<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>10. Concurrency Design Patterns</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch10"><a id="page_151"/>10. Concurrency Design Patterns</h2>
<p>In <a href="ch09.html#ch09">Chapter 9</a>, <em><a href="ch09.html#ch09">Goroutines</a></em>, we looked at a number of ways of synchronizing activities between goroutines, using patterns that are common in other languages. As with other facets of the language, there are some idioms that are natural in Go, but which would not make sense in another language.</p>
<p>Concurrency is a core part of Go. Spawning a new goroutine, which is roughly analogous to a thread, requires you to type three characters, including the space. The implementation of these goroutines in gc is similarly lightweight&#8212;slightly more than a function call but not much. In gccgo, it is equivalent to an operating system thread.</p>
<p>In the last chapter, we saw that Go has more or less the same set of synchronization primitives as the POSIX threads API. This means that <a id="page_152"/>you can take any algorithm designed for threads and implement it in Go very easily. Doing so is usually a bad idea, and is very rarely idiomatic Go. In this chapter, we&#8217;ll look at some of the techniques for designing scalable applications in Go.</p>
<h3 id="ch10lev1sec1">Timing Out Connections</h3>
<p class="pre">12&#160;&#160;<span class="EmpStrong">func</span> timeout(t <span class="EmpStrong">chan</span> bool) {<br/>13&#160;&#160;&#160;&#160;time.Sleep(5000000000)<br/>14&#160;&#160;&#160;&#160;t &lt;- true<br/>15&#160;&#160;}<br/>16<br/>17&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>18&#160;&#160;&#160;&#160;t := make(<span class="EmpStrong">chan</span> bool)<br/>19&#160;&#160;&#160;&#160;s := make(<span class="EmpStrong">chan</span> string)<br/>20&#160;&#160;&#160;&#160;<span class="EmpStrong">go</span> readString(s)<br/>21&#160;&#160;&#160;&#160;<span class="EmpStrong">go</span> timeout(t)<br/>22&#160;&#160;&#160;&#160;<span class="EmpStrong">select</span> {<br/>23&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> msg := &lt;- s:<br/>24&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Received: %s\n", msg)<br/>25&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> &lt;- t:<br/>26&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Timed out\n")<br/>27&#160;&#160;&#160;&#160;}<br/>28&#160;&#160;}</p>
<p class="example"><a id="ch10ex01"/>From: timeout.go</p>
<p>Go channels do not support a timeout automatically. This is intentional, because it&#8217;s difficult to design a timeout mechanism that is sufficiently general to be usable in all situations. Instead, Go provides a mechanism for you to implement timeouts yourself.</p>
<p><a id="page_153"/>The <span class="EmpStrong">select</span> statement allows you to wait for data from any channel. The example at the start of this section shows how to spawn a new goroutine to provide a timeout. This goroutine sleeps for five seconds and then sends a message back. The message itself is irrelevant. Here, we just use a boolean value, but it&#8217;s only the fact that the message is sent that matters, not its content.</p>
<p>The <span class="EmpStrong">select</span> statement here is used to time out a single connection. Either the first channel delivers a string within five seconds, or the timeout will cause anything that it sends to be ignored.</p>
<p>Note that we don&#8217;t close the channel that <code>readString()</code> will write to when the timeout occurs. If the <code>readString()</code> goroutine put a string into the channel in between closing it and exiting, then we&#8217;d get a runtime panic, which is not what we want. Instead, we silently discard the message that it sends.</p>
<p>That is not always the correct decision. If you want the other end to be able to know that an object has been freed, then it&#8217;s a good idea to close the channel. This allows the sender to handle the panic and clean up any resources related to generating the data. An even better solution would be to send a canceled message down another channel, so the goroutine knew that you&#8217;d get bored with waiting for it to finish.</p>
<p>In this example, we&#8217;re only timing out a single <a id="page_154"/>connection, but this same pattern works for an arbitrary number of channels in the <span class="EmpStrong">select</span> statement. You can implement the timeout signal more efficiently using a timer, as discussed in <a href="ch11.html#ch11">Chapter 11</a>, <em><a href="ch11.html#ch11">Dates and Times</a></em>.</p>
<h3 id="ch10lev1sec2">Aliased xor Mutable</h3>
<p>There is one rule that makes writing concurrent programs easy:</p>
<p><strong>No object should be both aliased and mutable.</strong></p>
<p>This is a general pattern for any language, but is particularly relevant to Go. Because Go uses a shared-everything model, you can pass pointers to objects down channels easily. You then have two concurrent goroutines that have references to the same object. If you haven&#8217;t been very careful, you now probably have some race conditions. If you&#8217;ve been slightly careful, you probably have the potential for deadlock.</p>
<p>If two goroutines try to modify the same object simultaneously, then you need to think very carefully about their possible interactions. As any experienced programmer knows, code that you need to think about carefully in order to be sure it is correct is most likely to be code that contains bugs.</p>
<p>To avoid this, follow a simple rule. If you ever pass a pointer through a channel, make sure that you immediately discard your copy of it.</p>
<p><a id="page_155"/>Passing a pointer through a channel should pass ownership of the pointee to the receiver.</p>
<p>The same rule applies to arguments passed when starting a new goroutine. The caller should not keep pointers to any objects that the new goroutine can modify.</p>
<p>You can use slices to enforce this when sharing an array between multiple goroutines. One fairly common use for parallelism is performing the same transformation on every element in an array. You can do this with a collection of goroutines, each working on a small range within the array. If you start each goroutine with a nonoverlapping slice of the array, then the array as a whole is only mutable from the calling goroutine. If it then waits for all modifications to complete, then your code is safe. It is not possible to expand a slice beyond its declared capacity, even if the underlying array has enough space to do so.</p>
<h3 id="ch10lev1sec3"><a id="page_156"/>Share Memory by Communicating</h3>
<p class="pre">&#160;5&#160;&#160;<span class="EmpStrong">type</span> request <span class="EmpStrong">struct</span> {<br/>&#160;6&#160;&#160;&#160;&#160;key int<br/>&#160;7&#160;&#160;&#160;&#160;value string<br/>&#160;8&#160;&#160;&#160;&#160;ret <span class="EmpStrong">chan</span> string<br/>&#160;9&#160;&#160;}<br/>10<br/>11&#160;&#160;<span class="EmpStrong">func</span> set(m <span class="EmpStrong">chan</span> request, key int, value string)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;string {<br/>12&#160;&#160;&#160;&#160;result := make(<span class="EmpStrong">chan</span> string)<br/>13&#160;&#160;&#160;&#160;m &lt;- request{key, value, result}<br/>14&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> &lt;-result<br/>15&#160;&#160;}<br/>16<br/>17&#160;&#160;<span class="EmpStrong">func</span> runMap(c <span class="EmpStrong">chan</span> request) {<br/>18&#160;&#160;&#160;&#160;m := make(<span class="EmpStrong">map</span>[int] string)<br/>19&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> {<br/>20&#160;&#160;&#160;&#160;&#160;&#160;req := &lt;- c<br/>21&#160;&#160;&#160;&#160;&#160;&#160;old := m[req.key]<br/>22&#160;&#160;&#160;&#160;&#160;&#160;m[req.key] = req.value<br/>23&#160;&#160;&#160;&#160;&#160;&#160;req.ret &lt;- old<br/>24&#160;&#160;&#160;&#160;}<br/>25&#160;&#160;}<br/>26<br/>27&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>28&#160;&#160;&#160;&#160;m := make(<span class="EmpStrong">chan</span> request)<br/>29&#160;&#160;&#160;&#160;<span class="EmpStrong">go</span> runMap(m)<br/>30&#160;&#160;&#160;&#160;fmt.Printf("Set %s\n", set(m, 1, "foo"))<br/>31&#160;&#160;&#160;&#160;fmt.Printf("Set %s\n", set(m, 1, "bar"))<br/>32&#160;&#160;}</p>
<p class="example"><a id="ch10ex02"/>From: sharedMap.go</p>
<p>Channel references are the primary exception to the rule from the last section. It is perfectly safe to share channel references between goroutines, <a id="page_157"/>because they provide implicit synchronization.</p>
<p>In a language like C or Java, you would typically implement a shared dictionary by creating a non-concurrent dictionary and a mutex lock. Whenever you wanted to manipulate the dictionary, you would acquire the lock, perform the manipulation, and then release the lock.</p>
<p>This pattern is possible in Go. The <em>sync package</em> provides a mutex implementation that can be used for this kind of task. This lets you enjoy all of the difficulties of lock-based programming that you&#8217;ve probably encountered in other languages.</p>
<p>If you are feeling lazy, and would prefer to spend your time worrying about the problems that your program is intended to solve, rather than about the minutiae of thread safety, then Go provides another alternative. The example at the start of this section provides a (very) simple implementation of a shared map. This uses channels for implicit synchronization.</p>
<p>This simple implementation only defines one operation, implemented in the <code>set()</code> function, which sets a new value and returns the old one.</p>
<p>The map itself is local to a goroutine. In a cleaner implementation, you would probably put the channel in an opaque interface and have a function that created the goroutine and the channel, rather than exposing the implementation details like this.</p>
<p>When you call the <code>set()</code> function, it creates a request, sends it across the channel, and <a id="page_158"/>then waits for the reply. The channel performs implicit synchronization for you. Requests sent across the channel are serialized, so there is no possibility of multiple concurrent accesses.</p>
<p>If you extend this map to have separate methods for setting and accessing values, then you can even benefit from concurrency. A set operation does not need to wait for a reply: it can simply push the key and value into the channel and return immediately. This set operation will complete after any pending operations in the queue.</p>
<p>From the perspective of the calling goroutine, any sequence of set and get operations will appear to be processed in sequence. If you do two set operations followed by a get, then only the get will block, and it won&#8217;t return until after the two set operations have completed. It is completely safe to access the map from multiple goroutines in this way, although you must take care if you want to ensure that updates from one goroutine are seen by another.</p>
<h3 id="ch10lev1sec4"><a id="page_159"/>Transactions by Sharing Channels</h3>
<p class="pre">36&#160;&#160;<span class="EmpStrong">func</span> HandleRequests(m <span class="EmpStrong">map</span>[int] string,<br/>37&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;c <span class="EmpStrong">chan</span> Request) {<br/>38&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> {<br/>39&#160;&#160;&#160;&#160;&#160;&#160;req := &lt;- c<br/>40&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">switch</span> (req.requestType) {<br/>41&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> Get:<br/>42&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;req.ret &lt;- m[req.key]<br/>43&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> Set:<br/>44&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;m[req.key] = req.value<br/>45&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> BeginTransaction:<br/>46&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;HandleRequests(m, req.transaction)<br/>47&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> EndTransaction:<br/>48&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span><br/>49&#160;&#160;&#160;&#160;&#160;&#160;}<br/>50&#160;&#160;&#160;&#160;}<br/>51&#160;&#160;}</p>
<p class="example"><a id="ch10ex03"/>From: transactionMap.go</p>
<p>One of the biggest problems with lock-based concurrency is that it is impossible to compose operations in a general way. Imagine that you have a thread-safe map implementation, with set and get operations that can be called from multiple threads and are guaranteed to be atomic. Now try to define an atomic increment operation in terms of these: It&#8217;s not possible.</p>
<p>An atomic increment operation needs to do a get, and then a modify, and then a set and needs to ensure that there are no other get or set operations happening until it completes. The simplest solution would be to add the atomic <a id="page_160"/>increment operation directly to the map and ensure that it holds the same lock that protects the get and set. When you need a more complex composite operation, then you need to further complicate your concurrent map.</p>
<p>This is difficult to get right. Fortunately, Go provides a much simpler mechanism. The <span class="romanAlt">transactionMap.go</span> example shows an extended version of the concurrent map from the example in the last section. This version defines operations to begin and end transactions.</p>
<div class="note"><hr/>
<p class="title"><a id="ch10note01"/>Note</p>
<p class="notepara">The sharedMap.go and transactionMap.go examples both use a structure for sending requests. In the second example, most of the requests only use some of the structure fields. This is not a significant overhead for a simple map, because the request structure is small, so you&#8217;re only wasting a few bytes if you only use half of it.</p>
<p class="notepara">For more complex data structures, you may want to consider using an interface type for requests. The interface would define an accessor to get the type, and an accessor to get specific request types. Each structure that implemented the interface would return either itself or <code>nil</code> from each accessor.</p>
<p class="notepara">If you encapsulate your concurrent data type behind a small set of public functions, then it&#8217;s very easy to switch between the two approaches.</p>
<hr/></div>
<p><a id="page_161"/>When you begin a transaction, the goroutine handling the map temporarily puts the channel to one side and starts listening for operations from the new one. This effectively gives the caller exclusive access to the map for a sequence of operations, until the transaction has been completed.</p>
<p class="pre-1">19&#160;&#160;<span class="EmpStrong">func</span> get(m <span class="EmpStrong">chan</span> Request, key int) string {<br/>20&#160;&#160;&#160;&#160;result := make(<span class="EmpStrong">chan</span> string)<br/>21&#160;&#160;&#160;&#160;m &lt;- Request{Get, key, "", result, nil}<br/>22&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> &lt;-result<br/>23&#160;&#160;}<br/>24&#160;&#160;<span class="EmpStrong">func</span> set(m <span class="EmpStrong">chan</span> Request, key int, value string) {<br/>25&#160;&#160;&#160;&#160;m &lt;- Request{Set, key, value, nil, nil}<br/>26&#160;&#160;}<br/>27&#160;&#160;<span class="EmpStrong">func</span> beginTransaction(m <span class="EmpStrong">chan</span> Request) <span class="EmpStrong">chan</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Request{<br/>28&#160;&#160;&#160;&#160;t := make(<span class="EmpStrong">chan</span> Request)<br/>29&#160;&#160;&#160;&#160;m &lt;- Request{BeginTransaction, 0, "", nil, t}<br/>30&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> t<br/>31&#160;&#160;}<br/>32&#160;&#160;<span class="EmpStrong">func</span> endTransaction(m <span class="EmpStrong">chan</span> Request) {<br/>33&#160;&#160;&#160;&#160;m &lt;- Request{EndTransaction, 0, "", nil, nil}<br/>34&#160;&#160;}</p>
<p class="example"><a id="ch10ex04"/>From: transactionMap.go</p>
<p>With this simple interface to the shared map, you can trivially implement an atomic append or atomic capitalize operation on the values held in the map. You just need to call <code>beginTransaction()</code>, then <code>get()</code>, perform whatever modification you wanted to make, and finally call <code>set()</code> and <code>endTransaction()</code>.</p>
<p><a id="page_162"/>This is a fairly primitive implementation of transactions. These transactions are blocking, and don&#8217;t support any form of rollback. A more complex implementation might create a new goroutine that handled all of the operations in the transaction on a copy of the map, and then passed the set of changes to the original. This would either merge them or reject them, depending on whether there were any conflicts.</p>
<h3 id="ch10lev1sec5">Concurrent Objects</h3>
<p class="pre">10&#160;&#160;<span class="EmpStrong">type</span> ConcurrentMap <span class="EmpStrong">struct</span> {<br/>11&#160;&#160;&#160;&#160;ch <span class="EmpStrong">chan</span> request<br/>12&#160;&#160;&#160;&#160;init sync.Once<br/>13&#160;&#160;}<br/>14&#160;&#160;<span class="EmpStrong">func</span> (cm *ConcurrentMap) Set(key int, value<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;string) string {<br/>15&#160;&#160;&#160;&#160;cm.init.Do(<span class="EmpStrong">func</span> () {<br/>16&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cm.ch = make(<span class="EmpStrong">chan</span> request)<br/>17&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">go</span> runMap(cm.ch)<br/>18&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;})<br/>19&#160;&#160;&#160;&#160;result := make(<span class="EmpStrong">chan</span> string)<br/>20&#160;&#160;&#160;&#160;cm.ch &lt;- request{key, value, result}<br/>21&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> &lt;-result<br/>22&#160;&#160;}</p>
<p class="example"><a id="ch10ex05"/>From: concurrentMap.go</p>
<p>It&#8217;s often convenient to use concurrency implicitly in Go. We&#8217;ve seen how to do that using some wrapper functions earlier in this chapter, but these still made the channel explicit.</p>
<p><a id="page_163"/>The example at the start of this section is a tidier version of the shared map from earlier. If you put this in a package, then users can use the <code>Set()</code> method without ever being aware of the way it is implemented. All that they know is that this is a shared map that can be used safely from multiple goroutines.</p>
<p>This pattern is very useful for testing, because it provides the same benefits as data hiding in other contexts. You can easily change the implementation of the concurrent map. You may want to implement another version using a simple mutex and compare the performance; being able to do this without modifying any code that uses the map is very useful.</p>
<p>The other advantage of using a structure, rather than a collection of functions, is that it lets you use interfaces. You could define a concurrent map and a non-shared map with the same interface, and code that didn&#8217;t care about thread safety could just use whichever one it was passed.</p>
<h3 id="ch10lev1sec6"><a id="page_164"/>Implementing Futures in Go</h3>
<p class="pre">&#160;6&#160;&#160;<span class="EmpStrong">type</span> futureInt64 <span class="EmpStrong">struct</span> {<br/>&#160;7&#160;&#160;&#160;&#160;ch <span class="EmpStrong">chan</span> int64<br/>&#160;8&#160;&#160;&#160;&#160;v int64<br/>&#160;9&#160;&#160;&#160;&#160;collect sync.Once<br/>10&#160;&#160;}<br/>11&#160;&#160;<span class="EmpStrong">func</span> (f *futureInt64) String() string {<br/>12&#160;&#160;&#160;&#160;f.collect.Do(<span class="EmpStrong">func</span>() { f.v = &lt;- f.ch })<br/>13&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> strconv.FormatInt(f.v, 10)<br/>14&#160;&#160;}<br/>15&#160;&#160;<span class="EmpStrong">func</span> fib(n int64) (int64, int64) {<br/>16&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> n &lt; 2 { <span class="EmpStrong">return</span> 1,1 }<br/>17&#160;&#160;&#160;&#160;f1, f2 := fib(n-1)<br/>18&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> f2, f1+f2<br/>19&#160;&#160;}<br/>20&#160;&#160;<span class="EmpStrong">func</span> Fib(n int64) fmt.Stringer {<br/>21&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> ch futureInt64<br/>22&#160;&#160;&#160;&#160;ch.ch = make(<span class="EmpStrong">chan</span> int64)<br/>23&#160;&#160;&#160;&#160;<span class="EmpStrong">go func</span>() {<br/>24&#160;&#160;&#160;&#160;&#160;&#160;_, f := fib(n)<br/>25&#160;&#160;&#160;&#160;&#160;&#160;ch.ch &lt;- f<br/>26&#160;&#160;&#160;&#160;}()<br/>27&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> &#38;ch<br/>28&#160;&#160;}<br/>29&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>30&#160;&#160;&#160;&#160;f := Fib(100)<br/>31&#160;&#160;&#160;&#160;fmt.Printf("The 100th Fibonacci number is: ")<br/>32&#160;&#160;&#160;&#160;fmt.Printf("%v\n", f)<br/>33&#160;&#160;}</p>
<p class="example"><a id="ch10ex06"/>From: futureFib.go</p>
<p>With goroutines, you can implement functions that run in the background. With channels, you can also collect their results asynchronously. The pattern shown at the start of this section shows how to implement <em>futures</em>, sometimes called <a id="page_165"/><em>promises</em>, in Go.</p>
<p>The <code>Fib()</code> function computes a number in the Fibonacci sequence, in a newly spawned goroutine, and returns a structure that implicitly synchronizes when it is accessed.</p>
<p>This simple return value only implements one method, declared in the <em>fmt package</em>, which converts a value to a string. For more complex return types, you&#8217;d need to create a more complex future type, which forwarded all of the declared messages to a field containing the real return value, once it had been received.</p>
<p>The advantage of this approach is that it allows a completely serial programming style, while still providing concurrency. Users of the <code>Fib()</code> function may act as if it is a purely sequential function, yet it will run in the background and only actually block the calling goroutine when it tries to use the return value.</p>
<p>As before, the amount of work done in the spawned goroutine is not really enough to justify creating a new goroutine. This pattern is more applicable where you have a bit more work to do.</p>
<h3 id="ch10lev1sec7"><a id="page_166"/>Coalescing Events</h3>
<p class="pre">&#160;6&#160;&#160;<span class="EmpStrong">func</span> later(deferRunning <span class="EmpStrong">chan</span> bool, delay time.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Duration, f <span class="EmpStrong">func</span>()) {<br/>&#160;7&#160;&#160;&#160;&#160;t := time.NewTimer(delay)<br/>&#160;8&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> {<br/>&#160;9&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">select</span> {<br/>10&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> cont := &lt;- deferRunning:<br/>11&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> cont {<br/>12&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t = time.NewTimer(delay)<br/>13&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} <span class="EmpStrong">else</span> {<br/>14&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;f()<br/>15&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span><br/>16&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>17&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> &lt;- t.C:<br/>18&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;f()<br/>19&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t = time.NewTimer(delay)<br/>20&#160;&#160;&#160;&#160;&#160;&#160;}<br/>21&#160;&#160;&#160;&#160;}<br/>22&#160;&#160;}<br/>23<br/>24&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>25&#160;&#160;&#160;&#160;deferRunning := make(<span class="EmpStrong">chan</span> bool)<br/>26&#160;&#160;&#160;&#160;buffer := ""<br/>27&#160;&#160;&#160;&#160;<span class="EmpStrong">go</span> later(deferRunning, 3000000000,<br/>28&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">func</span>() { fmt.Printf("User entered %s\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;buffer) })<br/>29&#160;&#160;&#160;&#160;b := make([]byte, 1)<br/>30&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> b[0] != '\n' {<br/>31&#160;&#160;&#160;&#160;&#160;&#160;os.Stdin.Read(b)<br/>32&#160;&#160;&#160;&#160;&#160;&#160;deferRunning &lt;- true<br/>33&#160;&#160;&#160;&#160;&#160;&#160;buffer += string(b)<br/>34&#160;&#160;&#160;&#160;}<br/>35&#160;&#160;&#160;&#160;deferRunning &lt;- false</p>
<p class="example"><a id="ch10ex07"/>From: idle.go</p>
<p>A common problem in interactive applications is running some code in the background in <a id="page_167"/>response to user input without increasing latency. For example, a text editor may want to run a spell checker or syntax highlighting task in the background. In theory, you want to do this after every keystroke, but if you spell check an entire document after every keystroke then you&#8217;re going to end up doing a lot of redundant work. A better solution, which is almost indistinguishable from the user&#8217;s perspective, is to run the background task after a few seconds (or a large fraction of a second) of inactivity.</p>
<p>The example at the start of this section shows how to do this. The program first spawns a background goroutine with a function to run when a timeout expires, a channel for deferring it, and a timeout. The function will be called a fixed delay after the last time it is deferred.</p>
<div class="note"><hr/>
<p class="title"><a id="ch10note02"/>Note</p>
<p class="notepara">Most UNIX systems implement buffering in the terminal. If you run this example from such a terminal then the program will not receive the input until you press Enter, so it will not defer execution of the background task.</p>
<hr/></div>
<p>This trivial example reads from the standard input, and defers execution of the background task until after it is completed. The task itself is also trivial, but you could easily replace it with something that did real work on the input.</p>
<h3 id="ch10lev1sec8"><a id="page_168"/>Map Reduce, Go Style</h3>
<p class="pre">17&#160;&#160;<span class="EmpStrong">func</span> Map(fileName string, intermediate <span class="EmpStrong">chan</span><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Partial) {<br/>18&#160;&#160;&#160;&#160;file, err := os.Open(fileName)<br/>19&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> err == nil {<br/>20&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> s scanner.Scanner<br/>21&#160;&#160;&#160;&#160;&#160;&#160;s.Init(file)<br/>22&#160;&#160;&#160;&#160;&#160;&#160;tok := s.Scan()<br/>23&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> tok != scanner.EOF {<br/>24&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;intermediate &lt;- Partial{s.TokenText(),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fileName}<br/>25&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;tok = s.Scan()<br/>26&#160;&#160;&#160;&#160;&#160;&#160;}<br/>27&#160;&#160;&#160;&#160;}<br/>28&#160;&#160;&#160;&#160;intermediate &lt;- Partial{"", ""}<br/>29&#160;&#160;}<br/>30<br/>31&#160;&#160;<span class="EmpStrong">func</span> Reduce(token string, files []string, final<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">chan</span> Result) {<br/>32&#160;&#160;&#160;&#160;counts := make(<span class="EmpStrong">map</span>[string] int)<br/>33&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> _, file := <span class="EmpStrong">range</span> files {<br/>34&#160;&#160;&#160;&#160;&#160;&#160;counts[file]++<br/>35&#160;&#160;&#160;&#160;}<br/>36&#160;&#160;&#160;&#160;final &lt;- Result{token, counts}<br/>37&#160;&#160;}</p>
<p class="example"><a id="ch10ex08"/>From: mapReduce.go</p>
<p>It seems fitting that a programming language developed by Google should make it easy to implement the concurrency pattern that made Google so successful: <em>Map Reduce</em>. This involves splitting an algorithm into two concurrent steps. One runs on chunks of the input and produces pairs of intermediate results; the other folds the intermediate results to produce a final result.</p>
<p><a id="page_169"/>The code at the start of this section shows the Go implementations of these two components for the canonical application of Map Reduce: indexing a set of files. In this case, it&#8217;s creating an index of the tokens used in the examples in this book. The map phase works on a single source file and generates a stream of (filename, token) pairs, which it then delivers as intermediate results.</p>
<p>Once the map phase has run, the reduce phase runs once for each token and counts the number of occurrences of the filename in the generated intermediate lists, providing a final result. You could use this to quickly search these source files: for each search term, you end up with a list of files and the number of times it occurs in that file.</p>
<p>The map and reduce functions are specific to the application of this pattern, but they need to be supported by some more generic code. In this example, the <code>collectIntermediates()</code> function does most of this work. This first collects the results from the <code>Map()</code> function and then spawns instances of the <code>Reduce()</code> function and finally delivers their collected results.</p>
<p>The <code>collectIntermediates()</code> function is quite simple. Hopefully you can follow it quite easily: it doesn&#8217;t contain anything that we haven&#8217;t looked at already, although it does combine quite a lot of parts of Go in one place. The <code>Map()</code> function will send some unknown number of <a id="page_170"/><a id="page_171"/>intermediate results as it runs. We use an empty pair as a placeholder indicating that it&#8217;s finished. The <code>collectIntermediates()</code> function is called with a known number of <code>Map()</code> goroutines, so it just decrements this count each time one finishes and then stops waiting for new results once it hits zero.</p>
<p class="pre-1">39&#160;&#160;<span class="EmpStrong">func</span> collectPartials(intermediate <span class="EmpStrong">chan</span> Partial,<br/>40&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count int,<br/>41&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;final <span class="EmpStrong">chan map</span>[string]<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">map</span>[string] int) {<br/>42&#160;&#160;&#160;&#160;intermediates := make(<span class="EmpStrong">map</span>[string] []string)<br/>43&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> count &gt; 0 {<br/>44&#160;&#160;&#160;&#160;&#160;&#160;res := &lt;- intermediate<br/>45&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> res.value == "" &#38;&#38; res.key == "" {<br/>46&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count--<br/>47&#160;&#160;&#160;&#160;&#160;&#160;} <span class="EmpStrong">else</span> {<br/>48&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;v := intermediates[res.key]<br/>49&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> v == nil {<br/>50&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;v = make([]string, 0, 10)<br/>51&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>52&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;v = append(v, res.value)<br/>53&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;intermediates[res.key] = v<br/>54&#160;&#160;&#160;&#160;&#160;&#160;}<br/>55&#160;&#160;&#160;&#160;}<br/>56&#160;&#160;&#160;&#160;collect := make(<span class="EmpStrong">chan</span> Result)<br/>57&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> token, files := <span class="EmpStrong">range</span> intermediates {<br/>58&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">go</span> Reduce(token, files, collect)<br/>59&#160;&#160;&#160;&#160;}<br/>60&#160;&#160;&#160;&#160;results := make(<span class="EmpStrong">map</span>[string] <span class="EmpStrong">map</span>[string] int)<br/>61&#160;&#160;&#160;&#160;// Collect one result <span class="EmpStrong">for</span> each goroutine we<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;spawned<br/>62&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> _, _ = <span class="EmpStrong">range</span> intermediates {<br/>63&#160;&#160;&#160;&#160;&#160;&#160;r := &lt;- collect<br/>64&#160;&#160;&#160;&#160;&#160;&#160;results[r.token] = r.counts<br/>65&#160;&#160;&#160;&#160;}<br/>66&#160;&#160;&#160;&#160;final &lt;- results<br/>67&#160;&#160;}</p>
<p class="example"><a id="ch10ex09"/>From: mapReduce.go</p>
<p>This part of the code builds a list of intermediate results for each token. When there are no more partial results to collect, it spawns a goroutine for each token to do the reduce step. This then passes back a map containing the number of times each word appears in a list. You could produce a better index by putting this into an array and sorting it by occurrences. I didn&#8217;t do that here, because it adds complexity without showing you any more that&#8217;s relevant to implementing the Map Reduce pattern.</p>
<p>After all of the reduce steps have run, this function again collects their results in a map and delivers it as the final result. This function is the only bit of serial code in this pattern; the map and reduce steps can run with a large degree of parallelism. As long as the work that they are doing is large in comparison with collecting the results, this approach can scale very well.</p>
<p>The program using this is quite simple. The <code>main()</code> function just spawns one copy of the <code>Map()</code> function for each <span class="romanAlt">.go</span> file and one copy of the <code>collectIntermediates()</code> function, joins them with channels, and waits for the result.</p>
<p>Most of the <code>main()</code> function is simply determining whether a file has a <span class="romanAlt">.go</span> suffix, and then printing the final results. As with most <a id="page_172"/>other things we&#8217;ve seen, the indexing step runs entirely in the background. This version just blocks waiting for the result to arrive on the <code>final</code> channel. It&#8217;s processing a relatively small amount of data, so will complete in a fraction of a second. If you passed it a larger input, then you could do something else while waiting for the background indexing to complete. This is a common pattern in API documentation or help viewers: they allow browsing while constructing the index.</p>
<p class="pre-1">69&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>70&#160;&#160;&#160;&#160;intermediate := make(<span class="EmpStrong">chan</span> Partial)<br/>71&#160;&#160;&#160;&#160;final := make(<span class="EmpStrong">chan map</span>[string] <span class="EmpStrong">map</span>[string] int)<br/>72&#160;&#160;&#160;&#160;dir, _ := os.Open(".")<br/>73&#160;&#160;&#160;&#160;names, _ := dir.Readdirnames(-1)<br/>74&#160;&#160;&#160;&#160;<span class="EmpStrong">go</span> collectPartials(intermediate, len(names),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;final)<br/>75&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> _, file := <span class="EmpStrong">range</span> names {<br/>76&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> (strings.HasSuffix(file, ".<span class="EmpStrong">go</span>")) {<br/>77&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">go</span> Map(file, intermediate)<br/>78&#160;&#160;&#160;&#160;&#160;&#160;} <span class="EmpStrong">else</span> {<br/>79&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;intermediate &lt;- Partial{"", ""}<br/>80&#160;&#160;&#160;&#160;&#160;&#160;}<br/>81&#160;&#160;&#160;&#160;}<br/>82&#160;&#160;&#160;&#160;result := &lt;- final<br/>83&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> token, counts := <span class="EmpStrong">range</span> result {<br/>84&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("\n\nToken: %v\n", token)<br/>85&#160;&#160;&#160;&#160;&#160;&#160;total := 0<br/>86&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> file, count := <span class="EmpStrong">range</span> counts {<br/>87&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("\t%s:%d\n", file, count)<br/>88&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;total += count<br/>89&#160;&#160;&#160;&#160;&#160;&#160;}<br/>90&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Total: %d\n", total)<br/>91&#160;&#160;&#160;&#160;}<br/>92&#160;&#160;}</p>
<p class="example"><a id="ch10ex10"/>From: mapReduce.go</p>
<p><a id="page_173"/>As with other Go patterns, there is no explicit synchronization in this example. We don&#8217;t even import the <em>sync package</em>: there are no mutexes, no condition variables, no wait groups. Synchronization happens implicitly via channels. In most Map Reduce implementations, the framework goes to a lot of effort to avoid spawning too many threads to run efficiently. The cheap concurrency in Go means that we don&#8217;t need to worry about that: we can just spawn a lot of goroutines and let the runtime sort it out.</p>
</body>
</html>