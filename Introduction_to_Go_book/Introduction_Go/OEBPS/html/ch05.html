<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>5. Arrays and Slices</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch05"><a id="page_79"/>5. Arrays and Slices</h2>
<p>Almost every programming language has a data structure that it calls an array, but the exact semantics vary considerably. In some languages, an array is a dynamically resizeable ordered collection of objects. In others, it&#8217;s a block of memory, with some vague hint that it probably contains variables of a specific type.</p>
<p>In Go, arrays are a very low-level data structure. Like C arrays, they are simply blocks of memory, but there are some important differences. Remember that Go does not permit pointer arithmetic. In C, array subscripting is just another way of writing pointer arithmetic, and you can use array and pointer types almost interchangeably.</p>
<p>In Go, pointers and arrays are distinct types. Because arrays and pointers are distinct, there is no such thing in Go as an arbitrary-sized array. The size of a Go array is intrinsic to its type. An array of 10 integers is a different type than an <a id="page_80"/>array of 5 integers.</p>
<p>One side effect of this is that there is automatic bounds checking with Go arrays. In C, you can trivially allocate an array of 10 elements, cast it to a pointer, access elements beyond the end of the array, and end up with undefined behavior.</p>
<p class="pre-1">1&#160;&#160;<span class="EmpStrong">package</span> main<br/>2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>3&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>4&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> a [2]int<br/>5&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i := 0 ; i&lt;15 ; i++ {<br/>6&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Element: %d %d\n", i, a[i])<br/>7&#160;&#160;&#160;&#160;}<br/>8&#160;&#160;}</p>
<p class="example"><a id="ch05ex01"/>From: overflow.go</p>
<p>The <span class="romanAlt">overflow.go</span> example shows a simple Go program that declares a small array and then tries to access past the end of it. The compiler doesn&#8217;t catch this as a static type error, because it isn&#8217;t doing enough range analysis to know that the index variable extends past the end of the array. The runtime system, however, does catch it.</p>
<p class="pre-1">1&#160;&#160;Element: 0 0<br/>2&#160;&#160;Element: 1 0<br/>3&#160;&#160;panic: runtime error: index out of range</p>
<p class="example"><a id="ch05ex02"/>Output from: overflow.go</p>
<p><a id="page_81"/>When you run this example, you get a runtime <em>panic</em>, which we&#8217;ll look at in more detail in <a href="ch08.html#ch08">Chapter 8</a>, <em><a href="ch08.html#ch08">Handling Errors</a></em>. This is a recoverable runtime error. A similar program in C would just silently access a random stack location. If you assigned to the variable, the C version would corrupt the stack, while the Go version would give you a helpful error.</p>
<p>Note that this is not a sensible idiom for iterating over an array. We&#8217;ll look at a better way of doing so later.</p>
<h3 id="ch05lev1sec1">Creating Arrays</h3>
<p class="pre">4&#160;&#160;<span class="EmpStrong">var</span> a1 [100]int<br/>5&#160;&#160;<span class="EmpStrong">var</span> matrix [4][4]float64<br/>6&#160;&#160;a2 := [...]int{1, 1, 2, 3, 5}</p>
<p class="example"><a id="ch05ex03"/>From: array.go</p>
<p>As mentioned earlier, the type of a Go array is a combination of its size and the type of its elements. This means that the size of the array must be known at compile time. That does not mean that it must be explicit. The third form of array declaration in the example at the start of this section shows how to create an array whose size is inferred. This creates an array of five integers, with a static type of <code>[5]int</code>.</p>
<p>Arrays can contain any types, including other arrays. The middle example creates an array of arrays of floating-point values. All arrays are <a id="page_82"/>values. If you assign from one array to another, you get a copy of the array.</p>
<p class="pre-1">1&#160;&#160;<span class="EmpStrong">package</span> main<br/>2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>3<br/>4&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>5&#160;&#160;&#160;&#160;a1 := [...]int{1, 2}<br/>6&#160;&#160;&#160;&#160;a2 := a1<br/>7&#160;&#160;&#160;&#160;a2[0] = 3<br/>8&#160;&#160;&#160;&#160;fmt.Printf("%d %d\n", a1[0], a2[0])<br/>9&#160;&#160;}</p>
<p class="example"><a id="ch05ex04"/>From: arrayAssign.go</p>
<p>Contrast this with C, where you can treat the name of the array as a pointer to its first element. This highlights an important philosophical difference between C and Go.</p>
<p class="pre-1">1&#160;&#160;1 3</p>
<p class="example"><a id="ch05ex05"/>Output from: arrayAssign.go</p>
<p>Copying an array is potentially very slow: it&#8217;s a linear time operation. Assigning a pointer, in contrast, is a very fast operation. C favors the fast operation by making it the default and requiring the programmer to explicitly state when he wants the slow operation.</p>
<p>Aliasing a data structure is fast, but it&#8217;s also a very common source of bugs, especially in concurrent code. Go, therefore, defaults to copying. <a id="page_83"/>Go makes it <em>possible</em> to write fast code, but makes it <em>easy</em> to write correct code. This is the opposite of the C philosophy, which makes it easy to write fast code and possible to write correct code.</p>
<h3 id="ch05lev1sec2">Slicing Arrays</h3>
<p class="pre">4&#160;&#160;<span class="EmpStrong">var</span> a1 [100]int<br/>5&#160;&#160;firstHalf := a1[:50]<br/>6&#160;&#160;secondHalf := a1[50:]<br/>7&#160;&#160;middle := a1[25:75]<br/>8&#160;&#160;all := a1[:]</p>
<p class="example"><a id="ch05ex06"/>From: slice.go</p>
<p>If you&#8217;ve looked at any C code, you&#8217;ll have noticed a common idiom: passing a pointer and a length as arguments to a function. This allows you to pass an array of an arbitrary size to a function. The downside of this approach is that it&#8217;s entirely informal. A typo can easily make you pass the wrong size, and then you&#8217;re back to memory corruption.</p>
<p>In Go, a much cleaner replacement for this idiom is formalized in the language. Rather than passing an array, or a pointer to the array, you pass a <em>slice</em>. A slice is a view on an array. If you&#8217;ve written JavaScript code with the WebGL extension, then this will be familiar to you: Go slices are conceptually similar to ArrayBufferView objects, while Go arrays are <a id="page_84"/>similar to ArrayBuffers.</p>
<p>If you compile with gccgo, then you can inspect the implementation of a slice easily. It&#8217;s just a C structure that stores a pointer to the array, its size, and its capacity.</p>
<div class="note"><hr/>
<p class="title"><a id="ch05note01"/>Note</p>
<p class="notepara">Slices have both a size and a capacity. The size is the number of array elements that you can access from that slice. The capacity is the maximum size slice that you can make by extending that slice, which is at most the size of the underlying array but may be less if you are using slices to restrict access to a range within an array. You can often ignore the capacity.</p>
<hr/></div>
<p>Slices are often used as function call parameters, because their size is a dynamic property, rather than an attribute of the type. If you use an array type as a function parameter, then the size is embedded in the type and callers can&#8217;t pass a larger array. If you use a slice type, then the caller can pass a reference to any size of memory allocation and the callee can test that it&#8217;s adequate.</p>
<p>There are other uses for slices. For example, you can use them to provide restricted range checking on an array. This can be a useful way of adding some sanity checking: use a slice of the array rather than the entire array and you can make sure that you didn&#8217;t accidentally exceed the bounds you thought were the limit.</p>
<p><a id="page_85"/>The syntax for creating slices from arrays (or other slices) is shown at the start of this section. Slices are created from ranges in existing arrays or slices, with the start and end indexes separated by a colon. If either of the indexes is omitted, then the slice extends to that end. As with most modern languages, Go arrays and slices are indexed from zero.</p>
<h3 id="ch05lev1sec3">Resizing Slices</h3>
<p class="pre">&#160;3&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;4&#160;&#160;&#160;&#160;s0 := make([]int, 2, 10)<br/>&#160;5&#160;&#160;&#160;&#160;s1 := append(s0, 2)<br/>&#160;6&#160;&#160;&#160;&#160;s2 := append(s0, 3)<br/>&#160;7&#160;&#160;&#160;&#160;fmt.Printf("Element: %d %d\n", s1[2], s2[2])<br/>&#160;8&#160;&#160;&#160;&#160;s0 = []int{0, 1}<br/>&#160;9&#160;&#160;&#160;&#160;s1 = append(s0, 2)<br/>10&#160;&#160;&#160;&#160;s2 = append(s0, 3)<br/>11&#160;&#160;&#160;&#160;fmt.Printf("Element: %d %d\n", s1[2], s2[2])<br/>12&#160;&#160;}</p>
<p class="example"><a id="ch05ex07"/>From: expandSlice.go</p>
<p>Resizing a slice is something of a misnomer. A slice itself is an immutable. You can&#8217;t expand a slice, but you can create a new slice that is a larger reference to the same array, or to a new, larger, array containing the same values.</p>
<p>It&#8217;s very important to be aware of exactly which of these operations you are preforming. Consider the example at the start of this section. It performs the same two <code>append()</code> operations on <a id="page_86"/>two different slices, both with the same size, but with very different results.</p>
<p class="pre-1">1&#160;&#160;Element: 3 3<br/>2&#160;&#160;Element: 2 3</p>
<p class="example"><a id="ch05ex08"/>Output from: expandSlice.go</p>
<p>The first slice has two elements, but a capacity of 10. This means that it is backed by an array of 10 elements, and just refers to the first two. The <code>append()</code> operation will create a new slice pointing to the same array, and set the next element in the array. The second <code>append()</code> operation does exactly the same thing. Slices <code>s1</code> and <code>s2</code> are both referencing the same underlying array, and the creation of <code>s2</code> modified <code>s1</code>.</p>
<p>The slice created with the <code>[]int{0, 1}</code> initializer has a capacity of two. The two <code>append()</code> operations now create a new array, copy the contents of the array that backs <code>s0</code> into it, and then set the third element.</p>
<p>You have to be very careful to think about aliasing when you use slices. If you have multiple slices referencing overlapping sections of a single array, then changes in one will be reflected in the others. Usually when you&#8217;re using slices, this is what you want.</p>
<h3 id="ch05lev1sec4"><a id="page_87"/>Truncating Slices</h3>
<p class="pre">3&#160;&#160;<span class="EmpStrong">func</span> truncate(slice []int) []int {<br/>4&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> s []int = make([]int, len(slice))<br/>5&#160;&#160;&#160;&#160;copy(s, slice)<br/>6&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> s<br/>7&#160;&#160;}</p>
<p class="example"><a id="ch05ex09"/>From: sliceShrink.go</p>
<p>Slices are just views on arrays. This means that they are very cheap to create; you just have to allocate a few words of memory describing the range within the array. This is a constant-time operation, independent of the size of the slice. In contrast, creating a copy of the array is a linear time operation, and so usually best avoided.</p>
<p>Quite often, you will use a slice for a dynamic buffer and, after a sequence of operations, end up with a small slice pointing to a large array. When this happens, it&#8217;s tempting to just use the small slice and forget about the large array.</p>
<p>Unfortunately, because slices refer to entire arrays, this means that the garbage collector will ensure that the array is not freed until the slice has been freed. If you allocate a 10MB array, it will remain in memory even if the only thing referencing it is a slice pointing to a one-value range.</p>
<p>The example at the start of this section shows a function that creates a new slice, backed by a new array, and then truncates it. If you use the result of this function, instead of the slice <a id="page_88"/>that you pass as an argument, the GC is free to delete the original array.</p>
<p>Be careful with the advice in this section. It&#8217;s tempting to fall prey to premature optimization and aggressively copy arrays. Always be aware of the lifespan of your new slice if you&#8217;re doing this. There&#8217;s no point copying a chunk of data just to allow the GC to collect an array a few milliseconds earlier. As always, profile first, and optimize second.</p>
<h3 id="ch05lev1sec5">Iterating Over Arrays</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;3&#160;&#160;<span class="EmpStrong">import</span> "time"<br/>&#160;4&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;5&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> a [100]int<br/>&#160;6&#160;&#160;&#160;&#160;// The slow way<br/>&#160;7&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i := 1 ; i &lt; 10 ; i++ {<br/>&#160;8&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Element %d is %d\n", i, a[i])<br/>&#160;9&#160;&#160;&#160;&#160;}<br/>10&#160;&#160;&#160;&#160;// The fast way<br/>11&#160;&#160;&#160;&#160;subrange := a[1:10]<br/>12&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i, v := <span class="EmpStrong">range</span> subrange {<br/>13&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Element: %d %d\n", i, v)<br/>14&#160;&#160;&#160;&#160;}<br/>15&#160;&#160;&#160;&#160;// The parallel way<br/>16&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i, v := <span class="EmpStrong">range</span> subrange {<br/>17&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">go</span> fmt.Printf("Element: %d %d\n", i, v)<br/>18&#160;&#160;&#160;&#160;}<br/>19&#160;&#160;&#160;&#160;time.Sleep(10000000)<br/>20&#160;&#160;}</p>
<p class="example"><a id="ch05ex10"/>From: iterate.go</p>
<p><a id="page_89"/>A few years ago, some researchers at IBM discovered that one of the main reasons for Java code being slower than C was the cost of bounds checking. Iterating over all of the elements in an array is a very common idiom in any language. In C, this is implemented just by adding the size of an element to a pointer value. In Java, and other high-level languages, it requires checking that the pointer value is in range as well.</p>
<p>A lot of research effort has gone into trying to remove these run-time bounds checks, but it&#8217;s not a trivial problem in the general case. You can improve performance a lot by helping the compiler and using idioms that allow it to perform the bounds check once per loop, rather than once per iteration.</p>
<p>The example at the start of this section shows three ways of iterating over part of an array. The first is a C-like way of doing it. The second is more idiomatic Go. Note the use of a slice to define a range within the array for iteration. You can use the entire array here in exactly the same way, but defining a slice allows you to iterate over a range within the array quickly and easily.</p>
<p>The third approach is the most interesting. This iterates over the array, with each loop iteration running in a separate goroutine. This pattern is most useful if you are doing a fairly significant amount of work with each element in the array.</p>
<p>More commonly, you&#8217;d want to mix these approaches. If you want to process a lot of <a id="page_90"/>elements in an array, then you can use slices to split it up into smaller chunks and then use a concurrent goroutine for each of the slices.</p>
</body>
</html>