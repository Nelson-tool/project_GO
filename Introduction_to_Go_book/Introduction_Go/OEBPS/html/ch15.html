<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>15. Interacting with the Go Runtime</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch15"><a id="page_219"/>15. Interacting with the Go Runtime</h2>
<p>One of the advantages of a dynamic language is that the internals of the implementation are exposed for your use. This lets you do various metaprogramming things that are much harder in static languages. The <em>go package</em> and its subpackages let you do very complex metaprogramming by transforming the abstract syntax tree of a Go program, but even without going that deep into the implementation there are lots of interesting things that you can do.</p>
<h3 id="ch15lev1sec1"><a id="page_220"/>Finding the Type of a Variable</h3>
<p class="pre">&#160;8&#160;&#160;<span class="EmpStrong">switch</span> t.Kind() {<br/>&#160;9&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> reflect.Int, reflect.Uint,<br/>10&#160;&#160;&#160;&#160;&#160;&#160;&#160;reflect.Int8, reflect.Int16,<br/>11&#160;&#160;&#160;&#160;&#160;&#160;&#160;reflect.Int32, reflect.Int64,<br/>12&#160;&#160;&#160;&#160;&#160;&#160;&#160;reflect.Uint8, reflect.Uint16,<br/>13&#160;&#160;&#160;&#160;&#160;&#160;&#160;reflect.Uint32, reflect.Uint64,<br/>14&#160;&#160;&#160;&#160;&#160;&#160;&#160;reflect.Uintptr:<br/>15&#160;&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%v is some kind of integer\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;v)<br/>16&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> reflect.Struct:<br/>17&#160;&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%#v is a structure\n", v)<br/>18&#160;&#160;&#160;&#160;&#160;&#160;&#160;r := reflect.TypeOf(<span class="EmpStrong">struct</span>{ io.Reader}{})<br/>19&#160;&#160;&#160;&#160;&#160;&#160;&#160;r = r.Field(0).Type<br/>20&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> t.Implements(r) {<br/>21&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%#v implements the io.Reader<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">interface</span>\n", v)<br/>22&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>23&#160;&#160;}</p>
<p class="example"><a id="ch15ex01"/>From: type.go</p>
<p>The <em>reflect package</em> provides true reflection. Reflection is a superset of introspection, but some languages that just provide support for introspection claim to support reflection. Introspection allows you to inspect low-level properties of various elements in a program, reflection allows you to modify them as well.</p>
<p>The simplest use for the reflect package is simple type introspection, querying a variable to find out its type. There are two important structures in the reflect package that you can use for this. These are <code>Type</code> and <code>Value</code>. The former encapsulates a type, the latter a value. You can <a id="page_221"/>construct either from an existing value.</p>
<p>Go&#8217;s reflection support is limited to values. You can&#8217;t construct new types at run time, but you can construct new values and modify existing ones using the reflection APIs. That&#8217;s usually enough, because constructing new types at run time has limited utility.</p>
<p>One of the slightly ugly parts of Go is that interfaces are not first-class values. This means that the only way of getting the type of an interface is indirectly. In the example at the start of this function, we get a <code>Type</code> structure for the <code>io.Reader</code> type by first getting one for an unnamed structure that has a field of this type, and then asking for the type of the field. It would be nice if we could just do something like:</p>
<p class="pre-n"><span class="EmpStrong">type</span> := reflect.TypeOf(io.Reader)</p>
<p>Unfortunately, in Go, only built-in functions can take types as arguments, and the reflection APIs are not built in. As an alternative, you might think about doing this:</p>
<p class="pre-n"><span class="EmpStrong">var</span> v io.Reader<br/><span class="EmpStrong">type</span> := reflect.TypeOf(v)</p>
<p>This also won&#8217;t work, because it&#8217;s the value that is passed to the function, not the variable. The value is <code>nil</code>, and so there is no way for the function to know that we meant <code>nil</code> interpreted as a <code>io.Reader</code>. The work around that we use is to create an anonymous structure like this:</p>
<p class="pre-n"><span class="EmpStrong">type</span> := reflect.TypeOf(<span class="EmpStrong">struct</span>{ io.Reader}{})</p>
<p><a id="page_222"/>This passes an empty instance of a structure that contains an <code>io.Reader</code> field. The <code>TypeOf()</code> function can then get the structure type, and we can then use its <code>Field()</code> method to get the type of the structure.</p>
<p>For primitive types, we just need to inspect the <code>Kind</code> field of the <code>Type</code>. If this corresponds to one of the primitive types, no further introspection is required: if something is an <code>int</code> then you already know everything about its type. If it is a structure, then you can inspect its fields, its methods, what interfaces it implements, and so on.</p>
<p>Note that, for simple cases (including the example at the start of this section), a type switch statement will achieve the same thing with significantly less overhead.</p>
<h3 id="ch15lev1sec2"><a id="page_223"/>Finalizing Structures</h3>
<p class="pre">&#160;5&#160;&#160;<span class="EmpStrong">type</span> example <span class="EmpStrong">struct</span> {<br/>&#160;6&#160;&#160;&#160;&#160;Str string<br/>&#160;7&#160;&#160;}<br/>&#160;8&#160;&#160;<span class="EmpStrong">func</span> finalizer(e *example) {<br/>&#160;9&#160;&#160;&#160;&#160;fmt.Printf("Finalizing %s\n", e.Str)<br/>10&#160;&#160;}<br/>11&#160;&#160;<span class="EmpStrong">func</span> NewExample() *example {<br/>12&#160;&#160;&#160;&#160;e := new(example)<br/>13&#160;&#160;&#160;&#160;runtime.SetFinalizer(e, finalizer)<br/>14&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> e<br/>15&#160;&#160;}<br/>16&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>17&#160;&#160;&#160;&#160;e := NewExample()<br/>18&#160;&#160;&#160;&#160;e.Str = "a structure"<br/>19&#160;&#160;&#160;&#160;e = NewExample()<br/>20&#160;&#160;&#160;&#160;runtime.GC()<br/>21&#160;&#160;}</p>
<p class="example"><a id="ch15ex02"/>From: finalize.go</p>
<p>Since Go is garbage collected, you don&#8217;t need to write destructors. Once an object is destroyed, the objects that it references will become unreachable and they will be collected automatically. Sometimes, however, you will create a structure that needs to do some explicit cleanup when it is destroyed.</p>
<p>In a lot of garbage-collected languages, there is explicit support at the language level for finalizers &#8212; methods that run automatically when an object is collected. Typically this takes the form of a specially named method.</p>
<p>Go lacks such support at the language level, <a id="page_224"/>for a good reason. Finalizers do not run deterministically, and so code that relies on them is usually wrong. They should only be used for <em>defensive programming</em>, in case the user of a structure forgets an explicit cleanup, not for things that must be run.</p>
<p>For example, the <code>File</code> structure in the <em>os package</em> registers a finalizer that closes the file descriptor. This means that you can forget to call <code>Close()</code> explicitly before allowing a <code>File</code> to be collected and you won&#8217;t run out of file descriptors. This is safe, because if the finalizer does not run then the operating system will close the file descriptor when the program exits. If code is required to run, for example to ensure on-disk consistency, then a finalizer is the wrong solution. This caveat does not usually apply to <span class="EmpStrong">defer</span> statements, because they will always execute unless the process image is corrupted.</p>
<p>In Go, finalizers are not methods, they are just functions. This has the interesting effect that different instances of a structure can have different finalizers, and they can even be closures.</p>
<p>The example at the start of this section shows a more conventional use for finalizers, where one is registered for every instance of a new structure when it is created. Note that we need to call the <code>NewExample()</code> function twice in this example for it to work.<sup><a id="ch15fn01" href="footnotes.html#ch15fn01a">1</a></sup> This is because there is still a <a id="page_225"/>reference on the stack left over from the last call to <code>NewExample()</code>.</p>
<p>This is a good example of why you should not rely on finalizers. If you change the second call to just set the value to <code>nil</code>, then intuitively you can see that the object is no longer referenced, but the finalizer may not be called. If the variable is set to <code>nil</code>, then the compiler notices that it is a dead store and simply removes the assignment, so <code>e</code> is left pointing to the old value. If you call <code>NewExample()</code>, then the compiler knows that this has side effects so won&#8217;t (currently) optimize it away. This is highly dependent on the implementation details of the compiler. Whether the finalizer runs depends on the implementation of the particular implementation of the compiler that you use, which should highlight how unreliable they are.</p>
<h3 id="ch15lev1sec3"><a id="page_226"/>Copying Arbitrary Types</h3>
<p class="pre">&#160;5&#160;&#160;<span class="EmpStrong">func</span> copyAny(inV, outV reflect.Value) {<br/>&#160;6&#160;&#160;&#160;&#160;t := inV.Type()<br/>&#160;7&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> t.Kind() != reflect.Struct {<br/>&#160;8&#160;&#160;&#160;&#160;&#160;&#160;outV.Set(inV)<br/>&#160;9&#160;&#160;&#160;&#160;} <span class="EmpStrong">else</span> {<br/>10&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i:=0 ; i&lt;t.NumField() ; i++ {<br/>11&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;copyAny(inV.Field(i), outV.Field(i))<br/>12&#160;&#160;&#160;&#160;&#160;&#160;}<br/>13&#160;&#160;&#160;&#160;}<br/>14&#160;&#160;}<br/>15&#160;&#160;<span class="EmpStrong">func</span> duplicate(in <span class="EmpStrong">interface</span>{}) <span class="EmpStrong">interface</span>{} {<br/>16&#160;&#160;&#160;&#160;outV := reflect.Indirect(reflect.New(reflect.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;TypeOf(in)))<br/>17&#160;&#160;&#160;&#160;copyAny(reflect.ValueOf(in), outV)<br/>18&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> outV.Interface()<br/>19&#160;&#160;}</p>
<p class="example"><a id="ch15ex03"/>From: copy.go</p>
<p>Copying is a surprisingly complex concept in programming languages. Copying a simple structure is trivial, just create a new bit of memory that contains the same values as the original. This becomes more complex when the structure references other values. Should copying recursively copy all referenced structures, or should it alias them? It gets even more complex when you think about external resources. Should copying a structure that encapsulates a file copy the file, or just give you another view into the same file? What about a socket?</p>
<p>Because if this difficulty in definition, the reflect package does not provide a single function <a id="page_227"/>for copying arbitrary types. The example at the start of this section defines a simple copy function using the reflect package. This is semantically equivalent to simple assignment in Go, although vastly less efficient. It walks structures, using their reflected values, and assigns each element in turn.</p>
<p>This example does not follow pointers, it just copies their value. You could try extending it to use the same techniques shown in the <code>duplicate()</code> function to create new instances of structures accessed by pointer and copy their contents. Although this example is quite simple, it shows most of the core functionality of the reflect package: you can use it to get the type of a value, construct a new instance of a type, and set a value independent of its type.</p>
<h3 id="ch15lev1sec4"><a id="page_228"/>Constructing Function Calls</h3>
<p class="pre">26&#160;&#160;z := big.NewInt(0)<br/>27&#160;&#160;z, isInt := z.SetString(s, 0)<br/>28&#160;&#160;<span class="EmpStrong">if</span> isInt {<br/>29&#160;&#160;&#160;&#160;stack = append(stack, z)<br/>30&#160;&#160;} <span class="EmpStrong">else</span> {<br/>31&#160;&#160;&#160;&#160;m, ok := findMethod(s, z)<br/>32&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> ok {<br/>33&#160;&#160;&#160;&#160;&#160;&#160;argc := m.Func.Type().NumIn()<br/>34&#160;&#160;&#160;&#160;&#160;&#160;last := len(stack)-1<br/>35&#160;&#160;&#160;&#160;&#160;&#160;argv := make([]reflect.Value, argc)<br/>36&#160;&#160;&#160;&#160;&#160;&#160;argv[0] = reflect.ValueOf(stack[last])<br/>37&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i:=0 ; i&lt;argc-1 ; i++ {<br/>38&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;argv[i+1] =reflect.ValueOf(stack[last-i<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;])<br/>39&#160;&#160;&#160;&#160;&#160;&#160;}<br/>40&#160;&#160;&#160;&#160;&#160;&#160;m.Func.Call(argv)<br/>41&#160;&#160;&#160;&#160;}<br/>42&#160;&#160;}</p>
<p class="example"><a id="ch15ex04"/>From: calc.go</p>
<p>The reflection interface allows you to fully use the power of a dynamic language. It is almost powerful enough to write a complete Go interpreter. The <span class="romanAlt">calc.go</span> example is a simple stack-based calculator that uses the <em>big package</em> to implement arithmetic.</p>
<p>The first thing that you should notice about this example is that it does not contain a command parser. When you run it, you can enter commands like Add or Sub, and it will apply them to the top elements on the stack, yet there is nothing parsing these commands in the code.</p>
<p class="pre-1">&#160;1&#160;&#160;123<br/>&#160;2&#160;&#160;[123]<br/>&#160;3&#160;&#160;456<br/>&#160;4&#160;&#160;[123 456]<br/>&#160;5&#160;&#160;Sub<br/>&#160;6&#160;&#160;[123 333]<br/>&#160;7&#160;&#160;Sub<br/>&#160;8&#160;&#160;[123 210]<br/>&#160;9&#160;&#160;90<br/>10&#160;&#160;[123 210 90]<br/>11&#160;&#160;Add<br/>12&#160;&#160;[123 210 300]</p>
<p class="example"><a id="page_229"/><a id="ch15ex05"/>Output from: calc.go</p>
<p>The commands that the user enters are mapped directly to methods. The <code>findMethod()</code> function uses reflection to find a method with the specified name and then this is called, again via the reflection interface.</p>
<p class="pre-1">&#160;9&#160;&#160;<span class="EmpStrong">func</span> findMethod(name string, value <span class="EmpStrong">interface</span>{}) (<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;reflect.Method, bool) {<br/>10&#160;&#160;&#160;&#160;t := reflect.TypeOf(value)<br/>11&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i:=0 ; i&lt;t.NumMethod() ; i++ {<br/>12&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> m := t.Method(i); m.Name == name {<br/>13&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> m, true<br/>14&#160;&#160;&#160;&#160;&#160;&#160;}<br/>15&#160;&#160;&#160;&#160;}<br/>16&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> reflect.Method{}, false<br/>17&#160;&#160;}</p>
<p class="example"><a id="ch15ex06"/>From: calc.go</p>
<h3 id="ch15lev1sec5"><a id="page_230"/>Calling C Functions</h3>
<p class="pre">1&#160;&#160;<span class="EmpStrong">package</span> arc4random<br/>2&#160;&#160;// #include &lt;stdlib.h&gt;<br/>3&#160;&#160;<span class="EmpStrong">import</span> "C"<br/>4<br/>5&#160;&#160;<span class="EmpStrong">func</span> arc4random() uint32 {<br/>6&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> uint32(C.arc4random())<br/>7&#160;&#160;}</p>
<p class="example"><a id="ch15ex07"/>From: cgo.go</p>
<p>Go, at least in the form of the Gc compiler, has a built-in foreign function call interface for supporting the de-facto lingua franca of the UNIX world: C. The <em>C pseudo-package</em> and associated tool provide a way of calling C directly from Go. This is very easy to use, in terms of source, but building code that uses cgo is slightly more complicated.</p>
<p>A cgo source file imports the C pseudo-package, immediately after some optional comments that specify include files, linker flags, and so on. The <span class="romanAlt">cgo</span> tool processes the source code and generates several files.</p>
<p class="pre-1">1&#160;&#160;$ go tool cgo cgo.go<br/>2&#160;&#160;$ ls _obj/<br/>3&#160;&#160;_cgo_.o&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;_cgo_export.h&#160;&#160;&#160;_cgo_main.c<br/>4&#160;&#160;_cgo_defun.c&#160;&#160;&#160;&#160;_cgo_flags&#160;&#160;&#160;&#160;&#160;&#160;cgo.cgo1.go<br/>5&#160;&#160;_cgo_export.c&#160;&#160;&#160;_cgo_gotypes.go cgo.cgo2.c</p>
<p class="example"><a id="ch15ex08"/>Output from: cgo</p>
<p><a id="page_231"/>The <span class="romanAlt">_cgo_defun.c</span> file contains the bridge code and must be compiled with the Plan 9 C compiler (<span class="romanAlt">6c</span> or similar, depending on the architecture). The other C files must be compiled with the system C compiler and the <span class="romanAlt">.go</span> file with the standard Go compiler.</p>
<div class="note"><hr/>
<p class="title"><a id="ch15note01"/>Note</p>
<p class="notepara">cgo is only officially supported when building packages, not when building programs. If you are using some C libraries, then you should compile wrap them in a Go package and use that from your program, rather than interleaving Go and C throughout your code.</p>
<hr/></div>
<p>This process is quite involved, and it&#8217;s better not to do it yourself. If you are using the standard go build system to build your package, which we&#8217;ll look at in <a href="ch16.html#ch16">Chapter 16</a>, <em><a href="ch16.html#ch16">Distributing Go Code</a></em>, then it will automatically invoke <span class="romanAlt">cgo</span> for every <span class="romanAlt">.go</span> file that imports the C package.</p>
</body>
</html>