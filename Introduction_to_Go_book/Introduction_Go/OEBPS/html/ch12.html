<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>12. Accessing Files and the Environment</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch12"><a id="page_183"/>12. Accessing Files and the Environment</h2>
<p>If you&#8217;re going to write any nontrivial Go code, eventually you will get to the point where you need to interact with things outside of your program. The most common mechanism for persistent storage on modern systems is the filesystem, and it&#8217;s quite rare to see a program that doesn&#8217;t need to read files, even if it isn&#8217;t writing any.</p>
<p>If you want to write portable code, the filesystem is one of the more tricky areas that you have to deal with. Any modern operating system provides a file store, which is a mapping from filenames to sequences of bytes. Beyond that, the semantics can vary considerably.</p>
<h3 id="ch12lev1sec1"><a id="page_184"/>Manipulating Paths</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;3&#160;&#160;<span class="EmpStrong">import</span> "path"<br/>&#160;4&#160;&#160;<span class="EmpStrong">import</span> "path/filepath"<br/>&#160;5<br/>&#160;6&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;7&#160;&#160;&#160;&#160;components := []string{"a", "path", "..", "with",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"relative", "elements"}<br/>&#160;8&#160;&#160;&#160;&#160;path := path.Join(components...)<br/>&#160;9&#160;&#160;&#160;&#160;fmt.Printf("Path: %s\n", path)<br/>10&#160;&#160;&#160;&#160;decomposed := filepath.SplitList(path)<br/>11&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> _, dir := <span class="EmpStrong">range</span> decomposed {<br/>12&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%s%c", dir, filepath.Separator)<br/>13&#160;&#160;&#160;&#160;}<br/>14&#160;&#160;&#160;&#160;fmt.Printf("\n")<br/>15&#160;&#160;}</p>
<p class="example"><a id="ch12ex01"/>From: path.go</p>
<p>File paths are one of the most common causes of headaches when porting code. These days, you generally only have to worry about Windows and UNIX paths, which use backslash and slash characters as separators, respectively. This is a significant improvement. Systems like MacOS Classic and VMS used other separators, and supporting all of them was quite complex.</p>
<p>When constructing a file path, you need to be careful to always use the correct separator. The <em>filepath package</em> allows you to do this yourself, using the <code>filepath.Separator</code> or <code>filepath.SeparatorString</code> constants. These store the character or string representation of <a id="page_185"/>the separator, respectively. It&#8217;s a good idea to use the string version, because you may find that you eventually want to run your Go code on a platform that uses a multicharacter separator, such as ::, although no such platforms are supported by the current implementation.</p>
<p>There are very few situations in which constructing a path using string manipulation is actually the right thing to do. In most cases, you want to use the <code>Join()</code> and <code>SplitList()</code> functions. These combine a slice of strings into a single string with the correct path separators and separate a string into its components, respectively.</p>
<p>Note how the <code>Join()</code> function is called in the example. This is an example of a <em>variadic function</em>, like <code>Printf()</code>. Unlike C, variadic functions in Go can be called either by an explicit argument list or by a slice. The <code>...</code> suffix on the slice indicates that it should be passed as the variadic argument set, rather than as a single argument. This appears redundant here, but it can be important. If the function accepted variadic arguments of the empty interface type, then the slice could be passed either as the argument list or as the only element in that list, and the ellipsis is required to disambiguate these two cases.</p>
<h3 id="ch12lev1sec2"><a id="page_186"/>Reading a File</h3>
<p class="pre">&#160;5&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;6&#160;&#160;&#160;&#160;file, err := os.Open("fileRead.<span class="EmpStrong">go</span>")<br/>&#160;7&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> err != nil{<br/>&#160;8&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Error: %s\n", err.Error())<br/>&#160;9&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span><br/>10&#160;&#160;&#160;&#160;}<br/>11&#160;&#160;&#160;&#160;buffer := make([]byte, 100)<br/>12&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> n, e := file.Read(buffer) ; e == nil ; n, e<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;= file.Read(buffer) {<br/>13&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> n &gt; 0 {<br/>14&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os.Stdout.Write(buffer[0:n])<br/>15&#160;&#160;&#160;&#160;&#160;&#160;}<br/>16&#160;&#160;&#160;&#160;}<br/>17&#160;&#160;}</p>
<p class="example"><a id="ch12ex02"/>From: fileRead.go</p>
<p>The <em>os package</em> contains a <code>File</code> type that encapsulates a file and allows you to access it. As with C&#8217;s <span class="romanAlt">stdio.h</span>, it also defines three always-extant instances of this type, one for each of the three standard channels.</p>
<p>The example at the start of this section shows a simple program that reads its source code and prints it to the standard output. This uses the <code>Open()</code> function, which always opens files for reading. If you need to write to a file, then you need to use the more general <code>OpenFile()</code> function and specify the <code>os.O_RDWR</code> flag or something similar.</p>
<p>At the lowest level, file I/O works via slices of bytes. A file is a sequence of bytes. Any more convenient interfaces must be built on top of this <a id="page_187"/>abstraction.</p>
<p>Remember that slices are immutable objects that represent mutable data, so the <code>Read()</code> function cannot modify the extent of the slice. When this program prints its output, it needs to slice <code>buffer</code> to the length that <code>Read()</code> indicated that it returned, unless the program length happens to be an exact multiple of the slice size.</p>
<p>When you reach the end of a file, <code>Read()</code> will return an <code>EOF</code> error and a zero length. In this example, we assume that the only read error is caused by reaching the end of the file, but for more complex uses you might want more robust error handling.</p>
<h3 id="ch12lev1sec3"><a id="page_188"/>Reading One Line at a Time</h3>
<p class="pre">13&#160;&#160;lineReader := bufio.NewReaderSize(file, 20)<br/>14&#160;&#160;<span class="EmpStrong">for</span> line, isPrefix, e := lineReader.ReadLine() ;<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;e==nil ;<br/>15&#160;&#160;&#160;&#160;line, isPrefix, e = lineReader.ReadLine() {<br/>16&#160;&#160;&#160;&#160;fmt.Printf("%.3d: ", lineNumber)<br/>17&#160;&#160;&#160;&#160;lineNumber++<br/>18&#160;&#160;&#160;&#160;os.Stdout.Write(line)<br/>19&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> isPrefix {<br/>20&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> {<br/>21&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;line, isPrefix, _ = lineReader.ReadLine()<br/>22&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os.Stdout.Write(line)<br/>23&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> !isPrefix { <span class="EmpStrong">break</span> }<br/>24&#160;&#160;&#160;&#160;&#160;&#160;}<br/>25&#160;&#160;&#160;&#160;}<br/>26&#160;&#160;&#160;&#160;fmt.Printf("\n")<br/>27&#160;&#160;}</p>
<p class="example"><a id="ch12ex03"/>From: lineRead.go</p>
<p>If you are reading a file containing binary data, then the techniques discussed in the last section are fine. If you are reading a text file, then you probably want to read one line at a time and then do some processing. The <em>bufio package</em> provides a reader that allows you to read a line at a time.</p>
<p>When you create a buffered reader with the <code>NewReaderSize()</code> function, it allocates an internal buffer. In this example, that buffer is 20 bytes long, which is enough for most, but not all, lines in this file. The reader will read into this buffer until it finds a line break, and then return a slice of the buffer.</p>
<p><a id="page_189"/>Because the slice is backed by the buffer, you must be careful to copy the data, not just the slice, if you want it to persist between calls to <code>ReadLine()</code>. This function returns three values. As well as the slice and the error code, it also returns a flag indicating whether the slice represents a partial line.</p>
<p>The example at the start of this section prints the source code for the program with line numbers, so it needs to be able to differentiate between reading a single line and reading part of a line. If the <code>isPrefix</code> flag is set, then it knows that it is reading part of a line. Subsequent calls to <code>ReadLine()</code> will return more of the line. The <code>isPrefix</code> flag remains set until it returns the last segment in a line.</p>
<p>If you&#8217;re using the line reader, then you will probably want a loop somewhat similar to the one shown in this example, with each iteration of the outer loop processing an entire line. It would be trivial to write a generic wrapper around this that builds a long array of bytes for the entire slice. This is not provided by default, because doing so means that feeding it a file with a single 1GB line would require you to read 1GB into memory. Although this interface is slightly harder to use, it has the advantage that it uses a deterministic amount of memory, making it much easier to reason about your code&#8217;s performance, independently of the data that it might be accessing.</p>
<h3 id="ch12lev1sec4"><a id="page_190"/>Determining if a File or Directory Exists</h3>
<p class="pre">&#160;6&#160;&#160;fmt.Printf("Enter a file name\n")<br/>&#160;7&#160;&#160;<span class="EmpStrong">var</span> s string<br/>&#160;8&#160;&#160;fmt.Scanf("%s", &#38;s)<br/>&#160;9&#160;&#160;fi, err := os.Stat(s)<br/>10&#160;&#160;<span class="EmpStrong">if</span> err != err {<br/>11&#160;&#160;&#160;&#160;fmt.Printf("%s does not exist!\n", s)<br/>12&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span><br/>13&#160;&#160;}<br/>14&#160;&#160;<span class="EmpStrong">if</span> fi.IsDir() {<br/>15&#160;&#160;&#160;&#160;fmt.Printf("%s is a directory\n", s)<br/>16&#160;&#160;}<br/>17&#160;&#160;mode := fi.Mode()<br/>18&#160;&#160;<span class="EmpStrong">if</span> mode &#38; os.ModeSymlink == os.ModeSymlink {<br/>19&#160;&#160;&#160;&#160;fmt.Printf("%s is a symbolic link\n", s)<br/>20&#160;&#160;}</p>
<p class="example"><a id="ch12ex04"/>From: isFile.go</p>
<p>Quite often, you will find that you need to check whether a file exists before you try to use it. This is not so important when you are accessing individual files: you can typically open them with a combination of flags that fails if they don&#8217;t exist. Even if a file does exist, it may not be usable. If it&#8217;s a directory or a link, for example, then you may want to interact with it in a different way than if it is a regular file. For example, if the user tells your program to open a directory, then you may wish to recursively open every file in the directory, rather than opening the directory as if it were a file.</p>
<p>The example at the start of this section checks <a id="page_191"/>whether a named file exists, and if it does then it also checks whether it is a directory or a symbolic link. This uses the Go <code>Stat()</code> function, which wraps the <code>stat()</code> system call and wraps the returned platform-dependent structure in a platform-independent Go structure.</p>
<p>In particular, you should note how we check whether a file is a symbolic link. The <code>Stat()</code> call will attempt to follow symbolic links. If it succeeds, then the returned structure will describe the file or directory at the end of the link, which won&#8217;t itself be a symbolic link, so its mode won&#8217;t have its symlink flag set. If, on the other hand, the file is a broken symlink, the returned structure will describe the link itself.</p>
<p>If you want to inspect a symbolic link directly, then you can use <code>Lstat()</code> instead. This is almost identical to <code>Stat()</code>, but it makes no attempt to follow links. As such, the result from this call will not let you tell whether the target of a link is a directory.</p>
<h3 id="ch12lev1sec5"><a id="page_192"/>Checking Environment Variables</h3>
<p class="pre">&#160;6&#160;&#160;<span class="EmpStrong">var</span> debugLevel int<br/>&#160;7<br/>&#160;8&#160;&#160;<span class="EmpStrong">func</span> debugLog(level int, msg string, args ...<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">interface</span>{}) {<br/>&#160;9&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> debugLevel &gt; level { fmt.Printf(msg, args<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;...) }<br/>10&#160;&#160;}<br/>11<br/>12&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>13&#160;&#160;&#160;&#160;debugLevel, _ = strconv.Atoi(os.Getenv("DEBUG")<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;)<br/>14&#160;&#160;&#160;&#160;debugLog(3, "Starting\n")<br/>15&#160;&#160;}</p>
<p class="example"><a id="ch12ex05"/>From: envDebug.go</p>
<p>Environment variables provide a fairly simple mechanism for setting some state for a program before it runs. The environment is a set of key-value pairs, which can be set on the command line or in code. When a program starts, it typically inherits the environment from its parent process, with any modifications that process made explicitly.</p>
<p>Environment variables can be useful for tunable parameters. The example at the start of this section sets an integer value indicating the debug level based on the value of an environment variable. If this environment variable is not set, then the <code>Getenv()</code> call will return the empty string and <code>Atoi</code> will return 0, so the default debug level is zero. If you want a different default, then you would need to explicitly set <a id="page_193"/>it.</p>
<p class="pre-1">1&#160;&#160;$ ./6.out<br/>2&#160;&#160;$ DEBUG=4 ./6.out<br/>3&#160;&#160;Starting</p>
<p class="example"><a id="ch12ex06"/>Output from: envDebug.go</p>
<p>The environment is stored as an array of strings in the <code>os.Envs</code> variable. The <code>Getenv()</code> function, on its first call, copies the environment variables into a map, so subsequent lookups only require a map lookup, rather than a linear search. It&#8217;s still relatively expensive to do a map lookup and then parse a decimal string, though, so this program caches the result.</p>
<p>Whether you need to do this kind of caching depends on the format of the data and how often it&#8217;s called. A debug logging function is expected to be called quite often, and should return quickly if it is not used. Looking up the environment variable and parsing the integer value for every call would be expensive. In other cases, this is not important because the code looking up the environment variable either wants to access the string directly, is called infrequently, or does something so expensive that it&#8217;s not worth optimizing this small part of it.</p>
</body>
</html>