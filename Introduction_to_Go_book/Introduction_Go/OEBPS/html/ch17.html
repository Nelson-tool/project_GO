<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>17. Debugging Go</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch17"><a id="page_243"/>17. Debugging Go</h2>
<p>In an ideal world, you would write Go code, compile it, and then it would work perfectly the first time. In fact, you&#8217;ll probably find that this is quite common. Go is designed so that there is little ambiguity in the source code, eliminating a lot of common bugs.</p>
<p>Go is still a relatively young language, so it doesn&#8217;t have quite the same level of debugging support of more mature languages. People have been writing buggy C and C++ code for decades, so there are lots of tools available to help them.</p>
<h3 id="ch17lev1sec1">Using a Debugger</h3>
<p>Go versions prior to 1.0 included a debugger called <span class="romanAlt">ogle</span>. This is named after a company named something like Go ogle that has funded a lot of the development of Go. This was not ready in time for the 1.0 release, so it was <a id="page_244"/>removed. Current versions of Go produce DWARF debugging metadata, the same format used by compilers for other languages. There are some Go packages for parsing this, so <span class="romanAlt">ogle</span> may be resurrected in the future. Until then you can debug Go code with a recent version of the <em>GNU Debugger (GDB)</em>.</p>
<p>Unfortunately, Go is only supported by version 7.1 and later of <span class="romanAlt">gdb</span>. This version is released under version 3 of the GNU General Public License and so is not shipped by default on Mac OS X or FreeBSD, only on GNU/Linux. If you are using another platform then you will have to download and compile it yourself.</p>
<div class="note"><hr/>
<p class="title"><a id="ch17note01"/>Note</p>
<p class="notepara">On OS X, debuggers (and any other programs that inspect another process&#8217;s memory state) must be explicitly authorized. You can find instructions for configuring gdb here: <a href="http://sourceware.org/gdb/wiki/BuildingOnDarwin">http://sourceware.org/gdb/wiki/BuildingOnDarwin</a></p>
<hr/></div>
<p>To start <span class="romanAlt">gdb</span>, just pass it the name of your compiled Go code. We&#8217;ll take a look at a slightly modified version of the <span class="romanAlt">overflow.go</span> example from <a href="ch05.html#ch05">Chapter 5</a>, <em><a href="ch05.html#ch05">Arrays and Slices</a></em>, which showed a runtime panic caused by attempting to access a value out of the permitted range in an array. The modified version, <span class="romanAlt">sliceOverflow.go</span>, does the same thing but with a slice into the array, rather than the array itself, so that we can look at slices in the debugger.</p>
<p><a id="page_245"/>When we run this, in or out of the debugger, we get a run-time panic. We can put a breakpoint on <code>runtime.panic</code> to catch all of these, but this specific one is an index-related panic, so we start by putting the breakpoint on <code>runtime.panicindex</code>. Don&#8217;t worry about remembering this: it shows up on the stack trace generated on the crash.</p>
<p class="pre-1">&#160;1&#160;&#160;$ gdb 6.out<br/>&#160;2&#160;&#160;(gdb) source ~/go/src/pkg/runtime/runtime-gdb.py<br/>&#160;3&#160;&#160;Loading Go Runtime support.<br/>&#160;4&#160;&#160;(gdb) <span class="EmpStrong">break</span> runtime.panicindex<br/>&#160;5&#160;&#160;Breakpoint 1 at 0xfe09: file go/src/pkg/runtime/<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;runtime.c, line 80.<br/>&#160;6&#160;&#160;(gdb) run<br/>&#160;7&#160;&#160;Breakpoint 1, runtime.panicindex ()<br/>&#160;8&#160;&#160;&#160;&#160;&#160;&#160;at go/src/pkg/runtime/runtime.c:80<br/>&#160;9&#160;&#160;80&#160;&#160;runtime&#183;panicindex(void)<br/>10&#160;&#160;(gdb) up<br/>11&#160;&#160;<span class="EmpItalic">#1&#160;&#160;0x000000000000209a in main.main ()</span><br/>12&#160;&#160;&#160;&#160;&#160;&#160;at overflow.go:6<br/>13&#160;&#160;7&#160;&#160;&#160;&#160;&#160;fmt.Printf(<span class="EmpItalic">"Element: %d %d\n"</span>, i, a[i])<br/>14&#160;&#160;(gdb) info locals<br/>15&#160;&#160;i = 1<br/>16&#160;&#160;slc =&#160;&#160;[]int = {0}<br/>17&#160;&#160;(gdb) p $len(slc)<br/>18&#160;&#160;$1 = 1</p>
<p class="example"><a id="ch17ex01"/>Output from: gdb</p>
<p>The debugger does not have native support for interpreting Go types; this is provided by some extensions written in Python and automatically interprets Go types for us. These appear in the debug metadata as typedefs of a format that the <a id="page_246"/>script can spot and interpret.</p>
<p>When we run the code in the debugger it stops where we put the breakpoint: on the function in the Go runtime that generates the panic. This isn&#8217;t a very interesting thing to look at, so we go up to the stack frame that actually caused the panic and look at the local variables, with the <span class="romanAlt">info locals</span> command.</p>
<p>There are three locals in this function: an index, an array, and a slice. Only two appear in the debugger, because the optimizer has already removed the array. From here, it&#8217;s obvious what the problem is: the index we are using is 1, but the slice only has one element (at index 0), so this is out of range.</p>
<p>To make absolutely certain, we can check the length and capacity of the slice with the <code>$len</code> and <code>$cap</code> functions provided by the Python script.</p>
<p>The GNU debugger is very powerful. You can, for example, configure breakpoints to only trigger when a specific condition is met, or break when a specific region in memory is touched. A full description of all of these features is far beyond the scope of this book. Check the <span class="romanAlt">gdb</span> manual for more details.</p>
<h3 id="ch17lev1sec2"><a id="page_247"/>Misunderstanding Memory Ordering</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;3<br/>&#160;4&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;5&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> s string<br/>&#160;6&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> flag bool<br/>&#160;7&#160;&#160;&#160;&#160;<span class="EmpStrong">go func</span>() {<br/>&#160;8&#160;&#160;&#160;&#160;&#160;&#160;fmt.Scanf("%s", &#38;s)<br/>&#160;9&#160;&#160;&#160;&#160;&#160;&#160;flag = true<br/>10&#160;&#160;&#160;&#160;}()<br/>11&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> !flag {}<br/>12&#160;&#160;&#160;&#160;fmt.Printf("%s\n", s)<br/>13&#160;&#160;}</p>
<p class="example"><a id="ch17ex02"/>From: orderingBug.go</p>
<p>The Go memory model makes it quite easy to write concurrent code that doesn&#8217;t do quite what you expect. Consider the example at the start of this section. If you look quickly at this code, you might expect it to spawn a new goroutine that waits for user input and spin until this input is received. When the input is received, the spawned goroutine will set the flag and the main goroutine will continue.</p>
<p>In fact, I have no idea what will happen if you try to run this code. When I run it, it asks for input and then infinite loops. According to the Go specification, printing an empty string and then exiting without ever waiting would also be valid behavior.</p>
<p><a id="page_248"/>This is because Go places very weak constraints on the observability of changes to memory between goroutines. The compiler is completely free to reorder the setting of <code>flag</code> to before the setting of <code>s</code> within the spawned goroutine. It is also free to completely eliminate the setting of <code>flag</code>, because it is a dead store within the scope of this goroutine.</p>
<p>This weak ordering requirement is quite irritating when you first start using Go, but it has two significant advantages. The first is that the Go compiler is free to be very aggressive about optimizing code, without having to do complex concurrency modeling. The more important benefit is that it strongly discourages you from writing code like this, which depends on subtle interactions between shared resources.</p>
<p>The <span class="romanAlt">fixedOrdering.go</span> example shows an idiomatic Go version of the same program. This is shorter, doesn&#8217;t do busy waiting (so doesn&#8217;t waste CPU and battery power), and is much easier to reason about and debug.</p>
<p class="pre-1">&#160;5&#160;&#160;s := make(<span class="EmpStrong">chan</span> *string)<br/>&#160;6&#160;&#160;<span class="EmpStrong">go func</span>() {<br/>&#160;7&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> buffer string<br/>&#160;8&#160;&#160;&#160;&#160;fmt.Scanf("%s", &#38;buffer)<br/>&#160;9&#160;&#160;&#160;&#160;s &lt;- &#38;buffer<br/>10&#160;&#160;}()<br/>11&#160;&#160;fmt.Printf("%s\n", *(&lt;-s))</p>
<p class="example"><a id="ch17ex03"/>From: fixedOrdering.go</p>
<p><a id="page_249"/>The easiest way of avoiding this kind of bug is simply to avoid sharing memory between goroutines. In Go, this is easy because you can always use channels to communicate. You can, of course, pass pointers between goroutines via channels. The fixed example does this, which avoids the need to copy the data down the channel, so the overhead is relatively small.</p>
<h3 id="ch17lev1sec3">Spotting Concurrency Bugs</h3>
<p class="pre">11&#160;&#160;c.count += in.Increment<br/>12&#160;&#160;out.Value = c.count<br/>13&#160;&#160;<span class="EmpStrong">return</span> nil</p>
<p class="example"><a id="ch17ex04"/>From: server.go</p>
<p>The example above is a snippet from an earlier example, and shows the most common silent error in Go code. As a stand-alone function, this is fine. Unfortunately, it is not thread-safe and it is called from multiple goroutines.</p>
<p>The offending line is the increment statement. This will compile to a load, add, store sequence. If the goroutine is interrupted in the middle, then two versions of this function could load the same value, perform the addition, and then store the result, losing one of the adds.</p>
<p>This is an example of a race condition and is caused by violating the mutable-xor-shared principle, as discussed in <a href="ch10.html#ch10">Chapter 10</a>, <em><a href="ch10.html#ch10">Concurrency Design Patterns</a></em>. There are several <a id="page_250"/>ways of fixing this. We looked at one in the section <em>Integrating with a Web Server</em> in <a href="ch14.html#ch14">Chapter 14</a>, <em><a href="ch14.html#ch14">Web Applications</a></em>, where the shared integer was replaced with a channel that produced a sequence of integers. Another solution is to replace the <code>+=</code> with a call to <code>atomic.AddInt32()</code> or <code>atomic.AddInt64()</code>.</p>
<p>The latter solution is faster, but it requires you to make sure that you use atomic operations every time you modify the shared value. The former solution is simpler, because the value is then no longer shared and so it is very hard to create a race condition around it.</p>
<p>There are still some concurrent problems that can occur with channels. The most common is caused by the lack of guaranteed delivery. Channels are buffered, so just because a send operation has succeeded does not mean that the value has been delivered anywhere. We saw an example of that in the section <em>Distributing Go</em> in <a href="ch13.html#ch13">Chapter 13</a>, <em><a href="ch13.html#ch13">Network Access</a></em>. That example involved a channel being forwarded over a network, but the same principle applies elsewhere. If the receiving end of a channel loses its reference then any objects still in the channel buffer will be garbage collected.</p>
<p>If you need to make sure that values that you send are really received, then you need an extra layer of buffering. When you send a message, you store a copy of it until you receive an acknowledgment. If the acknowledgment is not <a id="page_251"/>received, then you need some error handling code.</p>
<p>The synchronous nature of Go channels also means that they are potentially prone to <em>deadlock</em>. If two goroutines are waiting for each other to send data down a channel then you have deadlock. This is the simplest case, but it&#8217;s possible to have quite complex dependency graphs.</p>
<p>There are several ways to try to avoid this problem. The simplest is to arrange your communication into request-response hierarchies, so no goroutine can depend on data from a node closer to the root of the tree. This can be quite difficult to arrange, but hopefully most of your goroutines will be leaf nodes, which don&#8217;t depend on any others to be able to send a response.</p>
<h3 id="ch17lev1sec4"><a id="page_252"/>Restricting Behavior</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> example<br/>&#160;2<br/>&#160;3&#160;&#160;<span class="EmpStrong">type</span> Public <span class="EmpStrong">interface</span> {<br/>&#160;4&#160;&#160;&#160;&#160;Name() string<br/>&#160;5&#160;&#160;}<br/>&#160;6<br/>&#160;7&#160;&#160;<span class="EmpStrong">type</span> Example <span class="EmpStrong">struct</span> {<br/>&#160;8&#160;&#160;&#160;&#160;name string<br/>&#160;9&#160;&#160;}<br/>10&#160;&#160;<span class="EmpStrong">func</span> (e Example) Nme() string {<br/>11&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> e.name<br/>12&#160;&#160;}<br/>13<br/>14&#160;&#160;<span class="EmpStrong">func</span> NewExample() Example {<br/>15&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> Example{"No Name"}<br/>16&#160;&#160;}</p>
<p class="example"><a id="ch17ex05"/>From: conformanceError.go</p>
<p>When you start debugging, you have a large set of things that can possibly go wrong. Anything that you can do to reduce the number of possible things that can go wrong is helpful. This is the main reason why Go encourages you to use channels rather than shared memory for communication: it dramatically reduces the number of possible interactions, and therefore the number of places for bugs to hide.</p>
<p>When you start debugging, it&#8217;s always helpful to make sure that the code is doing what you think it is doing. Go doesn&#8217;t provide a built-in mechanism for assert statements, for two good reasons: they are often used as a crutch to avoid <a id="page_253"/>proper error handling, and their presence in test code can cause tests to be skipped.</p>
<p>Part of the aim of omitting assertions was to encourage Go developers to write proper error-handling code. In Go, it&#8217;s usually quite obvious when you&#8217;re skipping error handling, because you have function calls that return multiple values, some of which are ignored. The first thing to do is check that you are properly handling errors, even ones that you think are unlikely to occur.</p>
<p>Type-related errors in Go are relatively uncommon, but are still possible. The example at the start of this section shows a (contrived) simple interface and an implementation of this interface, with a bug. The bug is a typo in the <code>Name()</code> method: something very easy to do.</p>
<p>When you compile this, it reports no errors, but something later trying to assign the concrete implementation to the interface will break. If the assignment happens via the empty interface, for example by inserting the structure into a collection and then retrieving it, then it may not be caught until some time later.</p>
<p>The <span class="romanAlt">fixedConformanceError.go</span> example shows two possible ways of making the compiler detect this for you.</p>
<p>The first is to simply make the function return an interface type. This is only really viable if callers will only want to access the type via methods exported through the interface. If this is acceptable, then you should also consider making the concrete type private and only exporting it via the interface.</p>
<p class="pre-1">14&#160;&#160;<span class="EmpStrong">func</span> NewExample() Public {<br/>15&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> Example{"No Name"}<br/>16&#160;&#160;}<br/>17&#160;&#160;<span class="EmpStrong">func</span> NewExample2() Public {<br/>18&#160;&#160;&#160;&#160;e := Example{"No Name"}<br/>19&#160;&#160;&#160;&#160;e.(Public)<br/>20&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> e<br/>21&#160;&#160;}</p>
<p class="example"><a id="page_254"/><a id="ch17ex06"/>From: fixedConformanceError.go</p>
<p class="pre-1">1&#160;&#160;$ 6g fixedConformanceError.go<br/>2&#160;&#160;fixedConformanceError.go:15: Example.Name is a<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;field, not a method<br/>3&#160;&#160;fixedConformanceError.go:15: cannot use struct<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;literal (type Example) as type Public in<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> argument:<br/>4&#160;&#160;&#160;&#160;Example does not implement Public (missing Name<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;method)<br/>5&#160;&#160;fixedConformanceError.go:19: invalid type<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;assertion: e.(Public) (non-interface type<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Example on left)<br/>6&#160;&#160;fixedConformanceError.go:20: Example.Name is a<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;field, not a method<br/>7&#160;&#160;fixedConformanceError.go:20: cannot use e (type<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Example) as type Public in <span class="EmpStrong">return</span> argument:<br/>8&#160;&#160;&#160;&#160;Example does not implement Public (missing Name<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;method)</p>
<p class="example"><a id="ch17ex07"/>Output from: fixedConformanceError.go</p>
<p>The other option is to add a <em>type assertion</em>. This <a id="page_255"/>tells the compiler that you think that the type that you have conforms to the specified interface. The compiler checks this, and tells you that your assumption is wrong. If the compiler can&#8217;t check the type requirement accurately, then it will insert a run-time check.</p>
<p>It&#8217;s also a good idea to use slices to enforce range checking. The <span class="romanAlt">overflowError.go</span> example shows a simple error, where you accidentally overwrite a range in an array with a subsequent call.</p>
<p class="pre-1">&#160;4&#160;&#160;<span class="EmpStrong">func</span> setRange(i, j int, slice []int) {<br/>&#160;5&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> n:=0 ; i&lt;j ; i++ {<br/>&#160;6&#160;&#160;&#160;&#160;&#160;&#160;slice[n] = i<br/>&#160;7&#160;&#160;&#160;&#160;&#160;&#160;n++<br/>&#160;8&#160;&#160;&#160;&#160;}<br/>&#160;9&#160;&#160;}<br/>10<br/>11&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>12&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> arr [100]int<br/>13&#160;&#160;&#160;&#160;setRange(20, 50, arr[20:])<br/>14&#160;&#160;&#160;&#160;setRange(50, 80, arr[:])<br/>15&#160;&#160;&#160;&#160;fmt.Printf("Array: %v\n", arr)<br/>16&#160;&#160;}</p>
<p class="example"><a id="ch17ex08"/>From: overflowError.go</p>
<p>This example is trivial, but it&#8217;s fairly common to see concurrent goroutines accessing parts of an array like this. The fix is quite simple. If you specify exact ranges in the slice, as in <span class="romanAlt">fixedOverflowError.go</span>, then the code will panic if it tries to access part of the array beyond the <a id="page_256"/>range specified with the slice.</p>
<p class="pre-1">11&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>12&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> arr [100]int<br/>13&#160;&#160;&#160;&#160;setRange(20, 50, arr[20:50])<br/>14&#160;&#160;&#160;&#160;setRange(50, 80, arr[0:19])<br/>15&#160;&#160;&#160;&#160;fmt.Printf("Array: %v\n", arr)<br/>16&#160;&#160;}</p>
<p class="example"><a id="ch17ex09"/>From: fixedOverflowError.go</p>
<p>It&#8217;s worth using this facility whenever you are tempted to pass a slice to a function. Restrict the range to the part that you expect to be modified, and you&#8217;ll get a hard error, which is easy to pinpoint and debug, if it goes over. If the broken example had used two concurrent goroutines, rather than two synchronous calls, then it would have generated the expected result some times, but not others, depending on the order in which the two goroutines were scheduled. This kind of bug is very hard to find and fix.</p>
<h3 id="ch17lev1sec5"><a id="page_257"/>Building Unit Tests</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> eg<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "testing"<br/>&#160;3<br/>&#160;4&#160;&#160;<span class="EmpStrong">func</span> TestExample(t *testing.T) {<br/>&#160;5&#160;&#160;&#160;&#160;e := NewExample()<br/>&#160;6&#160;&#160;&#160;&#160;&#160;&#160;// Don't do this!<br/>&#160;7&#160;&#160;&#160;&#160;_ = e.(*concreteType)<br/>&#160;8&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> e.Name() != "Concrete <span class="EmpStrong">type</span>" {<br/>&#160;9&#160;&#160;&#160;&#160;&#160;&#160;t.Fail()<br/>10&#160;&#160;&#160;&#160;}<br/>11&#160;&#160;&#160;&#160;t.Errorf("This test is buggy")<br/>12&#160;&#160;}</p>
<p class="example"><a id="ch17ex10"/>From: eg/eg_test.go</p>
<p>Go includes a simple but powerful unit test framework. The <span class="romanAlt">eg_test.go</span> file shows a simple set of unit tests for the package in the last chapter.</p>
<p>These are run by simply invoking the <span class="romanAlt">go test</span> command with <span class="romanAlt">eg</span> as the argument. This will build the package along with any files with names ending in <span class="romanAlt">_test.go</span>, and then run any functions that start with <code>Test</code> and have the signature shown above.</p>
<p>The argument to testing functions is a pointer to a structure used for reporting failures. This test will unconditionally fail, so you can see what happens when a test fails.</p>
<p>The error message just before the failure tells you what went wrong; in this case it was our buggy test that always failed unconditionally.</p>
<p class="pre-1">1&#160;&#160;$ go <span class="EmpStrong">test</span> eg<br/>2&#160;&#160;--- FAIL: TestExample (0.00 seconds)<br/>3&#160;&#160;&#160;&#160;eg_test.go:11: This <span class="EmpStrong">test</span> is buggy<br/>4&#160;&#160;FAIL<br/>5&#160;&#160;FAIL&#160;&#160;eg&#160;&#160;0.012s</p>
<p class="example"><a id="page_258"/><a id="ch17ex11"/>Output from: gotest</p>
<p>If the previous test had failed, then we would have no useful error. This is bad style, because it makes finding the cause of the problem difficult.</p>
<p>This test contains another example of very bad testing style. If the type assertion had failed, then this test would have panicked. There is no <code>recover()</code> call, so this would abort without later tests being run. This is a problem if you want to be able to get helpful error reports from users.</p>
<p>Well written unit tests can be very helpful in preventing regressions, but they are not a panacea. Make certain that you are testing the correct thing. One project that I&#8217;ve worked on requires unit tests, and they generally test the exact behavior, rather than the high-level semantics, so a large change involves modifying a load of tests, completely defeating the point of the tests.</p>
</body>
</html>