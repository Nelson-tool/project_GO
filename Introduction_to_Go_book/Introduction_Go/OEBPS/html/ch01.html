<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>1. Introducing Go</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch01"><a id="page_1"/>1. Introducing Go</h2>
<p>When learning a new language, there are three things that you need to understand. The first and most important is the abstract model that the language presents. The next is the concrete syntax. Finally, you need to learn your way around the standard libraries and the common idioms of the language.</p>
<p>This chapter will look at the abstract model that Go presents to programmers. If you want to dive straight into real examples, skip to the next chapter, which covers the concrete syntax. The rest of the book will cover highlights from the Go standard library and the various idioms that you will find common in Go code.</p>
<h3 id="ch01lev1sec1">Go and C</h3>
<p>In the late &#8217;60s, a small team at the Bell Telephone Laboratories wrote a simple operating system called UNICS, a very lightweight system inspired <a id="page_2"/>by the MULTICS project, on the PDP-7 minicomputer that they had access to. When they wanted to port it to another system, they had to rewrite all of the code, which was written in PDP-7 assembly language.</p>
<p>To make the transition easier, they wanted to be able to share as much code as possible between different versions. They needed a language that was sufficiently low-level that a simple compiler (the only kind that existed in the &#8217;60s) could generate efficient machine code from it, yet which hid most of the irrelevant details of the target machine. BCPL was close, but it was too complex in some areas and lacked some required features in others.</p>
<p>Dennis Ritchie created the C programming language as a derivative of BCPL, and eventually most of the PDP-11 version of UNIX was rewritten in it. When UNIX was ported to the VAX, they just needed to retarget the compiler and write a small amount of very low-level assembly code. The majority of the system could be recompiled without modification.</p>
<p>Since its initial public release in 1978, C has become a very popular language. It is the de facto standard low-level language for programming these days, and it even finds use in a significant amount of application development.</p>
<p>The point of a low-level language is to provide an abstract machine model to the programmer that closely reflects the architecture of the <a id="page_3"/>concrete machines that it will target. There is no such thing as a universal low-level language: a language that closely represents the architecture of a PDP-11 will not accurately reflect something like a modern GPU or even an old B5000 mainframe. The attraction of C has been that, in providing an abstract model similar to a PDP-11, it is similar to most cheap consumer CPUs.</p>
<p>Over the last decade, this abstraction has become less like the real hardware. The C abstract model represents a single processor and a single block of memory. These days, even mobile phones have multicore processors, and a programming language designed for single-processor systems requires significant effort to use effectively. It is increasingly hard for a compiler to generate machine code from C sources that efficiently uses the resources of the target system.</p>
<p>In 2007, Robert Griesemer, Pike, and Ken Thompson began work on a new language. Thompson had both been instrumental in the creation of C and Pike had worked on it later at Bell Labs, being members of the original UNIX team that drove the development of C. The aim of Go, their new language, was to fill the same niche today that C fit into in the &#8217;80s. It is a low-level language for multiprocessor development. Experience with C taught them that a successful systems programming language ends up being used for application development, so Go incorporates a number of high-level <a id="page_4"/>features, allowing developers to use it for things like web services or desktop applications, as well as very low-level systems.</p>
<p>Both Pike and Thompson worked on Plan 9<sup><a id="ch01fn01" href="footnotes.html#ch01fn01a">1</a></sup>, a system designed to be a &#8220;better UNIX than UNIX.&#8221; Plan 9 eventually gave birth to the Inferno distributed operating system. For Inferno, Pike created the Limbo programming language. If you&#8217;ve used Limbo, you will find a lot of ideas very similar. The module system, channel-based communication, garbage collection, much of the type system, and even a lot of the syntax in Go are inherited directly from Limbo. The reference implementation of Go is based on the Plan 9 compiler toolchain.</p>
<p>If you come from C, then many things in Go will seem familiar, but some will seem strange. As a trivial example, variable declarations in Go usually look like they are written back to front to C programmers, although if you come from other members of the Algol family, such as Pascal, then these may not seem so strange. Most of these changes come from decades of experience working with C, and seeing ways in which it can be improved.</p>
<h3 id="ch01lev1sec2">Why Go?</h3>
<p>In recent years, scalability has become a lot more important than raw speed. Moore&#8217;s law tells us <a id="page_5"/>that the number of transistors on a CPU can be expected to double roughly every 18 months. For a long time, this roughly corresponded to a doubling in performance for a single thread of execution. Now, it generally means that you get twice as many cores.</p>
<p>It used to be that you just had to wait six months, and your C code would run twice as fast on a new machine. This is no longer true. Now, if you want your code to be faster on new machines, then it must be parallel.</p>
<p>C is inherently a serial language. Various libraries, such as POSIX threads and OpenMP, make it possible to write multithreaded code in C, but it&#8217;s very hard to write code that scales well. In creating DragonFly BSD, Matt Dillon observed that there was no point in creating an N:M threading model&#8212;where N userspace threads are multiplexed on top of M kernel threads&#8212;because C code that uses more than a handful of threads is very rare.</p>
<p>Go, in contrast, was designed with concurrency in mind. If you write idiomatic Go, then you will write code that, conceptually, does lots of things in parallel. The compiler and runtime environment can easily run this code on a single core by simply timeslicing between the various parts. They can also run it on a manycore machine by distributing the tasks across different threads.</p>
<p>This is a very important advantage. In the <a id="page_6"/>past, I had to write some code that would work on my single-core laptop and yet scale up to a 64-processor SGI machine. Doing this in C was very hard, but doing the same thing in Erlang was trivial. In Erlang, I wrote code that used over a thousand Erlang processes, and the runtime automatically distributed them across the available cores.</p>
<p>The disadvantage of the Erlang version was that Erlang performs significantly worse than C in a single thread. Until you have a large number of available cores, the single-threaded C version will be faster than the concurrent Erlang version.</p>
<p>Go combines the best of both worlds. In single-threaded performance, it is close to C, yet it encourages a programming style that scales well to large numbers of cores. It&#8217;s important to remember that the number of available cores is likely to follow a geometric growth pattern. Currently, two to eight cores is common<sup><a id="ch01fn02" href="footnotes.html#ch01fn02a">2</a></sup> and machines with more than about 16 cores are expensive. In a few years, you will see mobile phones with 64 cores and laptops with even more. Writing C code that scales to two, or even eight cores is quite difficult but not insanely hard. Writing C code that scales to 64 or 256 cores is very challenging. With a language designed for concurrency, it is much easier.</p>
<p>Concurrency is the most obvious advantage <a id="page_7"/>of Go, but it is not the only one. Go aims to provide a rich set of features without overcomplicating the language. Contrast this with C++, where even after having worked on a standard library implementation and a couple of compilers for the language, I still find myself having to refer to the spec periodically.</p>
<p>Go also includes a rich standard library, which makes developing complex web applications easy. It provides a number of mid-level abstractions, which provide high-level access to low-level features. We&#8217;ll look at one of those in detail in <a href="ch05.html#ch05">Chapter 5</a>, <em><a href="ch05.html#ch05">Arrays and Slices</a></em>.</p>
<h3 id="ch01lev1sec3">Goroutines and Channels</h3>
<p>The fundamental concurrency primitive in Go is the <em>goroutine</em>. This is a pun on coroutine, a method of flow control popularized by Simula. A goroutine is a like function call that completes asynchronously. Conceptually, it runs in parallel, but the language does not define how this actually works in terms of real parallelism.</p>
<p>A Go compiler may spawn a new operating system thread for every goroutine, or it may use a single thread and use timer signals to switch between them. The exact implementation mechanism for goroutines is not specified by the language and may change over time.</p>
<p>By themselves, goroutines are not very useful. C lets you create threads almost as easily as <a id="page_8"/>Go lets you create goroutines, yet that doesn&#8217;t make it easy to write concurrent code in C. Creating concurrent subprograms (threads, child processes, or goroutines) is the easy part of the problem. The difficult part is communicating between them.</p>
<p>C does not provide any primitives for communicating between threads, because C does not recognize threads; they are implemented in libraries. Threads all share an address space, so it is possible to write your own code for communicating between them, and anyone who has written concurrent C code has probably done this at least once.</p>
<p>Go, in contrast, is designed for concurrency. It uses a form of C. A. R. Hoare&#8217;s <em>Communicating Sequential Processes (CSP)</em> formalism to facilitate communication between goroutines. CSP defines communication channels that events can be sent down. Go programs can create channels and use them to communicate between threads.</p>
<p>A good rule of thumb for concurrent code is that the complexity of debugging it is proportional to the number of concurrent tasks multiplied by the number of possible ways in which they can interact. Because C threads use a shared-everything model, the number of possible ways in which they can interact is very large.</p>
<p>This is made worse by the fact that it is trivial for errors in code using pointers to mean that two C threads are sharing a data structure that <a id="page_9"/>they shouldn&#8217;t, for example via a buffer overrun or a dangling pointer. These problems do not manifest in Go because Go adds one feature to C and removes another. Go programs use garbage collection, making dangling pointers impossible, and disallows pointer arithmetic,<sup><a id="ch01fn03" href="footnotes.html#ch01fn03a">3</a></sup> making most other categories of pointer-related errors impossible. We&#8217;ll look at this later, in <em>Understanding the Memory Model</em>.</p>
<p>Creating a goroutine is intended to be much cheaper than creating a thread using a typical C threading library. The main reason for this is the use of <em>segmented stacks</em> in Go implementations.</p>
<p>The memory model used by early C implementations was very simple. Code was mapped (or copied) into the bottom of the address space. Heap (dynamic memory) space was put in just above the top of the program, and the stack grew down from the top of the address space. Low-level memory management worked using the <code>brk()</code> system call to add more pages at the top of the heap segment and the <code>sbrk()</code> call to add more pages at the bottom of the stack segment.</p>
<p>Threading complicated this. The traditional C stack was expected to be a contiguous block of memory. When you create a new thread, you need to allocate a chunk of memory big enough for the maximum stack size. Typically, that&#8217;s about 1MB of RAM. This means that creating a thread requires allocating 1MB of RAM, even <a id="page_10"/>if the thread is only ever going to use a few KB of stack space. This is required because compiled C code assumes that it can allocate more stack memory by moving the stack pointer. Operating systems usually mark the page below the bottom of the stack as no-access, so small stack overflows will cause a segmentation fault.</p>
<p>Go functions are more clever. They treat the stack as a linked list of memory allocations. If there is enough space in the current stack page for their use, then they work like C functions; otherwise they will request that the stack grows. A short-lived goroutine will not use more than the 4KB initial stack allocation, so you can create a lot of them without exhausting your address space, even on a 32-bit platform.</p>
<p>Goroutines are not intended to be implemented as kernel threads. The language does not make hard guarantees on their concurrency. Like Java threads or Erlang processes, a large number of goroutines can be multiplexed onto a small number of kernel threads. This means that context switches between goroutines is often cheaper than between POSIX threads.</p>
<h3 id="ch01lev1sec4">Selecting a Compiler</h3>
<p>At the time of writing, there are two stable Go compilers. The reference implementation is Gc, although it is commonly referred to as <em>6g</em>. This is based on the Plan 9 compiler toolchain.</p>
<p><a id="page_11"/>The Plan 9 toolchain programs are named with a number indicating the architecture that they target, followed by a letter indicating their function. The three architectures supported by Go are ARM (5), x86-64 (6), and i386 (8). If you are using ARM, you would use the <span class="romanAlt">5g</span> command instead of <span class="romanAlt">6g</span> to compile Go programs, and <span class="romanAlt">5l</span> instead of <span class="romanAlt">6l</span> to link them.</p>
<p>The alternative is a front end for the <em>GNU Compiler Collection (GCC)</em>, called gccgo. This turns Go code into more or less the same intermediate representation that GCC uses for Fortran, C, and C++, and then subjects it to the same set of optimizations, again producing native code.</p>
<p>Currently, Gc is probably the better choice, although gccgo is starting to produce better code. It is the reference implementation of Go, and so is the subject of the most active development. There are several important differences between them, however.</p>
<p>The most obvious is that gccgo uses operating system threads to implement goroutines, and will not use segmented stacks in all configurations. This means that creating a goroutine is as expensive as creating a thread in C. If you are writing code with a high order of parallelism, then this will make gccgo much slower than 6g. If your code only uses a few goroutines, and doesn&#8217;t create them very frequently, then the better optimization back end in GCC may make <a id="page_12"/>it faster.</p>
<p>It&#8217;s worth remembering that both compilers produce native executables. Go uses the same implementation model as Objective-C: native binaries and a small runtime library implementing the dynamic functionality. There is no virtual machine interpreting or JIT-compiling code. It would be possible to write a dynamic recompilation environment for Go, but the current implementations are static compilers. This means that distributing an application written in Go is as easy as distributing an application written in any other compiled language. You need to include any libraries that you use, but users don&#8217;t need a large runtime environment, as they do with .NET, Java, or Python code, for example.</p>
<p>Since Go is a relatively new language, there will almost certainly be new implementations appearing over time. For example, it is currently possible to use the gcc front end with the LLVM code generator via the DragonEgg plugin, and a native Go front end for LLVM is likely to appear at some point.</p>
<h3 id="ch01lev1sec5"><a id="page_13"/>Creating a Simple Go Program</h3>
<p class="pre">0&#160;&#160;$ 6g hello.go<br/>1&#160;&#160;$ 6l hello.6<br/>2&#160;&#160;$ ./6.out<br/>3&#160;&#160;Hello World!<br/>4&#160;&#160;$ go run hello.go<br/>5&#160;&#160;Hello World!</p>
<p>If you&#8217;re using the Gc compiler, then you need to invoke the version of it specific to your architecture. If you&#8217;re on an x86-64 system, then this will be <span class="romanAlt">6g</span>. This takes a list of Go source files and produces object code. The object code must then be linked to produce the final binary.</p>
<p>At first glance, this is very similar to C, where you also first run the compiler and then the linker. There are a number of differences, which mostly make Go easier to compile.</p>
<p>When you run <span class="romanAlt">6g</span>, it looks for <span class="EmpStrong">import</span> directives and inserts references to the relevant packages into the object code. This means that you usually don&#8217;t need to specify any libraries to the linker: it will read the required packages from the object code file that you give it and link all of those into the resulting executable.</p>
<p>The linking step is needed to combine all of the Go packages that you use, along with any C libraries that you call via the foreign function interface, into a single executable. The compiler performs partial linking to produce packages.</p>
<p><a id="page_14"/>The final linking step is only required when you want to import all of the separate bits of code and combine them with the system-specific preamble that all executables share.</p>
<p>The compiler and linker both generate default filenames from the target architecture. In the example at the start of this section, the <span class="romanAlt">6g</span> compiler generates a <span class="romanAlt">hello.6</span> object code file. If you used <span class="romanAlt">8g</span> instead, and generated 32-bit x86 code, then the resulting file would be <span class="romanAlt">hello.8</span> and the <span class="romanAlt">8l</span> linker would produce <span class="romanAlt">8.out</span> instead of <span class="romanAlt">6.out</span>. These are just the default output filenames. You can use <span class="romanAlt">-o</span> with both tools to specify another filename.</p>
<p>As of Go 1.0, all of the details of this are typically hidden from you. The <span class="romanAlt">go</span> command can compile and run programs for you with a single step. Simply type <span class="romanAlt">go run</span> followed by the name of the source file and it will do all of this for you. If you specify the <span class="romanAlt">-x</span> flag, then you can see exactly what this tool does as it runs.</p>
<h3 id="ch01lev1sec6">The Go Type System</h3>
<p>Go is a language with static typing and tight coupling between components. Go is also a language with dynamic typing and loose coupling between components. The language allows you to select which of these is more appropriate for each use case.</p>
<p>Go has a range of C-like primitive types and <a id="page_15"/>structures that are similar to C structures, with the addition of methods (which are allowed on all Go types, not just structures) but without any form of inheritance. If you call a method on an expression with a static type directly, then the methods on it are just syntactic sugar on function calls. They are statically looked up and called.</p>
<p>The other side of the Go type system is visible via interfaces. Unlike Java interfaces or Objective-C protocols, they support <em>duck typing</em><sup><a id="ch01fn04" href="footnotes.html#ch01fn04a">4</a></sup> and don&#8217;t have to be explicitly adopted. Any type that implements the methods that an interface lists implicitly implements that interface. If you&#8217;ve used languages in the Smalltalk family, including Python or Ruby, then you&#8217;re probably familiar with duck typing.</p>
<p>Interface types can be used as variable types. When you call any method on an interface-typed variable, it uses dynamic dispatch to find the correct method implementation.</p>
<p>Go also supports <em>introspection</em> on types. You can query any variable to find out whether it is an instance of a specified type, or whether it implements a specified interface. This makes it easy to write generic data structures in Go. You can either define an interface specifying the methods that you require, or use the <em>empty interface</em>, which can be used to represent any <a id="page_16"/>type (including primitive types) if you are just storing values and don&#8217;t need to call any methods.</p>
<p>One of the most useful features for a lazy programmer is the <em>type inference</em> that the Go compiler does. This allows you to avoid explicit type annotations on most variable declarations. If you combine initialization with declaration, then the compiler will infer the variable&#8217;s type from the type of the expression assigned to it.</p>
<h3 id="ch01lev1sec7">Understanding the Memory Model</h3>
<p>Go uses <em>garbage collection (GC)</em>. Generally, people have one of two reactions to this. If you come from a high-level language, like Java, C#, Ruby, Python, or Smalltalk, then your reaction is likely to be &#8220;So what? It&#8217;s a standard language feature these days.&#8221; People coming from C or C++, in contrast, tend to regard GC as a decadent luxury and a sign of incompetence among programmers in general. Oh, and they also want you to get off their lawn.</p>
<p>Garbage collection means that you don&#8217;t have to think about when to deallocate memory. In Go, you explicitly allocate values, but they are automatically reclaimed when they are no longer required. There is no equivalent of C&#8217;s <code>free()</code> or C++&#8217;s <code>delete</code>. As with other garbage collected languages, it is still possible to leak objects if <a id="page_17"/>you accidentally keep references to them after you stop using them.</p>
<p>When you&#8217;re writing single-threaded code, garbage collection is a luxury. It&#8217;s nice to have, but it&#8217;s not a vital feature. This changes when you start writing multithreaded code. If you are sharing pointers to an object between multiple threads, then working out exactly when you can destroy the object is incredibly hard. Even implementing something like reference counting is hard. Acquiring a reference in a thread requires an atomic increment operation, and you have to be very careful that objects aren&#8217;t prematurely deallocated by race conditions.</p>
<p>Like Java, and unlike C or C++, Go does not explicitly differentiate between stack and heap allocations. Memory is just memory. If you create an object with local scope, then current implementations will allocate it on the stack unless it has its address taken somewhere. Future implementations might always allocate it in a young GC generation and then move it to another generation if it has remaining references after a short amount of time. Alternatively, they may perform better escape analysis to allocate objects on the stack even if they have their address taken, as long as they are never referenced after the function in which they are allocated returns.</p>
<p>Go is designed to make garbage collection relatively easy to implement, although the <a id="page_18"/>existence of interior pointers makes it harder than a language like Java or Smalltalk. There are strict restrictions on where pointers can be stored, so the collector can, in theory, always tell, for example, the difference between an integer and a pointer value. In current implementations, Go uses fairly conservative garbage collection, although that is one of the areas that is likely to improve in future versions.</p>
<p>Because Go is designed for concurrency, the memory model defines explicitly what to expect when two goroutines touch the same memory: in short, there are no guarantees. Go does not enforce any constraints on the order that memory accesses occur with regard to each other. The compiler is free to reorder any memory accesses within a goroutine, as long as that reordering does not alter the semantics of the goroutine running in isolation. For example, consider the following bit of pseudocode:</p>
<p class="pre-n">a = b;<br/>use(b)<br/>use(a);<br/>b = 12;</p>
<p>The compiler is free to rearrange the statements so that the user-visible effect is not changed within the scope of this block. For example, this would be a valid reordering:</p>
<p class="pre-n">use(b)<br/>a = b;<br/>b = 12;<br/><a id="page_19"/>use(a);</p>
<p>Although the statements reading and writing the values of the two variables are no longer in the same order, it is not possible for the user to distinguish the difference. This means that you have to be very careful when using shared memory from two goroutines: if either variable in this example is shared then this kind of optimization would have confusing consequences. In general, it&#8217;s a good idea to only share read-only strutures. We&#8217;ll look at some alternatives for mutable data in <a href="ch10.html#ch10">Chapter 10</a>, <em><a href="ch10.html#ch10">Concurrency Design Patterns</a></em>.</p>
</body>
</html>