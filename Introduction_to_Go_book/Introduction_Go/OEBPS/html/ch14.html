<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>14. Web Applications</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch14"><a id="page_207"/>14. Web Applications</h2>
<p>It should come as no surprise that a language developed by a web giant should have a lot of standard library support for the Internet. The <em>textproto package</em>, for example, contains generic functionality for implementing protocols that work on a challenge-response basis, exchanging lines of text. These include SMTP, NNTP, HTTP, and so on.</p>
<p>Go is now usable in the Google App Engine, so it&#8217;s not surprising that developing web applications is one of the main reasons to choose Go. In this chapter, we&#8217;ll look at several of the features that allow you to integrate with the web.</p>
<h3 id="ch14lev1sec1"><a id="page_208"/>Integrating with a Web Server</h3>
<p class="pre">&#160;5&#160;&#160;<span class="EmpStrong">type</span> webCounter <span class="EmpStrong">struct</span> {<br/>&#160;6&#160;&#160;&#160;&#160;count <span class="EmpStrong">chan</span> int<br/>&#160;7&#160;&#160;}<br/>&#160;8&#160;&#160;<span class="EmpStrong">func</span> NewCounter() *webCounter {<br/>&#160;9&#160;&#160;&#160;&#160;counter := new(webCounter)<br/>10&#160;&#160;&#160;&#160;counter.count = make(<span class="EmpStrong">chan</span> int, 1)<br/>11&#160;&#160;&#160;&#160;<span class="EmpStrong">go func</span>() {<br/>12&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i:=1 ;; i++ { counter.count &lt;- i }<br/>13&#160;&#160;&#160;&#160;}()<br/>14&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> counter<br/>15&#160;&#160;}<br/>16&#160;&#160;<span class="EmpStrong">func</span> (w *webCounter) ServeHTTP(r http.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ResponseWriter, rq *http.Request) {<br/>17&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> rq.URL.Path != "/" {<br/>18&#160;&#160;&#160;&#160;&#160;&#160;r.WriteHeader(http.StatusNotFound)<br/>19&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span><br/>20&#160;&#160;&#160;&#160;}<br/>21&#160;&#160;&#160;&#160;fmt.Fprintf(r, "You are visitor %d", &lt;-w.count)<br/>22&#160;&#160;}<br/>23&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>24&#160;&#160;&#160;&#160;err := http.ListenAndServe(":8000", NewCounter<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;())<br/>25&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> err != nil {<br/>26&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Server failed: ", err.Error())<br/>27&#160;&#160;&#160;&#160;}<br/>28&#160;&#160;}</p>
<p class="example"><a id="ch14ex01"/>From: webServer.go</p>
<p>The simplest way of serving web clients from Go is to use the integrated web server in the <em>net/http package</em>. This provides a stub web server that delegates the handling of requests to your code.</p>
<p>The example at the start of this section is about <a id="page_209"/>the simplest dynamic web page possible. It returns a plain text string with a message and an integer that increments every call. Note that the <code>ResponseWriter</code> implements the <code>io.Writer</code> interface, so it can be used with the functions from the <em>fmt package</em> and other functions that produce output of this kind.</p>
<p>When you run this example, you just need to point your browser at <code>http://localhost:8000</code> and you will see the output. Every time the server receives a connection request, it will serve a simple (text only) page telling the user his hit number.</p>
<p>If you are already running a web server, but want to provide some dynamic components from Go, then you should take a look at the <em>fastcgi package</em>. This uses the same interface that the <code>webCounter</code> structure in this example implements, but associates it with a path in an existing server, rather than a port on a new server.</p>
<p>This example may appear more complicated than required, at first glance. Why are we using a channel to provide a stream of incrementing integers? Couldn&#8217;t we just increment a field? We could, if we used an atomic increment from the <em>atomic package</em>, but this is a somewhat cleaner approach.</p>
<p>Every time a request is received, the <code>ServeHTTP()</code> method will be called <em>in a new goroutine</em>. A simple increment statement is not <a id="page_210"/>atomic, so if two requests were handled at the same time then one of the increments could get lost. For an example this simple, that doesn&#8217;t really matter, but in anything more complex it might.</p>
<p>Spawning a new goroutine to provide the sequence is an example of the share memory by communicating pattern that we saw in <a href="ch10.html#ch10">Chapter 10</a>, <em><a href="ch10.html#ch10">Concurrency Design Patterns</a></em>. Using this, we don&#8217;t have to worry about concurrency. Each response will get a new value, irrespective of whether they are sequential or concurrent.</p>
<p>Note that counter values are not lost here, unlike some earlier examples, because all of the goroutines are sharing the same channel. The channel is not being deallocated with some counter values still stored in it, until the server exits.</p>
<h3 id="ch14lev1sec2"><a id="page_211"/>Connecting to Web Servers</h3>
<p class="pre">10&#160;&#160;client := &#38;http.Client{}<br/>11&#160;&#160;client.CheckRedirect =<br/>12&#160;&#160;&#160;&#160;<span class="EmpStrong">func</span>(req *http.Request, via []*http.Request)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;error {<br/>13&#160;&#160;&#160;&#160;fmt.Fprintf(os.Stderr, "Redirect: %v\n", req.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;URL);<br/>14&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> nil<br/>15&#160;&#160;}<br/>16&#160;&#160;<span class="EmpStrong">var</span> url string<br/>17&#160;&#160;<span class="EmpStrong">if</span> len(os.Args) &lt; 2 {<br/>18&#160;&#160;&#160;&#160;url = "http://golang.org"<br/>19&#160;&#160;} <span class="EmpStrong">else</span> {<br/>20&#160;&#160;&#160;&#160;url = os.Args[1]<br/>21&#160;&#160;}<br/>22&#160;&#160;page, err := client.Get(url)<br/>23&#160;&#160;<span class="EmpStrong">if</span> err != nil {<br/>24&#160;&#160;&#160;&#160;fmt.Fprintf(os.Stderr, "Error: %s\n", err.Error<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;())<br/>25&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span><br/>26&#160;&#160;}<br/>27&#160;&#160;io.Copy(os.Stdout, page.Body)<br/>28&#160;&#160;page.Body.Close()</p>
<p class="example"><a id="ch14ex02"/>From: wget.go</p>
<p>A typical web application or web service acts as both a client and a server, collecting data from other web services and providing it to clients, who may be end users or other web services. The client part in Go is even simpler than the server side.</p>
<p>The <code>http.Client</code> structure provides a very simple way of communicating with web servers. You can either construct a request yourself&#8212;using the same structure that was delivered to <a id="page_212"/>the <code>ServeHTTP()</code> function in the last section&#8212;or just specify a URL.</p>
<p>The example at the top of this section is a very simple tool for fetching a specified web page, or the Go home page if none is explicitly given. It then writes the contents of the page to the standard output. If the final page was found after following some redirections, it reports each redirection on the standard error. For every redirection, the client calls its <code>CheckRedirect</code> function, if one is set. This allows you to set custom policies for handling redirections, although this simple example just logs a message.</p>
<p>Note in particular how the page is written to the standard output. The <code>Get()</code> method will return immediately when the server starts delivering data; it won&#8217;t wait until the entire resource has been downloaded. This is particularly useful if the URL points to something like a CD or DVD disk image or a large movie. The response contains a field that implements the <code>io.ReadCloser</code> interface. You can read the data from this as it arrives. In this example, we&#8217;re just using the <code>io.Copy()</code> function to write it straight to the standard output.</p>
<h3 id="ch14lev1sec3"><a id="page_213"/>Parsing HTML</h3>
<p class="pre">14&#160;&#160;tokenizer := html.NewTokenizer(page.Body)<br/>15&#160;&#160;foundStart := false<br/>16&#160;&#160;<span class="EmpStrong">for</span> {<br/>17&#160;&#160;&#160;&#160;ty := tokenizer.Next()<br/>18&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> ty == html.ErrorToken { <span class="EmpStrong">break</span> }<br/>19&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> ty != html.StartTagToken { <span class="EmpStrong">continue</span> }<br/>20&#160;&#160;&#160;&#160;t := tokenizer.Token()<br/>21&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> t.Data != "a" { <span class="EmpStrong">continue</span> }<br/>22&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> _, attr := <span class="EmpStrong">range</span> t.Attr {<br/>23&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> "href" == attr.Key {<br/>24&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> !foundStart ||<br/>25&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;((len(attr.Val) &gt; 4) &#38;&#38;<br/>26&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;"http" == attr.Val[0:4] ){<br/>27&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> ".." == attr.Val {<br/>28&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;foundStart = true<br/>29&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>30&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">break</span><br/>31&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>32&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%s\n", attr.Val)<br/>33&#160;&#160;&#160;&#160;&#160;&#160;}<br/>34&#160;&#160;&#160;&#160;}<br/>35&#160;&#160;}</p>
<p class="example"><a id="ch14ex03"/>From: pkgList.go</p>
<p>Fetching a remote HTTP resource is usually only part of the problem. Interpreting the result is the other part. Parsing HTML is a common task for web applications, either interpreting HTML delivered from another server or validating HTML uploaded by clients.</p>
<p>The example at the start of this section uses the <em>exp/html package</em>, which contains an HTML5 parser, to read the package list from <a href="http://golang.org/pkg/">http://golang.org/pkg/</a> and try to find the package <a id="page_214"/>names. This is a fairly simple screen scraper. It assumes that every relative link after the link to the enclosing directory is the name of a package, and writes it out to the standard output. Because it relies on the structure of the page, this example may break at any point in the future if the structure of the package list page changes.</p>
<div class="note"><hr/>
<p class="title"><a id="ch14note01"/>Note</p>
<p class="notepara">This example uses a package from the exp hierarchy, which is not part of the standard Go 1.0 install. To run it, you will need to download the exp packages from the Go repository. If you are using the trunk version of Go, you probably have them installed already. Packages in the exp hierarchy are experimental and are intended to become standard parts of the Go library when they are finished. If you are using a Go release after 1.0 then you may find that the package is available without the exp/ prefix.</p>
<hr/></div>
<p>Unfortunately, the html package expects well-formed HTML as input, so it is not useful for validating user input. It is, however, useful for interpreting HTML from other sources. Most HTML5 provides better semantic markup than the Go package list and you can use this package to extract and transform parts of it easily.</p>
<p>The basic interface to the HTML5 tokenizer is the <code>Tokenizer</code> structure, which takes a reader and then provides a stream of tokens. Rather <a id="page_215"/>than constructing a new <code>Token</code> for every token in the input stream, we call the <code>Next()</code> method first. This returns the type of the next token, allowing us to skip character data and close tags. If we&#8217;ve found an open tag, then we ask it to construct a <code>Token</code> structure representing that tag.</p>
<div class="note"><hr/>
<p class="title"><a id="ch14note02"/>Note</p>
<p class="notepara">The html package is intended for parsing well-formed HTML 5. If you are parsing XML, then the <em>xml package</em> provides a very similar interface.</p>
<hr/></div>
<p>You can use the same approach when importing HTML, for example from ad networks or other third-party sites, to only allow a white-listed set of tags, simply discarding any that are not in your white list.</p>
<h3 id="ch14lev1sec4"><a id="page_216"/>Generating HTML</h3>
<p class="pre">&#160;6&#160;&#160;<span class="EmpStrong">type</span> webCounter <span class="EmpStrong">struct</span> {<br/>&#160;7&#160;&#160;&#160;&#160;count <span class="EmpStrong">chan</span> int<br/>&#160;8&#160;&#160;&#160;&#160;template *template.Template<br/>&#160;9&#160;&#160;}<br/>10&#160;&#160;<span class="EmpStrong">func</span> NewCounter() *webCounter {<br/>11&#160;&#160;&#160;&#160;counter := new(webCounter)<br/>12&#160;&#160;&#160;&#160;counter.count = make(<span class="EmpStrong">chan</span> int, 1)<br/>13&#160;&#160;&#160;&#160;<span class="EmpStrong">go func</span>() {<br/>14&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i:=1 ;; i++ { counter.count &lt;- i }<br/>15&#160;&#160;&#160;&#160;}()<br/>16&#160;&#160;&#160;&#160;counter.template, _ = template.ParseFiles("<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;counter.html")<br/>17&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> counter<br/>18&#160;&#160;}<br/>19&#160;&#160;<span class="EmpStrong">func</span> (w *webCounter) ServeHTTP(r http.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ResponseWriter, rq *http.Request) {<br/>20&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> rq.URL.Path != "/" {<br/>21&#160;&#160;&#160;&#160;&#160;&#160;r.WriteHeader(http.StatusNotFound)<br/>22&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span><br/>23&#160;&#160;&#160;&#160;}<br/>24&#160;&#160;&#160;&#160;w.template.Execute(r, <span class="EmpStrong">struct</span>{Counter int}{&lt;-w.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count})<br/>25&#160;&#160;}</p>
<p class="example"><a id="ch14ex04"/>From: htmlServer.go</p>
<p>We&#8217;ve looked at how to serve data over HTTP, but the name Hypertext Transfer Protocol implies that we probably want to be sending data in the Hypertext Markup Language, rather than plain text.</p>
<p>The <em>text/template package</em> provides a very flexible way of generating HTML, and other structured formats. It allows you to insert placeholders into documents and then replace <a id="page_217"/>them with dynamic data. The example at the start of this section uses the <span class="romanAlt">counter.html</span> file as the template. This is a simple HTML file that contains a Counter placeholder that we want to replace with the actual counter value.</p>
<p class="pre-1">&#160;1&#160;&#160;&lt;!doctype html&gt;<br/>&#160;2&#160;&#160;&lt;html&gt;<br/>&#160;3&#160;&#160;&#160;&#160;&lt;head&gt;<br/>&#160;4&#160;&#160;&#160;&#160;&#160;&#160;&lt;title&gt;Go Web Counter&lt;/title&gt;<br/>&#160;5&#160;&#160;&#160;&#160;&lt;/head&gt;<br/>&#160;6&#160;&#160;&#160;&#160;&lt;body&gt;<br/>&#160;7&#160;&#160;&#160;&#160;&#160;&#160;&lt;h1&gt;A Simple Example&lt;/h1&gt;<br/>&#160;8&#160;&#160;&#160;&#160;&#160;&#160;&lt;p&gt;You are visitor: {{.Counter}}&lt;/p&gt;<br/>&#160;9&#160;&#160;&#160;&#160;&lt;/body&gt;<br/>10&#160;&#160;&lt;/html&gt;</p>
<p class="example"><a id="ch14ex05"/>From: counter.html</p>
<p>The template package uses some of the techniques involving the <em>reflect package</em> that we will look at in <a href="ch15.html#ch15">Chapter 15</a>, <em><a href="ch15.html#ch15">Interacting with the Go Runtime</a></em>. To see how it works, we&#8217;ll start at the end, with the <code>Execute()</code> call in the <code>ServeHTTP()</code> method. This applies the template, writing the output to the writer given in the first argument. The second argument is a structure with one field for every value referenced in the template. Here, we use an anonymous structure with one field, <code>Counter</code>, which is the current counter value. Executing the template replaces the counter placeholder with this value.</p>
<p>The <code>Template</code> structure was constructed earlier. This example uses the <code>ParseFiles()</code> function <a id="page_218"/>to create and initialize a template using a file on the disk. It will then construct an internal map of where everything needs to be inserted, allowing it to be quickly executed.</p>
<p>The template package provides a very powerful language for inserting data into the template. In this example, we&#8217;ve only looked at the simplest case&#8212;a single field being inserted once&#8212;but it&#8217;s worth looking at the rest of the language if you find that this isn&#8217;t enough.</p>
<p>While powerful, the template language is not as flexible as something like PHP: it is not a complete programming language for generating HTML. This is intentional. This package serves as an abstraction layer between programmers and user interface designers. The interface designers just need to tell the back-end programmers what kind of data they need. They can then generate templates for displaying it, without encoding any of the application logic in the presentation layer.</p>
<p>You may prefer to use the <em>html/template package</em>, which is designed to be used with unsafe input. It assumes that the template is sanitized but that the arguments to it are not. In this example, we are generating the arguments to <code>Execute()</code>, so we don&#8217;t need to worry. If we were taking user input then having something else sanitizing it automatically would be handy.</p>
</body>
</html>