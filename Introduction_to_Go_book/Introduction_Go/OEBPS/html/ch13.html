<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>13. Network Access</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch13"><a id="page_195"/>13. Network Access</h2>
<p>When C was created, computers were rare and expensive. It was still fairly common for a company to have a single computer. Now, a computer that isn&#8217;t connected to a network is considered an oddity.</p>
<p>Being able to interact with the network is important for most programs. Go has a variety of packages in the standard library for network access, which is hardly surprising when you consider that Google is the language&#8217;s main backer.</p>
<h3 id="ch13lev1sec1"><a id="page_196"/>Connecting to Servers</h3>
<p class="pre">&#160;6&#160;&#160;<span class="EmpStrong">func</span> tryConnect(network, host string, port int)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;net.Conn {<br/>&#160;7&#160;&#160;&#160;&#160;p := strconv.Itoa(port)<br/>&#160;8&#160;&#160;&#160;&#160;addr := net.JoinHostPort(host, p)<br/>&#160;9&#160;&#160;&#160;&#160;c, e := net.Dial(network, addr)<br/>10&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> e == nil { <span class="EmpStrong">return</span> c }<br/>11&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> nil<br/>12&#160;&#160;}</p>
<p class="example"><a id="ch13ex01"/>From: connect.go</p>
<p>If you are used to high-level languages, then you will find Go&#8217;s basic network support quite primitive. Go incorporates convenient high-level wrappers for various protocols, but the socket-style APIs are somewhat baroque.</p>
<p>The example at the start of this section shows how to connect, given a host, a network, and a port. The host can be any network address. The network indicates the lower-layer protocol. For example, <code>"tcp"</code> indicates a TCP connection, running on either IPv4 or IPv6, while <code>"udp6"</code> indicates a UDP connection running on top of IPv6.</p>
<p>The <code>Dial()</code> function from the <code>net</code> package is responsible for creating the connection. This either returns an error or a valid connection. This takes the address as a single string, containing the host&#8217;s address and port number, so you must first combine these two values into a single string using the <code>JoinHostPort()</code> function.</p>
<p>Before you can use this function, you must look <a id="page_197"/>up a valid host address and the port number for the service that you are using. This is something that would be done automatically for you with a high-level API, but must be done explicitly in Go.</p>
<p class="pre-1">14&#160;&#160;<span class="EmpStrong">func</span> connect(network, service, host string) net.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Conn {<br/>15&#160;&#160;&#160;&#160;_, addrs, _ := net.LookupSRV(service, network,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;host)<br/>16&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> _, srv := <span class="EmpStrong">range</span> addrs {<br/>17&#160;&#160;&#160;&#160;&#160;&#160;c := tryConnect(network, srv.Target, int(srv.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Port))<br/>18&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> c != nil {<br/>19&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> c<br/>20&#160;&#160;&#160;&#160;&#160;&#160;}<br/>21&#160;&#160;&#160;&#160;}<br/>22&#160;&#160;&#160;&#160;port, _ := net.LookupPort(network, service)<br/>23&#160;&#160;&#160;&#160;ips, _ := net.LookupHost(host)<br/>24&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> _, ip := <span class="EmpStrong">range</span> ips {<br/>25&#160;&#160;&#160;&#160;&#160;&#160;c := tryConnect(network, ip, port)<br/>26&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> c != nil {<br/>27&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> c<br/>28&#160;&#160;&#160;&#160;&#160;&#160;}<br/>29&#160;&#160;&#160;&#160;}<br/>30&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> nil<br/>31&#160;&#160;}</p>
<p class="example"><a id="ch13ex02"/>From: connect.go</p>
<p>Unfortunately, Go does not provide a single interface encapsulating the various low-level lookup methods. There are generally two ways in which you can get a valid port number. One is via a static lookup for the IANA-assigned standard port, typically listed in the operating <a id="page_198"/>system&#8217;s <span class="romanAlt">/etc/services</span> file. The other is via an SRV record, specifying a nonstandard port for this service.</p>
<p>Go provides a mechanism for performing both kinds of lookup. The <code>LookupSRV()</code> function returns a list of SRV entries. In the <span class="romanAlt">connect.go</span> example, we just check these in the order that they are returned, ignoring their weight and priority values.</p>
<p>If there is no SRV record for the specified server, then you must fall back to static lookup, using <code>LookupPort()</code>. You can then use <code>LookupHost()</code> to find a set of network addresses that correspond to the host name, independent of the service. As with the set returned by <code>LookupSRV</code>, this example tries each one in turn until it finds one that works.</p>
<p class="pre-1">33&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>34&#160;&#160;&#160;&#160;c := connect("tcp", "http", "informit.com")<br/>35&#160;&#160;&#160;&#160;c.Write([]byte("GET / HTTP/1.1\r\nHost:<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;informit.com\r\n\r\n"))<br/>36&#160;&#160;&#160;&#160;buffer := make([]byte, 1024)<br/>37&#160;&#160;&#160;&#160;c.Read(buffer)<br/>38&#160;&#160;&#160;&#160;fmt.Printf("%s", buffer)<br/>39&#160;&#160;}</p>
<p class="example"><a id="ch13ex03"/>From: connect.go</p>
<p>The returned connection has a few methods that you can use for network communication. In this example, we&#8217;ve used the generic connection interface, which just provides methods for <a id="page_199"/>reading and writing slices of bytes. Packet-based connections, such as UDP, will return something implementing the <code>PacketConn</code> interface, supporting operations that allow writing packets to specific addresses and reading packets along with their associated address.</p>
<h3 id="ch13lev1sec2">Distributing Go</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "old/netchan"<br/>&#160;3&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;4<br/>&#160;5&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;6&#160;&#160;&#160;&#160;counter := 0<br/>&#160;7&#160;&#160;&#160;&#160;ch := make(<span class="EmpStrong">chan</span> int, 1)<br/>&#160;8&#160;&#160;&#160;&#160;server := netchan.NewExporter()<br/>&#160;9&#160;&#160;&#160;&#160;server.Export("Counter", ch, netchan.Send)<br/>10&#160;&#160;&#160;&#160;server.Export("foo", make(<span class="EmpStrong">chan</span> bool, 12),<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;netchan.Send)<br/>11&#160;&#160;&#160;&#160;err := server.ListenAndServe("tcp", "localhost<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;:1234")<br/>12&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> err != nil {<br/>13&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Error: %s\n", err.Error())<br/>14&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span><br/>15&#160;&#160;&#160;&#160;}<br/>16&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> {<br/>17&#160;&#160;&#160;&#160;&#160;&#160;counter++<br/>18&#160;&#160;&#160;&#160;&#160;&#160;ch &lt;- counter<br/>19&#160;&#160;&#160;&#160;}<br/>20&#160;&#160;}</p>
<p class="example"><a id="ch13ex04"/>From: chanserver.go</p>
<p>One of the big advantages of using channels to communicate is that it makes the distinction <a id="page_200"/>between threads and processes more blurred. If a goroutine communicates with the rest of the program entirely via channels that copy values, rather than passing pointers, then it does not need to be sharing memory with the rest of the program.</p>
<p>If a goroutine does not need to be sharing memory with the rest of the program, then you can trivially run it in another process. More importantly, you can run this process on a completely different computer. All of this is possible with only small modifications to the code.</p>
<p>The <span class="romanAlt">chanserver.go</span> file shows a simple example, a counter that returns a new value every time it is queried. The setup uses the <em>netchan package</em> to export a channel via a TCP connection, but the remainder of the code is unchanged. It would be exactly the same if the channel communicated with a local goroutine.</p>
<div class="note"><hr/>
<p class="title"><a id="ch13note01"/>Note</p>
<p class="notepara">The netchan package is in old/ and will not be supported in the Go 1.0 release. A new version is due to be added sometime after Go 1.0. This example will probably not work in an unmodified form with the new netchan package, but the core idea of simply rerouting channel messages over the network should remain valid.</p>
<hr/></div>
<p>Exporting the channel for remote connections is very simple. The <code>Exporter</code> and <code>Importer</code> types <a id="page_201"/>from the netchan package handle all of the hard work. They wrap a network socket and a local channel, transferring messages between them.</p>
<p>Preparing the exporter requires configuring the two sides: the local channel and the network interface. The <code>Export()</code> method provides the local part. It associates a channel with a name, and specifies the direction in which messages will be sent. Here, we are declaring that the channel should be published as Counter and that this process will be using the channel for sending data. You can call this method several times, if you want to export multiple channels over the same connection.</p>
<p>The <code>ListenAndServe()</code> method is the other part. It listens for incoming connections on the specified network address and connects remote channels to the ones that it&#8217;s advertised.</p>
<p>The client, in the <span class="romanAlt">chanclient.go</span> example, is similar. The <code>Importer</code> works in the same way, but in reverse. First it connects to a remote server, then it connects local channels to remote channels, identified by name. The <code>Import()</code> function in this example constructs the new <code>Importer</code>, connected to the server. When you run this program, the results might surprise you.</p>
<p>It appears that the counter is being increased by two each time. What&#8217;s really happening is that every other message is being lost. This is because the <code>Importer</code> buffers received messages. The server sends one value which is read by <a id="page_202"/>the client, and another which is buffered by the client. The client then exits, and the contents of its buffer are lost.</p>
<p class="pre-1">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "old/netchan"<br/>&#160;3&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;4<br/>&#160;5&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;6&#160;&#160;&#160;&#160;conn, err := netchan.Import("tcp", "localhost<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;:1234")<br/>&#160;7&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> err != nil {<br/>&#160;8&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Error: %s\n", err.Error())<br/>&#160;9&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span><br/>10&#160;&#160;&#160;&#160;}<br/>11&#160;&#160;&#160;&#160;ch := make(<span class="EmpStrong">chan</span> int)<br/>12&#160;&#160;&#160;&#160;err = conn.Import("Counter", ch, netchan.Recv,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1)<br/>13&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> err != nil {<br/>14&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Error: %s\n", err.Error())<br/>15&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span><br/>16&#160;&#160;&#160;&#160;}<br/>17&#160;&#160;&#160;&#160;fmt.Printf("Counter: %d\n", &lt;-ch)<br/>18&#160;&#160;}</p>
<p class="example"><a id="ch13ex05"/>From: chanclient.go</p>
<p class="pre-1">1&#160;&#160;$ ./6.out<br/>2&#160;&#160;Counter: 1<br/>3&#160;&#160;$ ./6.out<br/>4&#160;&#160;Counter: 3<br/>5&#160;&#160;$ ./6.out<br/>6&#160;&#160;Counter: 5</p>
<p class="example"><a id="ch13ex06"/>Output from: chanclient.go</p>
<p><a id="page_203"/>As Senator Stevens would tell you, Go programs are a series of tubes. The capacity of each tube is the size of its buffer. When you place a value into a channel, it is stored in this buffer. If the channel becomes unreferenced, then the garbage collector will free it, and will also free all values stored in the buffer. You can think of a channel like a tube that you push balls into. When it is full, you must remove a ball from the other end before you can put a new one in. If you throw the tube away, then you also throw away all of the balls still inside it.</p>
<p>Try extending this example so that it doesn&#8217;t lose messages. The simplest way of doing this is to export two channels, one in each direction, and only send a counter value in response to an explicit request. Most of the time, you&#8217;ll want bidirectional communication, so this isn&#8217;t too much extra effort.</p>
<h3 id="ch13lev1sec3"><a id="page_204"/>Serving Objects</h3>
<p class="pre">&#160;5&#160;&#160;<span class="EmpStrong">type</span> Counter <span class="EmpStrong">struct</span> {<br/>&#160;6&#160;&#160;&#160;&#160;count int<br/>&#160;7&#160;&#160;}<br/>&#160;8&#160;&#160;<span class="EmpStrong">type</span> Arg <span class="EmpStrong">struct</span> { Increment int }<br/>&#160;9&#160;&#160;<span class="EmpStrong">type</span> Result <span class="EmpStrong">struct</span> { Value int }<br/>10&#160;&#160;<span class="EmpStrong">func</span> (c *Counter) Value(in *Arg, out *Result)<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;error {<br/>11&#160;&#160;&#160;&#160;c.count += in.Increment<br/>12&#160;&#160;&#160;&#160;out.Value = c.count<br/>13&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> nil<br/>14&#160;&#160;}<br/>15<br/>16&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>17&#160;&#160;&#160;&#160;server := rpc.NewServer()<br/>18&#160;&#160;&#160;&#160;server.RegisterName("GoCounter", new(Counter))<br/>19&#160;&#160;&#160;&#160;l, _ := net.Listen("tcp", ":1234")<br/>20&#160;&#160;&#160;&#160;server.Accept(l)<br/>21&#160;&#160;}</p>
<p class="example"><a id="ch13ex07"/>From: server.go</p>
<p>The <em>net/rpc package</em> provides a generic mechanism for implementing <em>Remote Procedure Call (RPC)</em> functionality. This is split into two parts: one that is responsible for the programmer interface and another that is responsible for the wire protocol.</p>
<p>The package allows you to perform RPC either via a direct socket connection or over HTTP. The <em>jsonrpc package</em> provides an implementation of the wire protocol component for JSON-RPC. This is primarily useful if you need to export objects that non-Go code can call. JSON-RPC is a language-agnostic RPC mechanism and is <a id="page_205"/>fairly widely supported.</p>
<p>The example at the start of this section shows a very simple server. This exports a single method, as <code>GoCounter.Value()</code>, via the underlying RPC mechanism. By default, this uses the <em>gob</em> encoding, which is a Go-specific serialization for objects.</p>
<p>The <code>Value()</code> method on the <code>Counter</code> is automatically exported, because it takes two pointer arguments and returns an error code. The two arguments are used for the input and output parameters for the RPC, respectively. When a request is received, this will be called with the received arguments in the first arguments. It should then fill in values in the structure passed via the second argument and return <code>nil</code>, or an error condition if it failed.</p>
<p>The <code>Accept()</code> method called here will handle each connection in a new goroutine: If you connect to this example fast enough then you will see a race condition. It is a blocking call, so normally it would be called in a new goroutine, but in this example the server does nothing except serve the object so that is not necessary.</p>
<h3 id="ch13lev1sec4"><a id="page_206"/>Calling Remote Procedures</h3>
<p class="pre">&#160;5&#160;&#160;<span class="EmpStrong">type</span> Arg <span class="EmpStrong">struct</span> { Increment int }<br/>&#160;6&#160;&#160;<span class="EmpStrong">type</span> Result <span class="EmpStrong">struct</span> { Value int }<br/>&#160;7<br/>&#160;8&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;9&#160;&#160;&#160;&#160;client, _ := rpc.Dial("tcp", ":1234")<br/>10&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> r Result<br/>11&#160;&#160;&#160;&#160;client.Call("GoCounter.Value", &#38;Arg{1}, &#38;r)<br/>12&#160;&#160;&#160;&#160;fmt.Printf("%d\n", r.Value)<br/>13&#160;&#160;}</p>
<p class="example"><a id="ch13ex08"/>From: client.go</p>
<p>An RPC server is about as useful as the first telephone. A second telephone, or in this case an RPC client, is required to make it useful. The client component uses a very similar interface. The input and output arguments must be marshaled in the same way, into a structure with one field per argument, passed by pointer.</p>
<p>The example at the start of this section contains all of the code required to connect to the server from the last example and call its exported method. The <code>rpc.Dial()</code> function creates a new RPC client, connected to the specified network address. This is the same address that we passed to the <code>Listen()</code> function in the server.</p>
<p>The <code>Call()</code> method performs the remote call. This marshals the argument into the correct format for transmission, calls the remote procedure with the name given in the first argument, and then extracts the results into the structure in the second argument.</p>
</body>
</html>