<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>4. Common Go Patterns</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch04"><a id="page_61"/>4. Common Go Patterns</h2>
<p>The first step to fluent use of any programming language is understanding the design patterns and idioms that are commonly used. Learning the syntax is only the first step to learning how to think in the language, akin to learning vocabulary and basic grammar in a natural language. People speaking a second language often make very amusing mistakes by literally translating idioms from their first language.</p>
<p>Programming languages are no different. If you&#8217;ve read C++ code written by Java programmers, or vice versa, then you&#8217;ve probably encountered this. Just translating an approach that you would use in one language into another will work (as long as both languages are equally expressive), but it will usually give horrible code.</p>
<p>Design patterns in a programming language <a id="page_62"/>are like the idioms of a natural language. Some work in a lot of languages; others don&#8217;t. Quite often, you will find that design patterns in one language work around a missing feature. For example, <em>resource acquisition is initialization (RAII)</em> is a common C++ idiom, yet it makes no sense in a garbage-collected language because object lifetimes are not related to their scopes. Better techniques (such as Go&#8217;s <span class="EmpStrong">defer</span> statement) exist to solve the same problem. Go, like every other language, has a set of common patterns that are not necessarily applicable elsewhere.</p>
<h3 id="ch04lev1sec1">Zero Initialization</h3>
<p class="pre">&#160;5&#160;&#160;<span class="EmpStrong">type</span> Logger <span class="EmpStrong">struct</span> {<br/>&#160;6&#160;&#160;&#160;&#160;out *os.File<br/>&#160;7&#160;&#160;}<br/>&#160;8<br/>&#160;9&#160;&#160;<span class="EmpStrong">func</span> (l Logger) Log(s string) {<br/>10&#160;&#160;&#160;&#160;out := l.out<br/>11&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> (out == nil) {<br/>12&#160;&#160;&#160;&#160;&#160;&#160;out = os.Stderr<br/>13&#160;&#160;&#160;&#160;}<br/>14&#160;&#160;&#160;&#160;fmt.Fprintf(out, "%s [%d]: %s\n", os.Args[0],<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;os.Getpid(), s)<br/>15&#160;&#160;}<br/>16<br/>17&#160;&#160;<span class="EmpStrong">func</span> (l *Logger) SetOutput(out *os.File) {<br/>18&#160;&#160;&#160;&#160;l.out = out<br/>19&#160;&#160;}</p>
<p class="example"><a id="ch04ex01"/>From: log.go</p>
<p>One of the important concepts in Go is the <em>zero value</em>. <a id="page_63"/>When you declare a new variable, or when you create a value with the <code>new()</code> built-in function, it is initialized to the zero value for the type.</p>
<p>As its name implies, the zero value is the value when all of the memory used by the type is filled with zeros. It is common for Go data types to be expected to work with their zero value, without any further initialization. For example, the zero value for a Go mutex is an unlocked mutex: you just need to create the memory for it and it&#8217;s ready to use. Similarly, the zero value for an arbitrary-precision integer in Go represents the value zero.</p>
<p>In other languages, the <em>two-stage creation pattern</em> is common. This separates the allocation and initialization of objects into two explicit steps. In Go, there is no support for explicitly managing memory. If you declare a local variable and then take its address, or declare a pointer and use <code>new()</code> to create an object that it points to, the compiler is likely to generate the same code. The way in which you declare an object is a hint to the compiler, not an instruction. There is therefore little point in supporting two-stage creation in Go.</p>
<p>The second stage is also often redundant. An initializer that takes no arguments should not have to be stated. The fact that it can be commonly leads to bugs.</p>
<p>A concrete example of this is the POSIX thread <a id="page_64"/>API mutex. On FreeBSD, this is a pointer and a <code>NULL</code> value will be implicitly initialized. With the GNU/Linux implementation, it is a structure, and using an uninitialized version has undefined behavior. The compiler, however, has no way of knowing the difference between an initialized and an uninitialized mutex, so it will not give any warnings. A program that forgets to initialize the mutex can compile without any warnings, even at the highest warning level, and it may work sometimes, but it will fail unpredictably on some platforms.</p>
<p>In Go, this kind of bug is very rare. The common structures all use the zero initialization pattern, which means that you can always use a newly created instance of them immediately. The only time that you need to explicitly initialize one is when you want something other than the default behavior.</p>
<p>The same is true of other types. A pointer in Go is always initialized to <code>nil</code>, unless explicitly initialized to point to a valid object. In contrast, a pointer in C declared as a local value can contain any value. It may point to a live variable, or to an invalid memory address.</p>
<p>The Go approach has several advantages. First, there is no need for the compiler to perform complex flow analysis to warn you that a variable might be used uninitialized: there is no such thing as an uninitialized variable. This sounds simple, but determining if a variable may <a id="page_65"/>be used before being initialized is nontrivial, and modern C compilers still don&#8217;t always get it right. Secondly, it simplifies code. You only ever explicitly initialize a variable when you want to then use the value that you assigned to it.</p>
<p>You should aim to support this pattern in any Go structures that you define. Usually, this is easy. If your structure contains other structures as fields, and these structures support this pattern, then you get support for free.</p>
<p>If you are relying on other values, then it can be more complex. This is especially true with pointers: They do not support the zero initialization pattern. If you call a method on a nil pointer then you will get a crash unless the method is careful not to dereference the pointer.</p>
<p>The example at the start of this section shows one way of implementing the zero initialization pattern for structures that contain pointers. This example defines a structure for generating log messages and sending them to a file. The zero structure implicitly uses the standard error file descriptor, rather than a file stored in the structure.</p>
<p>Note that we are not setting the <code>out</code> field in the structure to anything; if it is not set, we are just using a different value. There are two reasons for this. The first is largely aesthetic: it lets us tell the difference between a <code>Logger</code> that is writing to the standard output because it has been explicitly set to use the standard output, and <a id="page_66"/>one that is using it implicitly. In this particular example, it&#8217;s not very important, but in other cases it can be.</p>
<p>The other reason is that it means that this method does not need to take a pointer to the structure. This is quite important because of how it relates to the Go type system. If you call a method via an interface, then methods that accept a pointer are only callable if the interface variable contains a pointer.</p>
<p>For example, you could define an interface that defined the <code>Log()</code> method and create a variable of this type. Then you could assign an instance of the <code>Logger</code> structure to that variable. You could also assign a pointer to an instance of the <code>Logger</code> structure to this variable. Both would work, because the <code>Log()</code> method is callable from both instances of the structure and pointers to instances. If the method took a pointer argument, then you would only be able to call it on pointers. It&#8217;s therefore good style in Go to only require methods to take a pointer when they modify the structure, or if the structure is so large that copying it on every method call would be prohibitive.</p>
<h3 id="ch04lev1sec2"><a id="page_67"/>Generic Data Structures</h3>
<p class="pre">&#160;4&#160;&#160;<span class="EmpStrong">type</span> stackEntry <span class="EmpStrong">struct</span>{<br/>&#160;5&#160;&#160;&#160;&#160;next *stackEntry<br/>&#160;6&#160;&#160;&#160;&#160;value <span class="EmpStrong">interface</span>{}<br/>&#160;7&#160;&#160;}<br/>&#160;8&#160;&#160;<span class="EmpStrong">type</span> stack <span class="EmpStrong">struct</span> {<br/>&#160;9&#160;&#160;&#160;&#160;top *stackEntry<br/>10&#160;&#160;}<br/>11<br/>12&#160;&#160;<span class="EmpStrong">func</span> (s *stack) Push(v <span class="EmpStrong">interface</span>{}) {<br/>13&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> e stackEntry<br/>14&#160;&#160;&#160;&#160;e.value = v<br/>15&#160;&#160;&#160;&#160;e.next = s.top<br/>16&#160;&#160;&#160;&#160;s.top = &#38;e<br/>17&#160;&#160;}<br/>18&#160;&#160;<span class="EmpStrong">func</span> (s *stack) Pop() <span class="EmpStrong">interface</span>{} {<br/>19&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> s.top == nil {<br/>20&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span>&#160;nil<br/>21&#160;&#160;&#160;&#160;}<br/>22&#160;&#160;&#160;&#160;v := s.top.value<br/>23&#160;&#160;&#160;&#160;s.top = s.top.next<br/>24&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span>&#160;v<br/>25&#160;&#160;}</p>
<p class="example"><a id="ch04ex02"/>From: genericStack.go</p>
<p>The <em>empty interface type</em> is a very important part of the Go type system. This has a similar, although slightly more generic, place to <code>void*</code> in C: It can represent any type. The empty interface literally means &#8220;any type that implements&#8212;at the least&#8212;no methods,&#8221; a restriction matched by every type.</p>
<p>It is common to use the empty interface type in generic data structures. If you can store values of the generic interface type, then you can store <a id="page_68"/>values of any type. You can&#8217;t, however, perform any operations on them.</p>
<p>If you want to create something like a set, then you must define a mechanism for defining equality, which typically involves defining an interface with an <code>isEqual()</code> method or something similar. If you are creating a data structure that doesn&#8217;t need to be aware of the representation or semantics of the values that it contains, then you should use the empty interface.</p>
<p>The example at the start of this section shows a generic stack type, with <code>Push()</code> and <code>Pop()</code> methods, capable of storing any Go type. The implementation is very simple: a singly-linked list of a private structure type that stores a value.</p>
<p>You can use the same technique when creating far more complex data structures. The advantage of using the empty interface type is that it allows both structure and primitive types to be stored. In the next section, we&#8217;ll look at how you can extend this general approach and specialize it for specific types.</p>
<h3 id="ch04lev1sec3"><a id="page_69"/>Specialized Generic Data Structures</h3>
<p class="pre">31&#160;&#160;<span class="EmpStrong">func</span> (s *stack) pushInt(v int64) {<br/>32&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> (s.isInteger) {<br/>33&#160;&#160;&#160;&#160;&#160;&#160;top := s.top.(*integerStackEntry)<br/>34&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> top.value == v {<br/>35&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;top.count++<br/>36&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span><br/>37&#160;&#160;&#160;&#160;&#160;&#160;}<br/>38&#160;&#160;&#160;&#160;}<br/>39&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> e integerStackEntry<br/>40&#160;&#160;&#160;&#160;e.value = v<br/>41&#160;&#160;&#160;&#160;e.next = s.top<br/>42&#160;&#160;&#160;&#160;s.top = &#38;e<br/>43&#160;&#160;&#160;&#160;s.isInteger = true<br/>44&#160;&#160;}<br/>45&#160;&#160;<span class="EmpStrong">func</span> (s *stack) Push(v <span class="EmpStrong">interface</span>{}) {<br/>46&#160;&#160;&#160;&#160;<span class="EmpStrong">switch</span> val := v.(<span class="EmpStrong">type</span>) {<br/>47&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> int64: s.pushInt(val)<br/>48&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> int: s.pushInt(int64(val))<br/>49&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">default:</span><br/>50&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> e genericStackEntry<br/>51&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;e.value = v<br/>52&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;e.next = s.top<br/>53&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s.top = &#38;e<br/>54&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s.isInteger = false<br/>55&#160;&#160;&#160;&#160;}<br/>56&#160;&#160;}</p>
<p class="example"><a id="ch04ex03"/>From: specializedStack.go</p>
<p>Suppose you wanted to use the stack from the last section in a push-down automaton. You&#8217;d probably be mainly pushing and popping integers, and often pushing the same integer several times in a row. There&#8217;s a large potential <a id="page_70"/>for optimization: you can have a specialized version of the stack entry that stores an integer and a count. If you push the same integer twice, then you just increment the count, saving the overhead of an allocation.</p>
<p>The example at the start of this section shows an expanded <code>Push()</code> method that does this. This now uses two types: one for the generic case and one for the integer case.</p>
<p class="pre-1">&#160;4&#160;&#160;<span class="EmpStrong">type</span> stackEntry <span class="EmpStrong">interface</span> {<br/>&#160;5&#160;&#160;&#160;&#160;pop() (<span class="EmpStrong">interface</span>{}, stackEntry)<br/>&#160;6&#160;&#160;}<br/>&#160;7&#160;&#160;<span class="EmpStrong">type</span> genericStackEntry <span class="EmpStrong">struct</span> {<br/>&#160;8&#160;&#160;&#160;&#160;next stackEntry<br/>&#160;9&#160;&#160;&#160;&#160;value <span class="EmpStrong">interface</span>{}<br/>10&#160;&#160;}<br/>11&#160;&#160;<span class="EmpStrong">func</span> (g genericStackEntry) pop() (<span class="EmpStrong">interface</span>{},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;stackEntry) {<br/>12&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> g.value, g.next<br/>13&#160;&#160;}<br/>14&#160;&#160;<span class="EmpStrong">type</span> integerStackEntry&#160;&#160;<span class="EmpStrong">struct</span> {<br/>15&#160;&#160;&#160;&#160;value int64<br/>16&#160;&#160;&#160;&#160;count int<br/>17&#160;&#160;&#160;&#160;next stackEntry<br/>18&#160;&#160;}<br/>19&#160;&#160;<span class="EmpStrong">func</span> (i *integerStackEntry) pop() (<span class="EmpStrong">interface</span>{},<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;stackEntry) {<br/>20&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> (i.count &gt; 0) {<br/>21&#160;&#160;&#160;&#160;&#160;&#160;i.count--<br/>22&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> i.value, i<br/>23&#160;&#160;&#160;&#160;}<br/>24&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> i.value, i.next<br/>25&#160;&#160;}</p>
<p class="example"><a id="ch04ex04"/>From: specializedStack.go</p>
<p><a id="page_71"/>When you push an integer, it uses a type switch statement to determine the type, and checks whether the last value to be pushed was an integer and if it has the same value as the top value. In this case, it just increments the count.</p>
<p>This example splits the specialized work up a bit between the generic data structure and the specialized components. You might want to modify it to add a <code>tryPush()</code> method to the <code>stackEntry</code> interface, which would try to add the value without adding a new stack entry. If this failed, then you could allocate a new entry of the same type.</p>
<p>This pattern shows one of the big advantages of the loose coupling that Go provides. The interface to the stack that uses a combination of <code>genericStackEntry</code> and <code>integerStackEntry</code> structures for its elements is completely compatible with the one from the last section, but is now more efficient for storing large sequences of identical integer values. The details of the two concrete structures implementing stack entries are completely hidden.</p>
<p>You can use this same approach to implement generic collections and then specialize them for your data. Complex collections in languages like Go typically incorporate this kind of self-optimizing behavior.</p>
<p>This is a fairly simple example and the saving in this case is not particularly worthwhile. If you were implementing a real stack, then a slice of <a id="page_72"/>empty interfaces would almost certainly be a lot faster and use less memory. The point of this example is to show you the general pattern, not how to write an efficient stack in Go.</p>
<p>This pattern is very useful in more complex data structures. For example, the underlying implementation of the map types uses a similar technique, generating a hash value based on the underlying type. You might want to do something similar, providing a built-in hash for basic types, using a zero hash by default, or using the <code>Hash()</code> method if one exists.</p>
<h3 id="ch04lev1sec4">Implementation Hiding</h3>
<p class="pre">27&#160;&#160;<span class="EmpStrong">type</span> Stack <span class="EmpStrong">interface</span> {<br/>28&#160;&#160;&#160;&#160;Push(<span class="EmpStrong">interface</span>{})<br/>29&#160;&#160;&#160;&#160;Pop() <span class="EmpStrong">interface</span>{}<br/>30&#160;&#160;}<br/>31&#160;&#160;<span class="EmpStrong">func</span> NewStack() Stack {<br/>32&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> &#38;stack{}<br/>33&#160;&#160;}</p>
<p class="example"><a id="ch04ex05"/>From: genericStack.go</p>
<p>Interfaces in Go are exactly what their name implies. They define how you interact with a type, not how it is implemented. If users of your structure do not need to be able to access any of the fields, then it is good style to only export an interface exposing the public methods, rather than the structure itself.</p>
<p><a id="page_73"/>The example at the start of this section shows a public interface for the two stack structures that we&#8217;ve defined already this chapter, along with a function for constructing it. By convention, the function that creates the concrete instance is named <code>NewSomething()</code>, if <code>Something</code> is the name of the interface.</p>
<p>This is not the only way of hiding implementation details. Any structure member that does not start with a capital letter is automatically hidden, and is only accessible from within the package in which it is declared. As such, the structures that we&#8217;ve defined to implement the stacks are already hiding the details of their implementation: none of their fields is visible from other packages.</p>
<p>The correct approach to use depends on how you expect people to use your structures. Only exporting the interface gives you the most flexibility, because you can completely change any details of the implementation without altering code that uses it. You can even implement several different structures optimized for different use cases and return different ones depending on the use. On the other hand, this approach prevents people from allocating instances of your structure on the stack, and prevents you from using the <em>zero initialization pattern</em>.</p>
<p>Although Go does not support explicit stack allocation, the compiler will try to allocate <a id="page_74"/>structures on the stack as an implementation detail if they are short-lived and do not have their address taken. This is very fast, as it just requires modifying the value of a register: variables on the stack are allocated just by moving the stack pointer. If the object is returned as a pointer via a constructor function, then the compiler is unable to do this, and will need to request memory that is managed by the garbage collector. For short-lived structures, this can be a significant performance penalty.</p>
<h3 id="ch04lev1sec5"><a id="page_75"/>Type Embedding</h3>
<p class="pre">&#160;4&#160;&#160;<span class="EmpStrong">type</span> A <span class="EmpStrong">struct</span> {}<br/>&#160;5&#160;&#160;<span class="EmpStrong">type</span> B <span class="EmpStrong">struct</span> {}<br/>&#160;6&#160;&#160;<span class="EmpStrong">func</span> (_ A) Print() { fmt.Printf("A printed\n") }<br/>&#160;7&#160;&#160;<span class="EmpStrong">func</span> (_ B) Print() { fmt.Printf("B printed\n") }<br/>&#160;8&#160;&#160;<span class="EmpStrong">func</span> (a A) PrintA() { a.Print() }<br/>&#160;9&#160;&#160;<span class="EmpStrong">type</span> C <span class="EmpStrong">struct</span> {<br/>10&#160;&#160;&#160;&#160;A<br/>11&#160;&#160;&#160;&#160;*B<br/>12&#160;&#160;}<br/>13&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>14&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> c C<br/>15&#160;&#160;&#160;&#160;c.B = &#38;B{}<br/>16&#160;&#160;&#160;&#160;// Implicitly inherited<br/>17&#160;&#160;&#160;&#160;c.PrintA()<br/>18&#160;&#160;&#160;&#160;// Not allowed: ambiguous<br/>19&#160;&#160;&#160;&#160;// c.Print()<br/>20&#160;&#160;&#160;&#160;// Explicitly disambiguated<br/>21&#160;&#160;&#160;&#160;c.B.Print()<br/>22&#160;&#160;&#160;&#160;c.A.Print()<br/>23&#160;&#160;}</p>
<p class="example"><a id="ch04ex06"/>From: embed.go</p>
<p>Go doesn&#8217;t support subclassing, but it is possible to achieve something similar via the limited form of implicit delegation that Go does support.</p>
<p>If you make an unnamed field in a Go structure, then any methods defined by the type of the field are implicitly added to the enclosing structure. The example at the start of this section contains a structure <code>C</code> that has two unnamed fields: fields with a type (<code>A</code> and <code>B*</code>), but with no name.</p>
<p>Note that the receiver for any of these methods <a id="page_76"/>will be the field, not the outer structure. This means that, even if the receiver is a pointer, it is not possible for it to access any of the fields in the outer structure. This can be slightly inconvenient. For example, it would be useful to be able to provide a <code>List</code> structure that could be added to any structure that needed list behavior, adding a <code>Next()</code> method returning the next item in the list, but this is not possible.</p>
<p>The example at the start of this section shows a problem that can occur when embedding structures in this way: What happens when two inner structures implement the same methods? There are lots of ways of solving this problem, including priority schemes, which can get very complicated with multiple layers of nesting.</p>
<div class="note"><hr/>
<p class="title"><a id="ch04note01"/>Note</p>
<p class="notepara">There is no direct Go equivalent of a C++ virtual base class. If a Go structure contains structures A and B as fields, and each of these contains an instance of a C as a field, then the outer structure will always contain two instances of C. It is possible to achieve something similar by making A and B contain a pointer to C, and explicitly setting them to point to the same instance.</p>
<hr/></div>
<p>The Go solution is to make programmers explicitly specify what they mean. Calling <code>c.Print()</code> in this example (the commented-out line) would cause the compiler to reject <a id="page_77"/>the program: it can&#8217;t figure out which <code>Print()</code> method you really mean without potentially introducing bugs into your program. You could extend this example by adding an explicit <code>Print()</code> method to <code>C</code> that delegated to one of the fields, or implemented the method in some other way.</p>
<p>Note that this example uses both a pointer and a value as fields, but the methods work on both. Exactly the same rules for methods apply in this case. The pointer field will add methods that take a value or a pointer, and the value field will add methods that take the value.</p>
</body>
</html>