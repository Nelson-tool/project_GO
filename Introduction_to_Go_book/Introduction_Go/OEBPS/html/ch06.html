<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>6. Manipulating Strings</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch06"><a id="page_91"/>6. Manipulating Strings</h2>
<p>C was created in America, back when it was fashionable to pretend that the rest of the world didn&#8217;t exist, so it used 7-bit ASCII<sup><a id="ch06fn01" href="footnotes.html#ch06fn01a">1</a></sup> characters to represent strings.</p>
<p>Go is more recent, and since then most technology companies in the USA have discovered that it&#8217;s quite a good idea to support other languages, mostly so you can sell things to people in other countries. Go uses UTF-8. This is entirely unsurprising, as UTF-8 was originally designed (on a diner placemat) by Rob Pike and Ken Thompson, two of the designers of Go.</p>
<p>Go strings are slightly higher-level than <a id="page_92"/>C strings, and there are some important differences. The most obvious is that the Go string type is immutable, like C constant strings and Java strings. Although strings behave very much like arrays, they are a separate type, with their own unique behavior. In some cases, you can treat a string as an array (or, rather, a slice) of bytes, while in others the fact that it contains Unicode character data becomes important.</p>
<h3 id="ch06lev1sec1">Comparing Strings</h3>
<p class="pre">&#160;5&#160;&#160;str1 := "A string"<br/>&#160;6&#160;&#160;str2 := "A " + "string"<br/>&#160;7&#160;&#160;<span class="EmpStrong">if</span> (str1 == str2) {<br/>&#160;8&#160;&#160;&#160;&#160;fmt.Printf("'%s' and '%s' are equal\n", str1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str2)<br/>&#160;9&#160;&#160;}<br/>10&#160;&#160;<span class="EmpStrong">if</span> (&#38;str1 == &#38;str2) {<br/>11&#160;&#160;&#160;&#160;fmt.Printf("'%s' and '%s' are identical\n",<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str1, str2)<br/>12&#160;&#160;}<br/>13&#160;&#160;str2 += " with a suffix"<br/>14&#160;&#160;<span class="EmpStrong">if</span> (str1 &lt; str2) {<br/>15&#160;&#160;&#160;&#160;fmt.Printf("'%s' comes before '%s'\n", str1,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str2)<br/>16&#160;&#160;}</p>
<p class="example"><a id="ch06ex01"/>From: compareStrings.go</p>
<p>Go strings are a high-level type, and have the concept of equality built in. A large percentage of bugs in C code relate to the handling of strings, and fixing this was one of the important tasks when designing Go.</p>
<p><a id="page_93"/>This is obvious when you look at comparing strings in the two languages. In C, a string is just a pointer to some bytes somewhere in memory. In Go, it is a real data type, built on the same low-level abstraction, but providing a more human-friendly interface.</p>
<p>When you use the normal comparison operators in Go, you get a result that makes sense considering the semantic content of the string. If two strings have the same character contents, they are considered equal. The less-than and greater-than operators will return an ordering based on their lexical ordering.</p>
<p>Unfortunately, this highlights one of the areas in which Go is currently very weak: localization. Strings are ordered based on the Unicode values of their constituent characters. In some locales, this is correct, but in others it is not. For example, the ordering between E and &#201; is highly dependent on the locale. In some, they should be together, but in other locales, accented characters come after all non-accented characters. Go does not currently provide any locale-aware means of sorting strings. In C++, you could use operator overloading to define a new string type that supported locale-aware sorting. The lack of operator overloading in Go makes this impossible.</p>
<div class="note"><hr/>
<p class="title"><a id="ch06note01"/><a id="page_94"/>Note</p>
<p class="notepara">Go is under constant development, so just because certain functionality doesn&#8217;t exist at the time of writing does not mean that it won&#8217;t exist by the time you read this. Check the Go package directory (<a href="http://golang.org/pkg/">http://golang.org/pkg/</a>) for locale support; it may have been added since publication.</p>
<hr/></div>
<h3 id="ch06lev1sec2">Processing a String One Character at a Time</h3>
<p class="pre">&#160;4&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;5&#160;&#160;&#160;&#160;str := "&#201;toil&#233;"<br/>&#160;6&#160;&#160;&#160;&#160;// Don't do this!<br/>&#160;7&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i := 0 ; i&lt;len(str) ; i++ {<br/>&#160;8&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%c", str[i])<br/>&#160;9&#160;&#160;&#160;&#160;}<br/>10&#160;&#160;&#160;&#160;fmt.Printf("\n")<br/>11&#160;&#160;&#160;&#160;// Do this instead<br/>12&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> _, c := <span class="EmpStrong">range</span> str {<br/>13&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%c", c)<br/>14&#160;&#160;&#160;&#160;}<br/>15&#160;&#160;&#160;&#160;fmt.Printf("\n")<br/>16&#160;&#160;}</p>
<p class="example"><a id="ch06ex02"/>From: stringIterate.go</p>
<p>The na&#239;ve way of iterating over the characters in a string would be to use a <span class="EmpStrong">for</span> loop indexing each character. This almost works, but it iterates over every byte, not every character.</p>
<p>UTF-8 is a way of encoding Unicode characters. There are several different encodings for <a id="page_95"/>Unicode, with UTF-8 and UTF-16 being the two most common. Both of these are <em>multibyte character encodings</em>, meaning that one character may be represented by more than one byte. In fact, they are both variable-length encodings as well. The 8 and 16 in their names refer to the number of bits in the smallest encodings.</p>
<p>A character encoded in UTF-8 is somewhere between one and four bytes long, depending on the character. The 128 ASCII characters are all single bytes, while other characters are longer.</p>
<p>If you iterate over a string using byte indexes, then your code may work. Only one of the characters in this section so far has had a multibyte encoding in UTF-8: the &#239; in na&#239;ve. Without that, it would be perfectly safe to treat this entire section as ASCII when manipulating it. If English is your native language, then it&#8217;s very easy to test code dealing with strings with input data that looks representative, and then have it break the first time someone else uses it.</p>
<p class="pre-1">1&#160;&#160;&#195;toil&#195;&#169;<br/>2&#160;&#160;&#201;toil&#233;</p>
<p class="example"><a id="ch06ex03"/>Output from: stringIterate.go</p>
<p>Fortunately, there is another alternative. The standard Go iteration pattern also works on strings. This returns each character, as a 32-bit integer representing a single Unicode character.</p>
<p><a id="page_96"/>Even this isn&#8217;t quite correct. Unicode supports the idea of <em>composed characters</em>, where a single character is defined by a sequence of code points. Fortunately, unless you are writing a text layout engine, it&#8217;s almost always safe to ignore these.</p>
<h3 id="ch06lev1sec3">Processing a Partial String One Character at a Time</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;3&#160;&#160;<span class="EmpStrong">import</span> "unicode/utf8"<br/>&#160;4<br/>&#160;5&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;6&#160;&#160;&#160;&#160;str := "&#201;toil&#233;"<br/>&#160;7&#160;&#160;&#160;&#160;rune := make([]byte, 0, 4)<br/>&#160;8&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i := 0 ; i&lt;len(str) ; i++ {<br/>&#160;9&#160;&#160;&#160;&#160;&#160;&#160;rune = append(rune, str[i])<br/>10&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> (utf8.FullRune(rune)) {<br/>11&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;char, _ := utf8.DecodeRune(rune)<br/>12&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%c", char)<br/>13&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rune = rune[0:0]<br/>14&#160;&#160;&#160;&#160;&#160;&#160;}<br/>15&#160;&#160;&#160;&#160;}<br/>16&#160;&#160;&#160;&#160;fmt.Printf("\n")<br/>17&#160;&#160;}</p>
<p class="example"><a id="ch06ex04"/>From: partialStringIterate.go</p>
<p>When you have a complete string in memory, it&#8217;s easy to iterate over it, but what happens when you are receiving text from the network, or reading it from the disk? In both cases, you will typically end up with buffers full of bytes in UTF-8 format.</p>
<p><a id="page_97"/>With ASCII data, this wouldn&#8217;t be a problem. One byte means one character. With UTF-8, a single byte may be a character, or it may be the first byte in a multibyte character. The <em>unicode/utf8 package</em> provides some helpful functions for telling these two apart.</p>
<p>The example from the start of this section uses a static string, but the same code would work on a stream of bytes acquired from any source. It collects the bytes into a short buffer until they represent a complete character, and then decodes them.</p>
<p>This is quite cumbersome. It demonstrates some of the more powerful string manipulation facilities in Go, but in real code you&#8217;d be much more likely to use something along the lines of the <span class="romanAlt">partialStringIterate2.go</span> example.</p>
<p class="pre-1">&#160;4&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;5&#160;&#160;&#160;&#160;str := "&#201;toil&#233;"<br/>&#160;6&#160;&#160;&#160;&#160;bytes := str[0:7]<br/>&#160;7&#160;&#160;&#160;&#160;str2 := string(bytes)<br/>&#160;8&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i, c := <span class="EmpStrong">range</span> str2 {<br/>&#160;9&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> (0xFFFD == c) {<br/>10&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;str2 = str2[i:]<br/>11&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">break</span><br/>12&#160;&#160;&#160;&#160;&#160;&#160;} <span class="EmpStrong">else</span> {<br/>13&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%c", c)<br/>14&#160;&#160;&#160;&#160;&#160;&#160;}<br/>15&#160;&#160;&#160;&#160;}<br/>16&#160;&#160;&#160;&#160;fmt.Printf("\n")<br/>17&#160;&#160;}</p>
<p class="example"><a id="ch06ex05"/>From: partialStringIterate2.go</p>
<p><a id="page_98"/>This uses normal string iteration, but checks for the value <code>0xFFFD</code>, used to represent an invalid rune. If it finds one, then it stores the partial string and then escapes from the loop.</p>
<p>For efficiency, you could skip this check for the majority of the string, and only perform it on the last few bytes. If you find an invalid rune somewhere before the end of the string, it means that your input data is invalid.</p>
<p>This example starts by slicing a string in the middle of a multibyte sequence, in the middle of the trailing &#233; in &#201;toil&#233;. This is very easy to do by accident. In general, you should avoid slicing strings directly. The utf8 package contains a <code>Slice()</code> function, which slices a string at run indexes, rather than at byte indexes.</p>
<h3 id="ch06lev1sec4">Splitting and Trimming Strings</h3>
<p class="pre">&#160;2<br/>&#160;3&#160;&#160;<span class="EmpStrong">import</span> "strings"<br/>&#160;4&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;5<br/>&#160;6&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;7&#160;&#160;&#160;&#160;str := "\tThis is a string \n"<br/>&#160;8&#160;&#160;&#160;&#160;str = strings.Trim(str, " \t\n\r")<br/>&#160;9&#160;&#160;&#160;&#160;words := strings.Split(str, " ")<br/>10&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> _, word := <span class="EmpStrong">range</span> words {<br/>11&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%s\n", word)<br/>12&#160;&#160;&#160;&#160;}<br/>13&#160;&#160;}</p>
<p class="example"><a id="ch06ex06"/>From: trimStrings.go</p>
<p><a id="page_99"/>The <em>strings package</em> contains some helpful functions for manipulating string data. This includes splitting and searching strings.</p>
<p>One very common activity is trimming the whitespace from the ends of a string. Both the <span class="romanAlt">trimStrings.go</span> and <span class="romanAlt">splitString.go</span> examples show ways of doing this.</p>
<p>The first explicitly declares the characters to treat as spaces: space, tab, carriage return, and line feed. The second is more interesting. It uses the <code>IsSpace()</code> function from the <em>unicode package</em>. This function identifies whether any Unicode character is classed as a space. You can use the same mechanism with other functions to trim other types of leading and trailing data. The unicode package provides some other functions that you can use here, but you can also define your own, to define a set algorithmically.</p>
<p>If you&#8217;ve ever used <code>strtok()</code> or <code>strsep()</code> in C, then you&#8217;ll appreciate the ease of splitting strings in Go. The <code>Split()</code> function from the strings package splits a string according to a provided separator. In the example at the start of this chapter, we use it to split a string into words, separated by spaces. The result is a slice of strings, so you can easily iterate over it just as you would any other slice.</p>
<p>Splitting a string at a specific character index is a bit harder. The <span class="romanAlt">splitString.go</span> example shows what happens when you get this wrong. This shows two ways of splitting a string in half.</p>
<p class="pre-1">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "strings"<br/>&#160;3&#160;&#160;<span class="EmpStrong">import</span> "unicode"<br/>&#160;4&#160;&#160;<span class="EmpStrong">import</span> "exp/utf8string"<br/>&#160;5&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;6<br/>&#160;7&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;8&#160;&#160;&#160;&#160;str := "\tthe important r&#244;les of utf8 text\n"<br/>&#160;9&#160;&#160;&#160;&#160;str = strings.TrimFunc(str, unicode.IsSpace)<br/>10&#160;&#160;&#160;&#160;// The wrong way<br/>11&#160;&#160;&#160;&#160;fmt.Printf("%s\n", str[0:len(str)/2])<br/>12&#160;&#160;&#160;&#160;// The right way<br/>13&#160;&#160;&#160;&#160;u8 := utf8string.NewString(str)<br/>14&#160;&#160;&#160;&#160;FirstHalf := u8.Slice(0, u8.RuneCount()/2)<br/>15&#160;&#160;&#160;&#160;fmt.Printf("%s\n", FirstHalf)<br/>16&#160;&#160;}</p>
<p class="example"><a id="page_100"/><a id="ch06ex07"/>From: splitString.go</p>
<p class="pre-1">1&#160;&#160;the important r?<br/>2&#160;&#160;the important r&#244;</p>
<p class="example"><a id="ch06ex08"/>Output from: splitString.go</p>
<p>The first way is the obvious approach. You slice the string, using half its length as the index for the end of the slice. This, unfortunately, slices the string right down the center of the &#244; character.</p>
<p>The second way is a little bit more involved. This uses the <em>exp/utf8string package</em>, first to count the number of runes in the string and then to split the string at a run index, rather than a byte index.</p>
<div class="note"><hr/>
<p class="title"><a id="ch06note02"/><a id="page_101"/>Note</p>
<p class="notepara">This example uses a package from the exp hierarchy, which is not part of the standard Go 1.0 install. To run it, you will need to download the exp packages from the Go repository. If you are using the trunk version of Go, you probably have them installed already. Packages in the exp hierarchy are experimental and are intended to become standard parts of the Go library when they are finished. If you are using a Go release after 1.0 then you may find that the package is available without the exp/ prefix.</p>
<hr/></div>
<p>This involved creating a <code>String</code> structure, wrapping the string. If you&#8217;re doing a lot of complex things to a string, then this is a lot more efficient than using the underlying string directly.</p>
<p>Note that the utf8string package is in the exp hierarchy. This means that it is considered experimental and its functionality may be incorporated into another package (unicode/utf8 would be an obvious choice) or change before the package is finalized.</p>
<h3 id="ch06lev1sec5"><a id="page_102"/>Copying Strings</h3>
<p class="pre">5&#160;&#160;str := "A string"<br/>6&#160;&#160;bytes := make([]byte, len(str))<br/>7&#160;&#160;copy(bytes, str)<br/>8&#160;&#160;strCopy := string(bytes)</p>
<p class="example"><a id="ch06ex09"/>From: stringCopy.go</p>
<p>Strings in Go are immutable, so there is no need to copy them. There is, however, a need to copy the data that they contain. The <code>copy()</code> built-in function allows you to copy a string into a preallocated byte slice, returning the number of bytes that it copied.</p>
<p>Once you&#8217;ve got the string data in a slice, you can modify it in any way that you want. You can then construct a new string from the slice with the standard <code>string()</code> conversion. You can also use <code>append()</code> to append a string to an existing slice of <code>bytes</code>.</p>
<p>Note that when you do this the string data will be copied twice, once into the slice and once to create the new string. This is fairly inefficient, so it should be avoided except for short strings.</p>
<h3 id="ch06lev1sec6">Creating Strings from Patterns</h3>
<p class="pre">5&#160;&#160;str := fmt.Sprintf("%T %#v, %d, %v", main, main,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;42, "aubergine")</p>
<p class="example"><a id="ch06ex10"/>From: sprintf.go</p>
<p><a id="page_103"/>Most of the examples so far have used the <code>fmt.Printf()</code> function for output. This is quite similar to the standard C <code>printf()</code> function, but with a few improvements. The main difference is due to how Go handles variadic functions. Every argument passed to <code>Printf()</code> after the format string is passed in a slice of empty interface elements. The function can inspect each one and see what its type is.</p>
<p>This means that most of the format specifiers in C&#8217;s <code>printf()</code> function are redundant. Their main purpose is to tell the function how to decode arguments that are pushed onto the stack. Go functions don&#8217;t need help with that.</p>
<p>That&#8217;s not to say that they&#8217;re entirely pointless. There is sometimes ambiguity as to how a value should be represented. For example, the <code>%f</code> format specifier omits an exponent from floating-point values, while <code>%E</code> always displays them.</p>
<p>Go introduces three interesting format specifiers, shown in the example at the start of this section. The <code>%v</code> specifier shows the value in its default format, either using a built-in formatter or calling the <code>String()</code> method on structures that implement one. The <code>%#v</code> specifier is similar, but it outputs the value as a Go-syntax literal value. <code>%T</code> prints the type.</p>
<p>The last of these can be incredibly useful for debugging. If you have received a value somewhere in some code via an empty interface, <a id="page_104"/>you can just print its type with this function, rather than having to trace all of the way back to where it was declared.</p>
<h3 id="ch06lev1sec7">Matching Patterns in Strings</h3>
<p class="pre">&#160;5&#160;&#160;<span class="EmpStrong">var</span> static = regexp.MustCompile(", *")<br/>&#160;6<br/>&#160;7&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;8&#160;&#160;&#160;&#160;r, _ := regexp.Compile("abcd*")<br/>&#160;9&#160;&#160;&#160;&#160;str := "abcddd fish, wibble abcd, abc, foo"<br/>10&#160;&#160;&#160;&#160;fmt.Printf("Replaced: %v\n", r.ReplaceAllString<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(str, "bar"))<br/>11&#160;&#160;&#160;&#160;fmt.Printf("Replaced: %v\n", static.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ReplaceAllString(str, ".&#160;&#160;"))<br/>12&#160;&#160;}</p>
<p class="example"><a id="ch06ex11"/>From: regex.go</p>
<p>Most modern languages provide some support for regular expressions. Some, like Perl and JavaScript, embed this support in the language. Most others provide them as part of the standard library.</p>
<p>In Go, regular expressions are provided via the <em>regexp package</em>. This defines a <code>Regexp</code> type, encapsulating a regular expression. These are created by compiling string representations of regular expressions into an internal state-machine representation. The compiled regular expression can then be applied to strings, byte slices, or rune readers.</p>
<p>The example at the start of this section shows <a id="page_105"/>one of the most common uses for regular expressions: replacing all matching occurrences in a string with a new pattern. You can also request the locations of the matches and perform your own substitution, or simply report their locations.</p>
<p>Compiling a regular expression is quite expensive. If you are using a regular expression more than once, then it&#8217;s a good idea to create it once and then store it. The <code>MustCompile()</code> function helps with this. It is equivalent to <code>Compile()</code> when the input string is valid, but panics if it is not. If you use it when initializing globals, as in the example, then your program will fail to start if your regular expression is invalid.</p>
</body>
</html>