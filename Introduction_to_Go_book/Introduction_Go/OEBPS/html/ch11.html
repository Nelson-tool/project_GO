<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>11. Dates and Times</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch11"><a id="page_175"/>11. Dates and Times</h2>
<p>Unsurprisingly, given its antecedents, Go inherits the UNIX notion of time. Time is represented at the low level by the number of seconds since the UNIX Epoch: the start of 1970 UTC. Local time is calculated from this by applying a time zone offset, and can then be converted into something suitable for display, such as a year, month, and day.</p>
<p>Most Go APIs use nanoseconds for <em>time intervals</em>. It&#8217;s important to differentiate between time and time intervals. A time is a fixed point relative to some epoc date and depends on things like the current time zone. A time interval, in contrast, is a quantity that makes sense in isolation.</p>
<p>The <em>time package</em> includes two types for representing these two concepts. A <code>Duration</code> represents a length of time, while a <code>Time</code> represents a fixed point in time.</p>
<h3 id="ch11lev1sec1"><a id="page_176"/>Finding the Current Date</h3>
<p class="pre">7&#160;&#160;fmt.Printf("%d seconds since the Epoc\n", now.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Unix())<br/>8&#160;&#160;fmt.Printf("%d nanoseconds since the Epoc\n", now<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.UnixNano())</p>
<p class="example"><a id="ch11ex01"/>From: now.go</p>
<p>The lowest-level mechanism for getting the time is in the <em>runtime package</em> and is private to the implementation. The private <code>now()</code> function in the runtime is a very thin wrapper around the <code>gettimeofday()</code> system call on UNIX and its equivalent on other systems. The system call returns a structure containing the number of elapsed seconds and microseconds.</p>
<p>The <em>time package</em> provides a convenient function, <code>Now()</code>, which returns a <code>Time</code> structure encapsulating the time. This structure also contains a time zone, so you can safely compare instances of it even if they are related to different events. You can then use its <code>Unix()</code> and <code>UnixNano()</code> methods, which return the time in seconds and nanoseconds, respectively.</p>
<p>The <code>Time</code> structure provides a large number of other methods for inspecting and comparing times. We&#8217;ll look at some of them in the rest of this chapter.</p>
<h3 id="ch11lev1sec2"><a id="page_177"/>Converting Dates for Display</h3>
<p class="pre">7&#160;&#160;now := time.Now()<br/>8&#160;&#160;fmt.Printf("Today is %s\n", now.Format("Monday"))<br/>9&#160;&#160;fmt.Printf("The time is %s\n", now.Format(time.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Kitchen))</p>
<p class="example"><a id="ch11ex02"/>From: localNow.go</p>
<p>When it comes to user interaction, we unfortunately see some big gaps in the Go standard library. Just as C assumed that everyone used text representable in ASCII, Go assumes that everyone uses the Gregorian calendar. This is fine if you only expect to have users in America or Europe, but in other parts of the world it&#8217;s likely to cause problems.</p>
<div class="note"><hr/>
<p class="title"><a id="ch11note01"/>Note</p>
<p class="notepara">Check the current documentation for the time package before using it. Hopefully it will have improved by the time you read this. The current implementation is full of implicit US-centric conventions. It is difficult to use in code that needs to work in Europe (it does not allow non-English day names to be used in format strings), and impossible to use in countries using the Islamic or Chinese calendars, which are completely unsupported.</p>
<hr/></div>
<p>If you only have to worry about people using the Gregorian calendar, then Go provides some useful features. The <code>Time</code> structure encapsulates <a id="page_178"/>a local date, as represented by the Gregorian calendar. This has public fields containing things like the month and day. You can either access these fields explicitly, or you can use the <code>Format()</code> method to prepare such a date for display.</p>
<p>Go date format strings are slightly non-obvious. Rather than defining a format string with escape sequences for things like the day of the week, they uses a specific date. This date is the fifth second after the fourth minute of the third hour in the afternoon of the second day of the first month, in the sixth year in the second millennium, with time zone offset -0700. This date was chosen because the value for each date component is different. Each component is in order when written in the middle-endian date format popular in the USA.</p>
<p>If you want to specify a date format explicitly, then you must write how this date would be represented using your format. For example, a little-endian date with a 24-hour time and an abbreviated day-of-the-week would be written as the string <code>"2006-1-2 (Mon) 15:04:05"</code>.</p>
<p>The package provides several standard formats. The most useful is <code>time.RFC3339</code>. This defines the long format from ISO 8601 format, which defines the international standard for unambiguous date formatting. The example at the start of this section uses the <code>time.Kitchen</code> standard, which defines a simple format for <a id="page_179"/>times, suitable for use in locales that use 12-hour time.</p>
<h3 id="ch11lev1sec3">Parsing Dates from Strings</h3>
<p class="pre">&#160;6&#160;&#160;<span class="EmpStrong">var</span> t string<br/>&#160;7&#160;&#160;fmt.Printf("Enter a time\n")<br/>&#160;8&#160;&#160;fmt.Scanf("%s", &#38;t)<br/>&#160;9&#160;&#160;parsed, err := time.Parse("03:04PM", t)<br/>10&#160;&#160;<span class="EmpStrong">if</span> err != nil {<br/>11&#160;&#160;&#160;&#160;parsed, err = time.Parse("15:04", t)<br/>12&#160;&#160;}<br/>13&#160;&#160;<span class="EmpStrong">if</span> err != nil {<br/>14&#160;&#160;&#160;&#160;fmt.Printf("Error: %s\n", err.Error())<br/>15&#160;&#160;} <span class="EmpStrong">else</span> {<br/>16&#160;&#160;&#160;&#160;fmt.Printf("Time in seconds since the Epoc: %d\<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;n", parsed.Unix())<br/>17&#160;&#160;}</p>
<p class="example"><a id="ch11ex03"/>From: parseTime.go</p>
<p>The <code>Parse()</code> function is the inverse of the <code>Format()</code> method. It allows you to construct a <code>Time</code> structure from a string, with a specified format.</p>
<p>The format string is the first argument and is in the format discussed in the last section. The example at the start of this section tries parsing two times: first as a 12-hour time with an explicit AM or PM, and then as a 24-hour time. If neither of these works, then it gives up.</p>
<p>You&#8217;ll notice, if you run this example, that the seconds since the epoc is always a large negative number. This is because the date component of <a id="page_180"/>the parsed time will be 0, putting the time about two millennia in the past.</p>
<p>If you want the time to be relative to today, then you need to explicitly set the date part.</p>
<h3 id="ch11lev1sec4">Calculating Elapsed Time</h3>
<p class="pre">&#160;7&#160;&#160;parsed, _ := time.Parse("2/1/2006", "15/6/1982")<br/>&#160;8&#160;&#160;now := time.Now()<br/>&#160;9&#160;&#160;parsedSeconds := parsed.Unix()<br/>10&#160;&#160;fmt.Printf("%d seconds difference\n", now.Unix()-<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;parsedSeconds)<br/>11&#160;&#160;diff := now.Sub(parsed)<br/>12&#160;&#160;fmt.Printf("%s difference\n", diff.String())</p>
<p class="example"><a id="ch11ex04"/>From: diffTime.go</p>
<p>If you have two times in seconds or nanoseconds, then it&#8217;s trivial to work out the difference between them. If they are in calendar format, then it&#8217;s different.</p>
<p>The simplest way of calculating a time difference is to convert both times to UNIX times, and then do the calculation. UNIX time is always in UTC: on UNIX systems, the system clock is set to UTC (or GMT on older systems) and the user-visible time is calculated by adding an offset to this time. This means that changing the time zone of the system will not confuse things like file modification times. It&#8217;s a good idea to adopt the same policy in your own code.</p>
<p>The example at the start of this section shows <a id="page_181"/>two ways of comparing dates. The first converts both to nanoseconds and then does simple subtraction to compare them. The second uses the <code>Sub()</code> method on the <code>Time</code> structure, which returns a <code>Duration</code>. This encapsulates a time interval and can be converted to hours, minutes, seconds, nanoseconds, or a string representation containing all three.</p>
<h3 id="ch11lev1sec5">Receiving Timer Events</h3>
<p class="pre">&#160;6&#160;&#160;time.AfterFunc(2000000000, <span class="EmpStrong">func</span> () {<br/>&#160;7&#160;&#160;&#160;&#160;fmt.Printf("Timer expired\n")<br/>&#160;8&#160;&#160;})<br/>&#160;9&#160;&#160;timer := time.NewTimer(3000000000)<br/>10&#160;&#160;time :=&#160;&#160;&lt;- timer.C<br/>11&#160;&#160;fmt.Printf("Current time: %d nanoseconds\n", time<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;.UnixNano())</p>
<p class="example"><a id="ch11ex05"/>From: timer.go</p>
<p>We&#8217;ve already looked at explicitly spawning goroutines to generate timer events, but the time package also provides some convenience functions for doing this. The <code>Timer</code> structure waits for a fixed length of time, and then either sends a message along its channel, or calls a function, depending on how it was created.</p>
<p>Using timers is usually more efficient than spawning a new goroutine. They are implemented using a heap. A spawned goroutine sleeps for the interval until the next timer is due to run, and then fires all timers that have <a id="page_182"/>expired when it wakes up. This means that you only have one parallel goroutine running, no matter how many timers you use. Spawning a goroutine is quite cheap, but not spawning a goroutine is usually even cheaper.</p>
<p>It&#8217;s not always quite so clear cut. The timer, as currently implemented, uses a mutex to protect the heap, which means that there is the possibility of contention if you are concurrently creating a lot of timers. In practice, however, it&#8217;s always likely to be more efficient to use a timer than implement your own version.</p>
<p>If you create a timer with <code>NewTimer</code>, then it will send the current nanosecond time along the channel created as its <code>C</code> field when it expires. If you call <code>AfterFunc()</code> instead, then the channel will not be used. The function that you pass will be called in its own goroutine when the timer expires.</p>
<p>Timers do not make any real-time guarantees. The timer is guaranteed not to be triggered before the timeout expires, but it may be triggered any time after that, depending on the machine load, the accuracy of the available timers, the operating system&#8217;s scheduler, and various other concerns.</p>
</body>
</html>