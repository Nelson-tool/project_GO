<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>7. Working with Collections</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch07"><a id="page_107"/>7. Working with Collections</h2>
<p>Go, in common with most other languages, provides arrays as a fundamental low-level collection type. It adds slices on top of arrays to provide a safe way of accessing arbitrary memory ranges.</p>
<p>In the standard library, Go also provides a small range of collection types, but there&#8217;s also one more that is part of the language: <em>maps</em>. Other languages call these <em>dictionaries</em>, <em>associative arrays</em>, or (not quite accurately) <em>hash tables</em>. They define a unique set of keys, each of which has one value associated with it.</p>
<h3 id="ch07lev1sec1"><a id="page_108"/>Creating a Map</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;3<br/>&#160;4&#160;&#160;<span class="EmpStrong">type</span> Any <span class="EmpStrong">interface</span> {}<br/>&#160;5<br/>&#160;6&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;7&#160;&#160;&#160;&#160;a := make(<span class="EmpStrong">map</span>[int] string)<br/>&#160;8&#160;&#160;&#160;&#160;b := make(<span class="EmpStrong">map</span>[Any] int)<br/>&#160;9&#160;&#160;&#160;&#160;a[12] = "A string in a <span class="EmpStrong">map</span>"<br/>10&#160;&#160;&#160;&#160;b[12] = 12<br/>11&#160;&#160;&#160;&#160;b["12"] = 13<br/>12&#160;&#160;&#160;&#160;b[12.0] = 14<br/>13&#160;&#160;&#160;&#160;fmt.Printf("%s %d %d\n", a[12], b[12], b["12"])<br/>14&#160;&#160;}</p>
<p class="example"><a id="ch07ex01"/>From: map.go</p>
<p>If you&#8217;ve ever worked on a C project, then you&#8217;ve probably implemented some form of map. The lack of any kind of map data type in the standard library is one of the things that people most often miss when moving from a high-level language to C.</p>
<p>The designers of Go decided to add a map as a built-in type to address this. The map type in Go is similar to the <code>std::</code><span class="EmpStrong">map</span> type in C++. It is defined by the types of its keys and values.</p>
<p>There are no restrictions on the type of the values stored in a map. Keys are a little bit more complicated. Typically, you will want to use either integers or strings as keys in a map. Explicitly stating the type allows the compiler to warn you if you are trying to use the wrong type <a id="page_109"/>as a key.</p>
<p>You can also use an interface type as a map key. This is very flexible, but turns off the compile-time type checking. The compiler will let you use any type that implements the interface as a key, but that doesn&#8217;t mean that it will work.</p>
<p>Key types must have the equality operator defined, and there is no operator overloading in Go, so this restricts you to the built-in types. This includes pointers, so you can use pointer types as map keys. Prior to 1.0, using structures as keys would generate a run-time panic. In Go 1.0, equality is defined on structures recursively, so two structures are equal if their fields are all equal.</p>
<p class="pre">1&#160;&#160;A string in a map 12 13</p>
<p class="example"><a id="ch07ex02"/>Output from: map.go</p>
<p>Note that there is no conversion performed when you use different types as keys. The example from the start of this chapter defines a map from an interface type to integers. It then uses three different representations of the number 12 (integer, string, and floating-point) as keys. All of these set different values. This may come as a surprise if you are used to a language with weak typing.</p>
<p>Maps, like other Go reference types, are created with the <code>make()</code> built-in function. If you try <a id="page_110"/>to create a map with <code>new()</code>, then this will appear to work, but you will get a pointer to an uninitialized reference to map, rather than a reference to a map. The map that this points to will be the nil map, and any attempt to modify it will cause a run-time panic. The following code is valid Go, and so it will compile; it just won&#8217;t work:</p>
<p class="pre-n">c := new(<span class="EmpStrong">map</span>[int] string)<br/>// This will panic at run time.<br/>(*c)[1] = "foo"</p>
<p>The fact that <code>new()</code> returns a pointer while <code>make()</code> returns a reference makes it difficult to make this mistake in practice. It&#8217;s hard to accidentally type <code>(*c)</code> when you mean <code>c</code>, and if you wrote <code>c</code> here then the compiler would reject the code because you&#8217;re trying to use a pointer as a map.</p>
<p>The <code>make()</code> function takes the map type as the first argument. If a second argument is specified, then this is the initial capacity of the map. Most of the time, you can ignore this. Maps will dynamically resize themselves as elements are added. If you are about to add a large (known) number of entries to a map, then you can avoid some resizing overhead by creating a map of the required size initially, but usually it&#8217;s safe to just let the map grow as required.</p>
<h3 id="ch07lev1sec2"><a id="page_111"/>Storing Unordered Groups of Objects</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;3<br/>&#160;4&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;5&#160;&#160;&#160;&#160;set := make(<span class="EmpStrong">map</span>[string] bool)<br/>&#160;6&#160;&#160;&#160;&#160;set["A"] = true<br/>&#160;7&#160;&#160;&#160;&#160;fmt.Printf("%t %t\n", set["A"], set["B"])<br/>&#160;8&#160;&#160;&#160;&#160;// Setting to false does not remove the value<br/>&#160;9&#160;&#160;&#160;&#160;set["A"] = false<br/>10&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> k, v := <span class="EmpStrong">range</span> set {<br/>11&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%s %t\n", k, v)<br/>12&#160;&#160;&#160;&#160;}<br/>13&#160;&#160;&#160;&#160;// Remove the element from the set<br/>14&#160;&#160;&#160;&#160;delete(set,"A")<br/>15&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> k, v := <span class="EmpStrong">range</span> set {<br/>16&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%s %t\n", k, v)<br/>17&#160;&#160;&#160;&#160;}<br/>18&#160;&#160;}</p>
<p class="example"><a id="ch07ex03"/>From: set.go</p>
<p>You can think of a set as a map from objects to boolean values. In Go, that&#8217;s exactly how you would implement one.</p>
<p>This works because of the idea of a <em>zero value</em>, which is essential to a lot of Go patterns. Every Go type has an associated zero value. This is the value that is created by interpreting a block of zero-value bytes that is the same size as the type as an instance of that type.</p>
<p>When you look up a key that is not present in a map, the map returns the zero value. The zero value for a <code>bool</code> is <code>false</code>. You can therefore test <a id="page_112"/>membership in a set by simply checking whether the value for a specific key is true or false.</p>
<p>The example from the start of this section defines a set of strings and shows the one slight complication with this approach. A zero value is returned both when the key does not exist and when the key is associated with the zero value. This is apparent when you iterate over the map. The first loop tells you that the key <code>"A"</code> is associated with the value <code>false</code>.</p>
<p>You can also explicitly remove values from the map, rather than setting them to the zero value, by using the <code>delete()</code> built-in function. This takes a map as the first argument and the key to remove as the second.</p>
<h3 id="ch07lev1sec3">Using Lists</h3>
<p class="pre">&#160;6&#160;&#160;l := list.New()<br/>&#160;7&#160;&#160;l.PushBack(42)<br/>&#160;8&#160;&#160;l.PushBack(main)<br/>&#160;9&#160;&#160;l.PushBack("A string")<br/>10&#160;&#160;<span class="EmpStrong">for</span> e := l.Back() ; e != nil ; e = e.Prev() {<br/>11&#160;&#160;&#160;&#160;fmt.Printf("%v\n", e.Value)<br/>12&#160;&#160;}</p>
<p class="example"><a id="ch07ex04"/>From: list.go</p>
<p>The Go standard library defines a few collections, including lists. The <em>list package</em> contains a good example of how interface types in Go can be composed. Lists are formed from <a id="page_113"/>elements, which wrap some other Go type. This means that you can store anything that you want in a list.</p>
<p>Note that, unlike maps, lists are not built in. This means that you only have one list type, not one list type for every possible element type. You can only pass types as arguments to built-in functions like <code>new()</code> and <code>make()</code>, not to library functions like <code>list.New()</code>. So it is impossible to have a list of a specific type without using type introspection, and if you do that then you still don&#8217;t get compile-time checking.</p>
<p>Lists use the <em>empty interface type</em> for objects stored in list entries. We looked at this in <a href="ch04.html#ch04">Chapter 4</a>, <em><a href="ch04.html#ch04">Common Go Patterns</a></em>. It allows any Go type to be stored, without any checking.</p>
<p>In practice, this lack of explicit type checking is rarely a problem. If you really feel that you need it, then you can define some wrappers that set and get list elements with explicit types and always use them.</p>
<p>In the example at the start of this section, we store three differently typed values in a list: an integer, a string, and a function. This shows the type-agnostic nature of the list in particular, and the empty interface type in general.</p>
<h3 id="ch07lev1sec4"><a id="page_114"/>Defining New Collections</h3>
<p class="pre">&#160;4&#160;&#160;<span class="EmpStrong">type</span> Hashable <span class="EmpStrong">interface</span> {<br/>&#160;5&#160;&#160;&#160;&#160;Hash() int<br/>&#160;6&#160;&#160;&#160;&#160;IsEqual(Hashable) bool<br/>&#160;7&#160;&#160;}<br/>&#160;8&#160;&#160;<span class="EmpStrong">type</span> HashTable <span class="EmpStrong">struct</span> {<br/>&#160;9&#160;&#160;&#160;&#160;table <span class="EmpStrong">map</span>[int] []Hashable<br/>10&#160;&#160;}<br/>11&#160;&#160;<span class="EmpStrong">func</span> (h HashTable) Find(value Hashable) Hashable{<br/>12&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> (h.table == nil) { <span class="EmpStrong">return</span> nil }<br/>13&#160;&#160;&#160;&#160;l := h.table[value.Hash()]<br/>14&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> l == nil { <span class="EmpStrong">return</span> nil }<br/>15&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> _, e := <span class="EmpStrong">range</span>(l) {<br/>16&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> value.IsEqual(e) {<br/>17&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> e<br/>18&#160;&#160;&#160;&#160;&#160;&#160;}<br/>19&#160;&#160;&#160;&#160;}<br/>20&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> nil<br/>21&#160;&#160;}<br/>22&#160;&#160;<span class="EmpStrong">func</span> (h *HashTable) Add(value Hashable) {<br/>23&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> h.Find(value) != nil { <span class="EmpStrong">return</span> }<br/>24&#160;&#160;&#160;&#160;hash := value.Hash()<br/>25&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> (h.table == nil) {<br/>26&#160;&#160;&#160;&#160;&#160;&#160;h.table = make(<span class="EmpStrong">map</span>[int] []Hashable)<br/>27&#160;&#160;&#160;&#160;}<br/>28&#160;&#160;&#160;&#160;l := h.table[hash]<br/>29&#160;&#160;&#160;&#160;h.table[hash] = append(l, value)<br/>30&#160;&#160;}</p>
<p class="example"><a id="ch07ex05"/>From: hashTable.go</p>
<p>If you are designing a new collection, it&#8217;s usually a good idea to be as generic as possible. This means using the empty interface type if you can, and a simple interface if you can&#8217;t.</p>
<p>The example at the start of this section shows a simple hash table implementation, with <a id="page_115"/>secondary chaining. This uses a map from integers to slices and then chains values off the end of each slice. The Go specification does not define how the map is implemented, but in existing implementations it&#8217;s already a hash table, so this is slightly redundant and would not make much sense outside of an example.</p>
<p>For things to go into a hash table, they must be able to provide a hash, and they must define equality. The <code>Hashable</code> interface defines two methods that must be implemented by values going into the hash table.</p>
<p>If you wanted to store some of the Go primitive types in this collection, then you&#8217;d have a problem. Something like a <code>string</code> or an <code>int</code> does not implement these (or any other) methods, so you can&#8217;t pass one to a function that requires its arguments to do so.</p>
<p>Fortunately, there is a simple solution. You can define a new type that uses one of these as the underlying representation and then add methods to that. The example does this for strings, defining a <code>str</code> type that is a string with the required extra methods.</p>
<p class="pre-1">32&#160;&#160;<span class="EmpStrong">type</span> str string<br/>33&#160;&#160;<span class="EmpStrong">func</span> (s str) Hash() int {<br/>34&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> len(s)<br/>35&#160;&#160;}<br/>36&#160;&#160;<span class="EmpStrong">func</span> (s str) IsEqual(other Hashable) bool {<br/>37&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> s == other.(str)<br/>38&#160;&#160;}<br/>39<br/>40&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>41&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> h HashTable<br/>42&#160;&#160;&#160;&#160;h.Add(str("Foo"))<br/>43&#160;&#160;&#160;&#160;h.Add(str("Foo"))<br/>44&#160;&#160;&#160;&#160;h.Add(str("Bar"))<br/>45&#160;&#160;&#160;&#160;h.Add(str("Wibble"))<br/>46&#160;&#160;&#160;&#160;fmt.Printf("%v %v %v\n", h.Find(str("Foo")), h.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Find(str("Bar")), h.Find(str("Wibble")))<br/>47&#160;&#160;}</p>
<p class="example"><a id="page_116"/><a id="ch07ex06"/>From: hashTable.go</p>
</body>
</html>