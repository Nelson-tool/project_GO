<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>9. Goroutines</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch09"><a id="page_131"/>9. Goroutines</h2>
<p>Goroutines are the basic primitive for concurrency in Go and are very easy to create. Go is intended for a world in which the number of available cores keeps increasing, so it encourages a concurrent programming style. The easy creation of goroutines is a key part of that.</p>
<h3 id="ch09lev1sec1">Creating Goroutines</h3>
<p class="pre">&#160;6&#160;&#160;<span class="EmpStrong">go</span> fmt.Printf("Printed in the background\n")<br/>&#160;7&#160;&#160;i := 1<br/>&#160;8&#160;&#160;<span class="EmpStrong">go</span> fmt.Printf("Currently, i is %d\n", i)<br/>&#160;9&#160;&#160;<span class="EmpStrong">go func</span>() {<br/>10&#160;&#160;&#160;&#160;fmt.Printf("i: %d\n", i)<br/>11&#160;&#160;}()<br/>12&#160;&#160;i++<br/>13&#160;&#160;time.Sleep(1000000000)</p>
<p class="example"><a id="ch09ex01"/>From: goroutine.go</p>
<p>You create a new goroutine by prefixing any function call with the keyword <span class="EmpStrong">go</span>. This creates <a id="page_132"/>a new goroutine containing the call frame and schedules it to run.</p>
<p>The newly created goroutine behaves like a thread in other languages. It can access its arguments, any globals, and anything reachable from them.</p>
<p>If you want to do more than just call an existing function, then you can combine the <span class="EmpStrong">go</span> statement with an anonymous function. The third <span class="EmpStrong">go</span> statement in the example shows a common error in writing this kind of code, as you can see from the output.</p>
<p class="pre-1">1&#160;&#160;Printed in the background<br/>2&#160;&#160;Currently, i is 1<br/>3&#160;&#160;i: 2</p>
<p class="example"><a id="ch09ex02"/>Output from: goroutine.go</p>
<p>The goroutine that references the variable <code>i</code> takes it as a parameter. This means that its value is copied into the call frame for the new goroutine. The second goroutine references it indirectly via the closure. This means that it shares a reference to <code>i</code> with the caller. When the caller increments the variable, the change is reflected in the goroutine.</p>
<p>When I ran this example, the third <code>Printf()</code> statement told me that <code>i</code> was 2, but this is not guaranteed. The goroutine may execute immediately, or it may execute before the increment.</p>
<p><a id="page_133"/>The situation is actually slightly more complicated than that. We looked at the Go memory model in <a href="ch01.html#ch01">Chapter 1</a>, <em><a href="ch01.html#ch01">Introducing Go</a></em>. The compiler does not have any constraints on the ordering of memory accesses from a concurrent goroutine, so it is completely free to fold the increment into the initialization. This means that the line written after the goroutine was created may actually run before.</p>
<p>The <code>Sleep()</code> call at the end stops the main goroutine from exiting before the spawned one has had a chance to produce any output. Go does not require all goroutines to exit before the program terminates.</p>
<h3 id="ch09lev1sec2"><a id="page_134"/>Synchronizing Goroutines</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;3&#160;&#160;<span class="EmpStrong">import</span> "sync"<br/>&#160;4<br/>&#160;5&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;6&#160;&#160;&#160;&#160;m := make(<span class="EmpStrong">map</span>[int] string)<br/>&#160;7&#160;&#160;&#160;&#160;m[2] = "First Value"<br/>&#160;8&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> lock sync.Mutex<br/>&#160;9&#160;&#160;&#160;&#160;<span class="EmpStrong">go func</span>() {<br/>10&#160;&#160;&#160;&#160;&#160;&#160;lock.Lock()<br/>11&#160;&#160;&#160;&#160;&#160;&#160;m[2] = "Second Value"<br/>12&#160;&#160;&#160;&#160;&#160;&#160;lock.Unlock()<br/>13&#160;&#160;&#160;&#160;}()<br/>14&#160;&#160;&#160;&#160;lock.Lock()<br/>15&#160;&#160;&#160;&#160;v := m[2]<br/>16&#160;&#160;&#160;&#160;lock.Unlock()<br/>17&#160;&#160;&#160;&#160;fmt.Printf("%s\n", v)<br/>18&#160;&#160;}</p>
<p class="example"><a id="ch09ex03"/>From: mutex.go</p>
<p>As we saw in the last section, it&#8217;s often important to enforce some synchronization between concurrent parts of the program. This is not surprising: if some background task is completely independent of everything else, then it should probably be part of a different program.</p>
<p>The <em>sync package</em> provides mutexes. These are simple locks that can be held by at most one goroutine at a time. Mutexes are an example of the <em>zero initialization pattern</em> that we saw in <a href="ch04.html#ch04">Chapter 4</a>, <em><a href="ch04.html#ch04">Common Go Patterns</a></em>. This means that a mutex with a zero value is treated as <a id="page_135"/>an unlocked mutex and is ready to use. The example at the start of this section shows this: the mutex is used as soon as it is created, with no explicit initialization required.</p>
<div class="note"><hr/>
<p class="title"><a id="ch09note01"/>Note</p>
<p class="notepara">In this chapter, we&#8217;re looking at some low-level synchronization primitives that are similar to the ones that you would expect to find in other languages. Using things like mutexes and condition variables is often not good idiomatic Go. You would often be better served by some of the techniques covered in <a href="ch10.html#ch10">Chapter 10</a>, <em><a href="ch10.html#ch10">Concurrency Design Patterns</a>.</em></p>
<hr/></div>
<p>Mutexes in Go work just as they do in any other language. They provide two methods, <code>Lock()</code> and <code>Unlock()</code>, for acquiring and releasing the mutex.</p>
<p>The example at the start of this section uses a mutex to protect a map. Operations on maps are not atomic, so attempts to modify them concurrently from two goroutines have undefined behavior. This example use a simple lock to protect the map so that the two goroutines can attempt to modify it without any problems. We&#8217;ll look at a better way of implementing a concurrent map in Go in <a href="ch10.html#ch10">Chapter 10</a>, <em><a href="ch10.html#ch10">Concurrency Design Patterns</a></em>.</p>
<p>Note that this approach doesn&#8217;t make any guarantees about which order the two goroutines access the map. Most of the time you run this <a id="page_136"/>example, you will see the first value printed, because the spawned goroutine will not finish starting until after the original has acquired the lock.</p>
<p>It is possible to enforce ordering by moving the <code>lock.Lock()</code> line out of the spawned goroutine. The main goroutine will then block on the second <code>lock.Lock()</code> call until the spawned goroutine releases the lock by calling <code>lock.Unlock()</code> before returning.</p>
<p>This means that Go &#8220;mutexes&#8221; are actually <em>binary semaphores</em>, rather than true mutexes. They do not have an owner, which means that they cannot support recursive use (calling <code>Lock()</code> on the same mutex twice in the same goroutine causes it to deadlock) and that they do not support error checking behavior. These would be very irritating limitations in other languages.</p>
<h3 id="ch09lev1sec3"><a id="page_137"/>Waiting for a Condition</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;3&#160;&#160;<span class="EmpStrong">import</span> "sync"<br/>&#160;4<br/>&#160;5&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;6&#160;&#160;&#160;&#160;m := make(<span class="EmpStrong">map</span>[int] string)<br/>&#160;7&#160;&#160;&#160;&#160;m[2] = "First Value"<br/>&#160;8&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> mutex sync.Mutex<br/>&#160;9&#160;&#160;&#160;&#160;cv := sync.NewCond(&#38;mutex)<br/>10&#160;&#160;&#160;&#160;updateCompleted := false<br/>11&#160;&#160;&#160;&#160;<span class="EmpStrong">go func</span>() {<br/>12&#160;&#160;&#160;&#160;&#160;&#160;cv.L.Lock()<br/>13&#160;&#160;&#160;&#160;&#160;&#160;m[2] = "Second Value"<br/>14&#160;&#160;&#160;&#160;&#160;&#160;updateCompleted = true<br/>15&#160;&#160;&#160;&#160;&#160;&#160;cv.Signal()<br/>16&#160;&#160;&#160;&#160;&#160;&#160;cv.L.Unlock()<br/>17&#160;&#160;&#160;&#160;}()<br/>18&#160;&#160;&#160;&#160;cv.L.Lock()<br/>19&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> !updateCompleted {<br/>20&#160;&#160;&#160;&#160;&#160;&#160;cv.Wait()<br/>21&#160;&#160;&#160;&#160;}<br/>22&#160;&#160;&#160;&#160;v := m[2]<br/>23&#160;&#160;&#160;&#160;cv.L.Unlock()<br/>24&#160;&#160;&#160;&#160;fmt.Printf("%s\n", v)<br/>25&#160;&#160;}</p>
<p class="example"><a id="ch09ex04"/>From: condvar.go</p>
<p>Go provides condition variables, which are similar to their POSIX equivalent. The <span class="romanAlt">condvar.go</span> example extends the example from the last section to ensure that the write from the concurrent goroutine has completed before reading. For this simple use, it would be better to use a wait group, as discussed in the section <a id="page_138"/>Performing Actions in the Background.</p>
<p>A condition variable allows one or more goroutines to sleep until some condition is met. They are typically used in a solution to the <em>producer-consumer problem</em>. It&#8217;s quite unlikely that you will actually want to use them in Go, because channels provide a much better solution to this, but they can be useful when implementing algorithms designed for other systems.</p>
<p>Condition variables have a lock associated with them. The Go implementation allows any type that implements the <code>Locker</code> interface to be used, but in this example we use a mutex. The <code>L</code> field of the condition variable can be used to access this lock directly.</p>
<p>When you call <code>Wait()</code>, the lock is atomically released and the goroutine goes to sleep. If the lock is not held by the calling goroutine, then the call to <code>Wait()</code> will panic. When another goroutine calls either <code>Signal()</code> or <code>Broadcast()</code> on the condition variable, then sleeping goroutines wake up and attempt to reacquire the lock. <code>Signal()</code> wakes just one, while <code>Broadcast()</code> wakes them all.</p>
<p>Typically, you will want to call these functions with the lock held, or there is a chance of wakeup events being lost. This is not required and can be avoided if you know that they will be called later with the lock held.</p>
<p>Condition variables, as their name would imply, <a id="page_139"/>are intended to be used to monitor a condition. In this example, the condition that the <code>cv</code> condition variable is protecting is the state of the <code>updateCompleted</code> variable. If this variable is true, then we say that the condition holds. Conditions do not have to be simple variables; they can also be the result of some computation.</p>
<p>The example shows the common pattern for using a condition variable. The producer acquires the lock, updates the condition (the <code>updateCompleted</code> variable), and then signals the condition variable (<code>cv</code>) before releasing the lock. The consumer acquires the lock, tests the condition, and, if it doesn&#8217;t hold, then it sleeps on the condition variable. It then reacquires the lock when the producer releases it, releases it itself, and continues.</p>
<p>There are two possible execution orders for this example. The original goroutine&#8212;the <code>main()</code> function&#8212;may acquire the lock first. If this happens, then <code>updateCompleted</code> will be <code>false</code>, so it will call <code>Wait()</code>, atomically releasing the lock. At this point, the spawned goroutine will acquire the lock, do its modifications, and then signal the condition variable and release the lock, allowing the original goroutine to continue.</p>
<p>Alternatively, the spawned goroutine will grab the lock first. In this case, the original goroutine will probably block on the <code>Lock()</code> call, although it may not if the spawned goroutine completes its updates first. Either way, it <a id="page_140"/>will not proceed past this line until the other goroutine has released the lock. At this point, <code>updateCompleted</code> will be <code>true</code>, so it won&#8217;t wait and will proceed to completion immediately.</p>
<h3 id="ch09lev1sec4">Performing Thread-Safe Initialization</h3>
<p class="pre">&#160;5&#160;&#160;<span class="EmpStrong">type</span> LazyInit <span class="EmpStrong">struct</span> {<br/>&#160;6&#160;&#160;&#160;&#160;once sync.Once<br/>&#160;7&#160;&#160;&#160;&#160;value int<br/>&#160;8&#160;&#160;}<br/>&#160;9&#160;&#160;<span class="EmpStrong">func</span> (s *LazyInit) Value() int {<br/>10&#160;&#160;&#160;&#160;s.init()<br/>11&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> s.value<br/>12&#160;&#160;}<br/>13&#160;&#160;<span class="EmpStrong">func</span> (s *LazyInit) init() {<br/>14&#160;&#160;&#160;&#160;s.once.Do(<span class="EmpStrong">func</span>() { s.value = 42 })<br/>15&#160;&#160;}<br/>16&#160;&#160;<span class="EmpStrong">func</span> (s *LazyInit) SetValue(v int) {<br/>17&#160;&#160;&#160;&#160;s.value = v<br/>18&#160;&#160;}<br/>19<br/>20&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>21&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> l LazyInit<br/>22&#160;&#160;&#160;&#160;fmt.Printf("%d\n", l.Value())<br/>23&#160;&#160;&#160;&#160;l.SetValue(12)<br/>24&#160;&#160;&#160;&#160;fmt.Printf("%d\n", l.Value())<br/>25&#160;&#160;}</p>
<p class="example"><a id="ch09ex05"/>From: once.go</p>
<p>Most Go structures use the zero initialization pattern, so when you create a structure that uses them, you generally don&#8217;t do explicit initialization. Sometimes, however, you do, <a id="page_141"/>and it&#8217;s often best to support <em>lazy initialization</em> rather than require an explicit call to an initializer.</p>
<p>The example from the start of this section shows a trivial type that encapsulates an integer. This supports the zero initialization pattern, but it has an initial value of 42, rather than zero. To support this, it uses the <code>Once</code> type from the sync package. This is similar to <code>pthread_once()</code> in the POSIX threading API, although it&#8217;s easier to use.</p>
<p>The <code>Once</code> object has a <code>Do()</code> method, which takes a function as an argument. It will run that function exactly once, as you might have guessed from the name. This is thread-safe, so calling <code>Do()</code> twice from different goroutines will still only run it once, and will cause the second caller to block until the first has completed.</p>
<p>In general, this pattern will be more expensive than using a designated initializer. At best, it will require one extra branch to check whether the object has been initialized. A good Go compiler will make this overhead small, but it will still exist.</p>
<h3 id="ch09lev1sec5"><a id="page_142"/>Performing Actions in the Background</h3>
<p class="pre">&#160;7&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;8&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> w sync.WaitGroup<br/>&#160;9&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> _, v := <span class="EmpStrong">range</span> os.Args {<br/>10&#160;&#160;&#160;&#160;&#160;&#160;w.Add(1)<br/>11&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">go func</span>(str string) {<br/>12&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%s\n", strings.ToUpper(str))<br/>13&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;w.Done()<br/>14&#160;&#160;&#160;&#160;&#160;&#160;}(v)<br/>15&#160;&#160;&#160;&#160;}<br/>16&#160;&#160;&#160;&#160;w.Wait()<br/>17&#160;&#160;}</p>
<p class="example"><a id="ch09ex06"/>From: wait.go</p>
<p>Performing some action in the background is one of the most common uses for a goroutine. If you have all of the data required for a calculation, but you don&#8217;t need the result immediately, then you can start it running in the background in a goroutine and then do something else and wait for it to complete when you actually need the result.</p>
<p>The <em>sync package</em> provides <em>wait groups</em> to make this easier. You can implement these yourself with channels quite easily but it&#8217;s convenient to use the preprepared version. If you&#8217;re coming from Java, then you may have used the <code>CountDownLatch</code> class: Go wait groups are used for a similar purpose.</p>
<p>Wait groups are similar to counting semaphores. <a id="page_143"/>You can increment and decrement their value, and block if the value is not zero. There are two typical ways of using wait groups. In both cases, you call <code>Done()</code> from within the background goroutine to indicate that it&#8217;s finished, but you initialize the waiting value in one of two ways.</p>
<p>If you are launching a fixed-number of background goroutines, then you can just call <code>Add()</code> once with the number as the argument. Alternatively, you may be launching a variable number of them. For example, if you are reading input from a channel, then you might want to create a background goroutine for each message that you receive. At the end, you&#8217;d want to make sure that you wait for all of the processing to complete.</p>
<p>The example at the start of this section shows how to use wait groups to implement the latter pattern. This iterates over every argument passed to the program and, in the background, prints the uppercase version of it. If you try removing the last line of this example, you&#8217;ll find that it doesn&#8217;t print any output: the <code>main()</code> function&#8212;and therefore the program&#8212;exits before the first background goroutine has a chance to print any output.</p>
<p>Using the arguments array here is a fairly trivial example, but it shows how you can spawn an arbitrary number of goroutines in the background and wait for them all to finish.</p>
<h3 id="ch09lev1sec6"><a id="page_144"/>Communicating Via Channels</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;3<br/>&#160;4&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;5&#160;&#160;&#160;&#160;m := make(<span class="EmpStrong">map</span>[int] string)<br/>&#160;6&#160;&#160;&#160;&#160;m[2] = "First Value"<br/>&#160;7&#160;&#160;&#160;&#160;c := make(<span class="EmpStrong">chan</span> bool, 1)<br/>&#160;8&#160;&#160;&#160;&#160;<span class="EmpStrong">go func</span>() {<br/>&#160;9&#160;&#160;&#160;&#160;&#160;&#160;m[2] = "Second Value"<br/>10&#160;&#160;&#160;&#160;&#160;&#160;c &lt;- true<br/>11&#160;&#160;&#160;&#160;}()<br/>12&#160;&#160;&#160;&#160;_ = &lt;- c<br/>13&#160;&#160;&#160;&#160;fmt.Printf("%s\n", m[2])<br/>14&#160;&#160;}</p>
<p class="example"><a id="ch09ex07"/>From: chan.go</p>
<p>Creating parallel subprograms cheaply is useful, but the real strength of Go comes from the ease with which these detached goroutines can communicate. So far this chapter has looked at the primitive synchronization operations that you&#8217;d expect to find in any vaguely modern language. Hopefully, you will never need to use these in Go programs.</p>
<p>Go provides <em>channels</em>, based on Hoare&#8217;s <em>Communicating Sequential Processes</em> (<em>CSP)</em> formalism. A channel is quite like a UNIX pipe: you can put data down one end and get it out at the other. It supports buffering, with a configurable buffer size. Unlike pipes, channels are typed. When you create a channel, you specify the type of values that will be passed along it. Of course, you can use the empty <a id="page_145"/>interface type if you want to be able to pass values of any type and detect the type at the receiving end.</p>
<p>Channels encourage a style of programming that scales easily without increasing debugging complexity. All of the techniques that we&#8217;ll look at in <a href="ch10.html#ch10">Chapter 10</a>, <em><a href="ch10.html#ch10">Concurrency Design Patterns</a></em>, involve channels. Many of them can be implemented in other languages using mutexes, condition variables, and so on, but most of the time this involves implementing channels on top of these lower-level primitives.</p>
<p>You can also replace the lower-level synchronization primitives with channels. The example at the start of this section shows how to replace explicit synchronization via condition variables with implicit synchronization via a channel. This example is equivalent to the one from the last section, but is much simpler.</p>
<div class="note"><hr/>
<p class="title"><a id="ch09note02"/>Note</p>
<p class="notepara">Most of the examples in this chapter are doing a very small amount of work in a spawned goroutine. It is almost certainly more expensive to set up the synchronization primitives and spawn the concurrent goroutine than it would be to just do the work in the caller. The point of these examples is to demonstrate the use of synchronization mechanisms, not to encourage you to do trivial amounts of work in parallel.</p>
<hr/></div>
<p>This example starts by creating a channel. As <a id="page_146"/>with maps and slices, channels are created with the <code>make()</code> built-in function. The first argument is a channel type, and the second is the size of the buffer. In this example, we just want a single element buffered, because we&#8217;re only ever sending one value over the channel. We use <code>bool</code> as the type for the channel, although any type would be fine because we&#8217;re not actually using the result.</p>
<p>In the spawned goroutine, we send the value <code>true</code> through the channel. The caller tries to read a value from the channel. This will block until a value is sent. In this simple example, we&#8217;re just discarding the received value.</p>
<p>For clarity, I&#8217;ve assigned the value that we read from the channel to the blank identifier. In Go, receive operations are expressions. The <code>&lt;- c</code> part evaluates to the first value received on channel <code>c</code>. This can be either stored somewhere, passed as a function argument, or ignored. You can, for example, write <code>someFunction(&lt;-c)</code> to block until a value is received on the channel and then call <code>someFunction()</code> with this value as the argument.</p>
<p>This is about the simplest possible use for a channel. It serves to illustrate the fact that channels provide simple solutions to some of the problems that you&#8217;d typically solve with mutexes or condition variables in other languages.</p>
<p>Channels are not just a replacement for condition variables; they allow a flexible <a id="page_147"/>message-passing design for concurrent programs. We&#8217;ll look at several more complex examples of their use in the rest of the book.</p>
<p>If you&#8217;re coming from Erlang, then you may find this construct quite familiar. There are some important differences. Erlang uses actor-model concurrency but uses CSP-derived syntax for sending and receiving messages. Go uses CSP, but with its own syntax. The important difference between Erlang&#8217;s Actor model and CSP is the existence of channels. In Erlang, you send messages to process identifiers. In Go, you send them to channels, which are a slightly higher level of abstraction.</p>
<p>A message sent to a Go channel may be received by any goroutine, including the one that originally sent it. Two messages sent to a single channel may be handled by different goroutines. In contrast, a message sent to an Erlang process is always handled by that process. It&#8217;s trivial to implement either of these models on top of the other. You can implement Erlang-style communication by simply creating a channel for each goroutine that you spawn and sharing the sending end but keeping the receiving end private. You can implement channels in Erlang by either using an indirection layer, where one process forwards messages to one or more others, or by tagging messages that you send with a channel identifier to allow them to be sorted at the final receiving end.</p>
<h3 id="ch09lev1sec7"><a id="page_148"/>Using Multiple Channels</h3>
<p class="pre">27&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>28&#160;&#160;&#160;&#160;abort := make(<span class="EmpStrong">chan</span> bool)<br/>29&#160;&#160;&#160;&#160;count := make(<span class="EmpStrong">chan</span> int)<br/>30&#160;&#160;&#160;&#160;<span class="EmpStrong">go</span> cancel(abort)<br/>31&#160;&#160;&#160;&#160;<span class="EmpStrong">go</span> countDown(count)<br/>32&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> {<br/>33&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">select</span> {<br/>34&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> i := &lt;- count:<br/>35&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> 0 == i {<br/>36&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;selfDestruct()<br/>37&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span><br/>38&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>39&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%d seconds remaining\n", i)<br/>40&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> a := &lt;- abort:<br/>41&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> a {<br/>42&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Self destruct aborted\n")<br/>43&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;} <span class="EmpStrong">else</span> {<br/>44&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;selfDestruct()<br/>45&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>46&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span><br/>47&#160;&#160;&#160;&#160;&#160;&#160;}<br/>48&#160;&#160;&#160;&#160;}<br/>49&#160;&#160;}</p>
<p class="example"><a id="ch09ex08"/>From: selfDestruct.go</p>
<p>Quite often, you want to be able to receive input from one of a small group of goroutines. This is not possible with the normal receive statement, because it blocks when attempting to read from the channel.</p>
<p>The <span class="EmpStrong">select</span> statement is similar to a <span class="EmpStrong">switch</span> statement, but it selects based on the availability of communication channels rather than on a truth value. The <span class="EmpStrong">select</span> statement will pick one <a id="page_149"/>and perform the relevant communication, which can be a send or a receive operation.</p>
<p>You can also implement a non-blocking receive with the <span class="EmpStrong">select</span> statement. If there is a <span class="EmpStrong">default</span><code>:</code> clause, then that will be executed if none of the channels in case statements are ready; otherwise it will block until one becomes ready.</p>
<p class="pre-1">&#160;5&#160;&#160;<span class="EmpStrong">func</span> cancel(abort <span class="EmpStrong">chan</span> bool) {<br/>&#160;6&#160;&#160;&#160;&#160;fmt.Printf("This program will self destruct, do<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;you wish to cancel?\n")<br/>&#160;7&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> r int<br/>&#160;8&#160;&#160;&#160;&#160;fmt.Scanf("%c", &#38;r)<br/>&#160;9&#160;&#160;&#160;&#160;<span class="EmpStrong">switch</span> r {<br/>10&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">default</span>: abort &lt;- false<br/>11&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> 'y': abort &lt;- true<br/>12&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> 'Y': abort &lt;- true<br/>13&#160;&#160;&#160;&#160;}<br/>14&#160;&#160;}<br/>15<br/>16&#160;&#160;<span class="EmpStrong">func</span> countDown(count <span class="EmpStrong">chan</span> int) {<br/>17&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i := 10 ; i &gt;= 0 ; i-- {<br/>18&#160;&#160;&#160;&#160;&#160;&#160;count &lt;- i<br/>19&#160;&#160;&#160;&#160;&#160;&#160;time.Sleep(1000000000)<br/>20&#160;&#160;&#160;&#160;}<br/>21&#160;&#160;}</p>
<p class="example"><a id="ch09ex09"/>From: selfDestruct.go</p>
<p>The <span class="romanAlt">selfDestruct.go</span> example uses a <span class="EmpStrong">select</span> statement to receive input from one of two channels. One counts down from ten to zero, once per second, while the other sends a boolean value based on user input. If the timer reaches <a id="page_150"/>zero, or the user actively chooses not to cancel, then this example calls the <code>selfDestruct()</code> function. If the user cancels, then it exits normally.</p>
<p>This same pattern can be employed in any situation where you have multiple possible inputs from channels but don&#8217;t know which one is likely to have data first. In this example, one channel comes from the user, so it may contain data immediately, never, or some time between the two. Channels from the network also fall into this category.</p>
<p>A more interesting case for this pattern is when you have steps of a parallel computation taking different amounts of time. It lets you receive partial responses in the order in which they are ready and then start the next phase of computation immediately.</p>
</body>
</html>