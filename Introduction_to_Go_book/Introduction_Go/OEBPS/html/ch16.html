<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>16. Distributing Go Code</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch16"><a id="page_233"/>16. Distributing Go Code</h2>
<p>After you&#8217;ve written some Go code, there is a good chance that you are going to want other people to be able to use it. Because Go is statically compiled, you can distribute binary packages just as you would distribute code written in C, or any other statically compiled language.</p>
<p class="pre-1">1&#160;&#160;$ otool -L 6.out<br/>2&#160;&#160;6.out:<br/>3&#160;&#160;&#160;&#160;/usr/lib/libSystem.B.dylib</p>
<p class="example"><a id="ch16ex01"/>Output from: otool</p>
<p>Programs compiled by Gc are statically linked, so you can just distribute the output from <span class="romanAlt">6l</span> without worrying about any other libraries. If you are distributing code&#8212;especially packages&#8212;in <a id="page_234"/>source form, then Go provides a few helper utilities to make your life a bit easier.</p>
<h3 id="ch16lev1sec1">Installing Third-Party Packages</h3>
<p class="pre">0&#160;&#160;$ go get github.com/dustin/gomemcached<br/>1&#160;&#160;$ go install github.com/dustin/gomemcached<br/>2&#160;&#160;$ ls ~/go/src/pkg/github.com/dustin/gomemcached/<br/>3&#160;&#160;README.markdown&#160;&#160;&#160;&#160;&#160;&#160;client<br/>4&#160;&#160;gocache&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;mc_constants.go<br/>5&#160;&#160;mc_constants_test.go server<br/>6&#160;&#160;$ ls ~/go/pkg/darwin_amd64/github.com/dustin/<br/>7&#160;&#160;gomemcached.a</p>
<p>Go packages, like Go executables, can be distributed in binary format. As with binary executables, these are limited to one architecture and one platform, so it&#8217;s not the recommended distribution mechanism.</p>
<p>The <span class="romanAlt">go</span> command provides a very easy-to-use mechanism for installing Go packages from source. Typically, you will use it in two stages. The <span class="romanAlt">go get</span> command will fetch the code from the remote repository. Go knows about several specific code locations, including Google Code and GitHub. For others, you can specify a URL with the revision control system name appended, such as <span class="romanAlt">example.com/my/project.hg</span> to fetch from a mercurial repository. The <span class="romanAlt">go install</span> command then builds and installs it.</p>
<p>The sources will be put in the <span class="romanAlt">src/pkg</span> directory <a id="page_235"/>in your Go installation and the compiled binary in the <span class="romanAlt">pkg</span> directory, in a subdirectory corresponding to your architecture.</p>
<p>The URL at the start of this section is for a package providing a memcached implementation for Go. If you want to use this package, then you should specify the entire remote path in the import directive, like this:</p>
<p class="pre-n"><span class="EmpStrong">import</span> mc "github.com/dustin/gomemcached/<br/>&#160;&#160;&#160;&#160;client"</p>
<p>This allows multiple packages with the same name to coexist, as long as they have different URLs.</p>
<p>There are lots of other packages available beyond the standard library, although, as with any other language, the quality varies considerably. You can find a list of most of them on the Go dashboard: <a href="http://godashboard.appspot.com/package">http://godashboard.appspot.com/package</a></p>
<h3 id="ch16lev1sec2"><a id="page_236"/>Creating Packages</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> eg<br/>&#160;2<br/>&#160;3&#160;&#160;// An example <span class="EmpStrong">interface</span> in a <span class="EmpStrong">package</span><br/>&#160;4&#160;&#160;<span class="EmpStrong">type</span> Example <span class="EmpStrong">interface</span> {<br/>&#160;5&#160;&#160;&#160;&#160;// Returns the name of this <span class="EmpStrong">type</span><br/>&#160;6&#160;&#160;&#160;&#160;Name() string<br/>&#160;7&#160;&#160;&#160;&#160;// Unique identifier <span class="EmpStrong">for</span> the <span class="EmpStrong">type</span><br/>&#160;8&#160;&#160;&#160;&#160;id() uint32<br/>&#160;9&#160;&#160;}<br/>10<br/>11&#160;&#160;// Creates a new value implementing<br/>12&#160;&#160;// the Example <span class="EmpStrong">interface</span><br/>13&#160;&#160;<span class="EmpStrong">func</span> NewExample() Example {<br/>14&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> new(concreteType)<br/>15&#160;&#160;}</p>
<p class="example"><a id="ch16ex02"/>From: pkg/src/eg/types.go</p>
<p>We&#8217;ve created lots of packages already in the examples. Or, more accurately, we&#8217;ve created one package&#8212;called main&#8212;a lot of times. If you look in the <span class="romanAlt">pkg</span> directory in your Go installation, then you will find one <span class="romanAlt">.a</span> file for each package that you have installed.</p>
<p>A <span class="romanAlt">.a</span> file is an archive&#8212;a static library. It contains the output from the compiler. The Go compiler, unlike a C compiler, emits quite a lot of metadata in the resulting binary, including the set of exported functions and types.</p>
<p>Small packages, including a lot of the standard library packages, are compiled from single source files. Others may be compiled from more than one. If you are compiling multiple files into a <a id="page_237"/>single package, then you must pass them to Gc as a single invocation. This is required because individual files in a package may have mutual dependencies, which can only be resolved by considering their source files in combination.</p>
<p>The <span class="romanAlt">eg</span> example package shows this. It is a trivial package containing two files. If you try to compile either in isolation, then you will get errors. The <span class="romanAlt">pkg/src/eg/concrete.go</span> file refers to an interface that is not defined in that file; the <span class="romanAlt">pkg/src/eg/types.go</span> file refers to a structure that is defined elsewhere.</p>
<p class="pre-1">&#160;1&#160;&#160;<span class="EmpStrong">package</span> eg<br/>&#160;2<br/>&#160;3&#160;&#160;<span class="EmpStrong">type</span> concreteType <span class="EmpStrong">struct</span> {}<br/>&#160;4&#160;&#160;<span class="EmpStrong">const</span> (<br/>&#160;5&#160;&#160;&#160;&#160;concreteTypeId uint32 = 0<br/>&#160;6&#160;&#160;)<br/>&#160;7<br/>&#160;8&#160;&#160;<span class="EmpStrong">func</span> (s concreteType) Name() string {<br/>&#160;9&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> "Concrete <span class="EmpStrong">type</span>"<br/>10&#160;&#160;}<br/>11&#160;&#160;<span class="EmpStrong">func</span> (s concreteType) id() uint32 {<br/>12&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> concreteTypeId<br/>13&#160;&#160;}<br/>14&#160;&#160;<span class="EmpStrong">func</span> (s concreteType) isEqual(o Example) bool {<br/>15&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> concreteTypeId == o.id()<br/>16&#160;&#160;}</p>
<p class="example"><a id="ch16ex03"/>From: pkg/src/eg/concrete.go</p>
<p>Source files within the same package may refer to each other&#8217;s private variables and types. There is no such thing as a file-local variable in <a id="page_238"/>Go. Source files are just a convenience for the programmer; they do not have any significance to the language. Unlike C, there is no <code>extern</code> directive in Go, telling the compiler that a symbol that it can&#8217;t see really does exist. The Go compiler must be able to find all symbols that it wants to refer to, either in source files or packages.</p>
<p>Most of the examples so far have been self contained, so we haven&#8217;t spent much time looking at Go&#8217;s visibility rules. Other languages have a set of keywords describing the visibility of various symbols. Go uses a simpler approach: anything that starts with a capital letter<sup><a id="ch16fn01" href="footnotes.html#ch16fn01a">1</a></sup> is public, and so can be accessed from another package. Anything else is private, meaning that it may only be accessed from the same package.</p>
<p>To build the package, you need to use the <span class="romanAlt">go build</span> and <span class="romanAlt">go install</span> tools. The build step is actually optional: if you omit it then <span class="romanAlt">go install</span> will run it implicitly. Before running either command, you need to make sure that Go can find your source files, and that subsequent compilations will be able to find the generated package. This is controlled through the <span class="romanAlt">GOPATH</span> environment variable. This contains a list of paths that Go will use, in addition to the install location for the main Go environment.</p>
<p>Go packages must conform to the same layout <a id="page_239"/>as the main Go tree. The directory that you add to the <span class="romanAlt">GOPATH</span> should contain a <span class="romanAlt">src</span> directory, which should contain one subdirectory for each package. When you run <span class="romanAlt">go install</span>, it will create a <span class="romanAlt">pkg</span> directory if one doesn&#8217;t already exist and will install the package there. You can then import it just as you would any other package.</p>
<p class="pre-1">1&#160;&#160;$ <span class="EmpStrong">export</span> GOPATH=<span class="EmpStrong">'pwd'</span><br/>2&#160;&#160;$ ls<br/>3&#160;&#160;src<br/>4&#160;&#160;$ go build eg<br/>5&#160;&#160;$ go install eg<br/>6&#160;&#160;$ ls<br/>7&#160;&#160;pkg src<br/>8&#160;&#160;$ file pkg/darwin_amd64/eg.a<br/>9&#160;&#160;pkg/darwin_amd64/eg.a: current ar archive</p>
<p class="example"><a id="ch16ex04"/>Output from: gobuild</p>
<h3 id="ch16lev1sec3"><a id="page_240"/>Documenting Your Code</h3>
<p class="pre">&#160;0&#160;&#160;$ go doc eg<br/>&#160;1&#160;&#160;PACKAGE<br/>&#160;2<br/>&#160;3&#160;&#160;package eg<br/>&#160;4&#160;&#160;import <span class="EmpItalic">"eg"</span><br/>&#160;5<br/>&#160;6&#160;&#160;TYPES<br/>&#160;7<br/>&#160;8&#160;&#160;type Example interface {<br/>&#160;9&#160;&#160;&#160;&#160;&#160;&#160;// Returns the name of this type<br/>10&#160;&#160;&#160;&#160;&#160;&#160;Name() string<br/>11&#160;&#160;&#160;&#160;&#160;&#160;// contains filtered or unexported methods<br/>12&#160;&#160;}<br/>13&#160;&#160;An example interface in a package<br/>14<br/>15&#160;&#160;func NewExample() Example<br/>16&#160;&#160;&#160;&#160;&#160;&#160;Creates a new value implementing<br/>17&#160;&#160;the Example interface</p>
<p>Go does not have header files to help separate interface and implementation. This separation is imposed by the language, and anyone reading the source can easily see which symbols will be exported and which are kept private.</p>
<p>Having to read the source code for a package to understand how it works is not ideal, and shouldn&#8217;t be encouraged. The <span class="romanAlt">go doc</span> utility reads all of the source files for a package, extracts all comments that appear above public declarations, and presents them to the user.</p>
<p>Persuading developers to write documentation is one of the hardest tasks in programming, so <a id="page_241"/><span class="romanAlt">godoc</span> is intended to be trivial to use. There is no special syntax for using it: it extracts any comment that appears above a declaration.</p>
<p>Hopefully, by the time you&#8217;ve read this far, you&#8217;ve looked at the package documentation on the Go web site. If so, then you&#8217;ve already seen the output from <code>godoc</code>. In fact, you&#8217;ve used the tool directly. When run with the <span class="romanAlt">-http</span> flag, it not only generates HTML, it also runs as a web server publishing the documentation.</p>
<p>You can specify the <span class="romanAlt">-src</span> flag to generate internal documentation. This is less useful because people using the internal interfaces are probably looking at the source files, but the output from <span class="romanAlt">godoc</span> can be easier to navigate.</p>
<h3 id="ch16lev1sec4">Staying Up to Date</h3>
<p class="pre">&#160;0&#160;&#160;$ go tool fix -diff trimStrings.go<br/>&#160;1&#160;&#160;diff trimStrings.go fixed/trimStrings.go<br/>&#160;2&#160;&#160;@@ -6,7 +6,7 @@<br/>&#160;3&#160;&#160;&#160;func main() {<br/>&#160;4&#160;&#160;&#160;&#160;str := <span class="EmpItalic">"\tThis is a string \n"</span><br/>&#160;5&#160;&#160;&#160;&#160;str = strings.Trim(str, <span class="EmpItalic">" \t\n\r"</span>)<br/>&#160;6&#160;&#160;- words := strings.Split(str, " ", -1)<br/>&#160;7&#160;&#160;+ words := strings.Split(str, " ")<br/>&#160;8&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> _, word := range words {<br/>&#160;9&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf(<span class="EmpItalic">"%s\n"</span>, word)<br/>10&#160;&#160;&#160;&#160;}<br/>11&#160;&#160;$ go tool fix trimStrings.go<br/>12&#160;&#160;trimStrings.go: fixed stringssplit</p>
<p><a id="page_242"/>The Go language and libraries are constantly evolving. It would be quite frustrating to have to keep rewriting a large Go application to prevent it from breaking with newer versions of the language. Fortunately, this is not required: the <span class="romanAlt">fix</span> tool will do it for you.</p>
<p>Since I started writing this book, the <code>strings.Split()</code> function that I used in the <span class="romanAlt">trimStrings.go</span> example in <a href="ch06.html#ch06">Chapter 6</a>, <em><a href="ch06.html#ch06">Manipulating Strings</a></em>, went from taking three arguments to taking two, so I needed to modify it. The example at the start of this section shows how I did it.</p>
<p>I never entirely trust automatic code rewriting tools, so I chose to run <span class="romanAlt">fix</span> with the <span class="romanAlt">-diff</span> option first. This shows the changes that it will make so that you can check them for sanity. This change looked sensible, so I ran the tool again and it modified the example.</p>
<p>If you run <span class="romanAlt">go tool fix -help</span> then it will list all of the modifications that it can make. You may find that you don&#8217;t want to make all of these changes and you can use the <span class="romanAlt">-r</span> option to restrict it to a list of only some of them.</p>
</body>
</html>