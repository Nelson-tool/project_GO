<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>2. A Go Primer</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch02"><a id="page_21"/>2. A Go Primer</h2>
<p>One of the goals of Go was a consistent and unambiguous syntax. This makes it easy for tools to examine Go programs, and also makes it easy to learn. Unhelpful compiler errors make it difficult to learn a language, as anyone who has made a typo in C++ code using templates will know.</p>
<p>In C, for example, function and global variable declarations have almost the same syntax. This means that the compiler can&#8217;t easily tell which one you meant if you make an error. It gives you helpful error messages like &#8220;expected ;&#8221; on a line where you don&#8217;t think a semicolon is expected at all.</p>
<p>The Go grammar was designed to make it possible for the compiler to tell you more accurately what you did wrong. It was also designed to avoid the need to state something that can be easily inferred. For example, if you create a variable and set its value to 42, the <a id="page_22"/>compiler could probably guess that this variable should be an integer, without it being explicitly stated. If you initialize it with a function call, then the compiler can definitely tell that the type should be whatever the function returned. This was the same problem that C++ 2011 solves with the <code>auto</code> type.</p>
<p>Go adopts JavaScript&#8217;s idea of <em>semicolon insertion</em>, and takes it a step further. Any line that can be interpreted as a complete statement has a semicolon implicitly inserted at the end by the parser.<sup><a id="ch02fn01" href="footnotes.html#ch02fn01a">1</a></sup> This means that Go programs can freely omit semicolons as statement terminators. This adds some constraints, for example enforcing a brace style where open braces are at the end of the line at the start of flow-control statements, rather than on their own. If you happen to be a human, this is unfortunate, because it means that you can&#8217;t use the highly optimized symmetry recognition paths, which evolution has spent the last million or so years optimizing in your visual cortex, for recognizing code blocks.</p>
<p>This chapter contains an overview of Go syntax. This is not a complete reference. Some aspects are covered in later chapters. In particular, all of the concurrency-related aspects of Go are covered in <a href="ch09.html#ch09">Chapter 9</a>, <em><a href="ch09.html#ch09">Goroutines</a></em>.</p>
<h3 id="ch02lev1sec1"><a id="page_23"/>The Structure of a Go Source File</h3>
<p class="pre">1&#160;&#160;<span class="EmpStrong">package</span> main<br/>2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>3<br/>4&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>5&#160;&#160;&#160;&#160;fmt.Printf("Hello World!\n")<br/>6&#160;&#160;}</p>
<p class="example"><a id="ch02ex01"/>From: hello.go</p>
<p>A Go source file consists of three parts. The first is a <span class="EmpStrong">package</span> statement. Go code is arranged in packages, which fill the r&#244;les of both libraries and header files in C. The package in this example is called <code>main</code>, which is special. Every program must contain a <code>main</code> package, which contains a <code>main()</code> function, which is the program entry point.</p>
<p>The next section specifies the packages that this file uses and how they should be imported. In this example, we&#8217;re importing the <code>fmt</code> package.</p>
<p>Once the <code>fmt</code> package has been imported, any of its exported types, variables, constants, and functions can be used, prefixed by the name of the package. In this simple example, we&#8217;re calling <code>Printf()</code>, a function similar to C&#8217;s <code>printf</code>, to print &#8220;Hello World!&#8221; in the terminal.</p> 
<p>Although Go uses static compilation, it&#8217;s important to realize that <span class="EmpStrong">import</span> statements are much closer to Java or Python import <a id="page_24"/>directives than to C inclusions. They do not include source code in the current compilation unit. Unlike Java and Python packages, Go packages are imported when the code is linked, rather than when it is run. This ensures that a Go application will not fail because of a missing package on the deployment system, at the cost of increasing the size of the executable. Packages in Go are more important than in languages like Java, because Go only provides access control at the package level, while Java provides it at the class level.</p>
<p>When you compile a package (from one or more <span class="romanAlt">.go</span> files) with the <span class="romanAlt">Gc</span> compiler, you get an object code file for the package. This includes a metadata section that describes the types and functions that the package exports. It also contains a list of the packages that this package imports.</p>
<p>The input to the <span class="romanAlt">6l</span> linker is always a <span class="romanAlt">.6</span> file for the <code>main</code> package. This file contains references to every package that the <code>main</code> package imports, which may in turn reference further packages. The linker then combines them all.</p>
<p>This eliminates one of the most irritating problems with building complex C programs: you include a header, and then have to work out which library provided it and add the relevant linker flags. With Go, if a package compiles, it will link. You don&#8217;t have to provide any extra flags to the linker to tell it to link things that <a id="page_25"/>you&#8217;ve referenced via <span class="EmpStrong">import</span> directives.</p>
<p>The remainder of a Go file contains declarations of types, variables, and functions. We&#8217;ll explore that for the rest of this chapter.</p>
<p>You may find that you have two packages that you want to import that have the same name. This would cause problems in Go. The <span class="romanAlt">badStyleImport.go</span> example is functionally equivalent to the example at the start of this section but renames the <code>fmt</code> package, calling it <code>format</code>. Renaming a package when you import it is usually a bad idea, because it makes your code harder for people to read. You should only ever use it when you explicitly need to disambiguate two packages with the same name.</p>
<p class="pre-1">0&#160;&#160;<span class="EmpStrong">package</span> main<br/>1&#160;&#160;<span class="EmpStrong">import</span> format "fmt"<br/>2<br/>3&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>4&#160;&#160;&#160;&#160;format.Printf("Hello World!\n")<br/>5&#160;&#160;}</p>
<p class="example"><a id="ch02ex02"/>From: badStyleImport.go</p>
<h3 id="ch02lev1sec2"><a id="page_26"/>Declaring Variables</h3>
<p class="pre">4&#160;&#160;<span class="EmpStrong">var</span> i int<br/>5&#160;&#160;<span class="EmpStrong">var</span> &#920; float32<br/>6&#160;&#160;<span class="EmpStrong">var</span> explicitly, typed, pointers *complex128<br/>7&#160;&#160;int_pointer := &#38;i<br/>8&#160;&#160;another_int_pointer := new(int)<br/>9&#160;&#160;generic_channel := make(<span class="EmpStrong">chan interface</span>{})</p>
<p class="example"><a id="ch02ex03"/>From: variables.go</p>
<p>Variables are declared with the <span class="EmpStrong">var</span> keyword, followed by the variable name, and finally by the type. The existence of a specific keyword for variable declarations makes it easy to differentiate them from other types of statements.</p>
<p>Writing the type at the end looks weird to people familiar with C-family languages, but it makes sense when you read the code. A (typed) variable declaration is an instruction saying, for example, &#8220;declare the variable foo to have the type int.&#8221;</p>
<p>One of the variables declared at the start of this section uses &#952; (theta) as a variable name. Go permits identifiers to start with any symbols that Unicode classes as letters. This can sometimes be very useful, such as if variable names are mathematical quantities. Don&#8217;t abuse it, though: the person maintaining your code will not thank you if you use characters that he can&#8217;t type on his keyboard for frequently used variables.</p>
<p>A declaration statement may declare multiple <a id="page_27"/>variables, but they all have the same type. In C, some may have the type that is written at the start of the declaration, some may be pointers to that type, some may be pointers to pointers to that type, and so on. The form used by Go is far less prone to ambiguity.</p>
<p>You will rarely use the long form of declarations. One of the key ideas in writing good code is the <em>principle of minimum scope</em>. This means that the scope of a variable&#8212;the lexical region where it is valid&#8212;should be as small as possible for the variable&#8217;s lifetime. One corollary of this is that variables should be declared immediately before their first use and initialized as part of their declaration.</p>
<p>Go provides a shorthand syntax, the <code>:=</code> initialization operator, which does this. Using this notation, you can declare and initialize a variable in a single statement. More importantly, you avoid the need to declare a type for the variable: the type of the variable is the type of the expression used to initialize it.</p>
<p>The example at the start of this section shows both kinds of declaration. It also introduces Go&#8217;s syntax for pointers. The variable <code>int_pointer</code> is initialized using the <em>address-of operator (<code>&#38;</code>)</em>. This should be familiar to C programmers: it returns the address in memory of an object. The returned value, however, is more similar to a Java reference than a C pointer. You can&#8217;t perform arithmetic using Go pointers, <a id="page_28"/>nor use them interchangeably with arrays. As with Java references, you can pass Go pointers around without having to worry about when the underlying object will be deallocated. It will automatically be freed when the last reference is destroyed. Unlike Java references, you can make pointers to primitive types, not just to structures (Go&#8217;s equivalent of objects).</p>
<p>In this example, you could return <code>int_pointer</code> from this function without any problems. This may seem strange to C programmers, because it points to a variable declared locally. The Go compiler will try to allocate <code>i</code> on the stack, but that&#8217;s just an implementation detail. If its address is taken and it is returned from the function then it will be allocated on the heap instead.</p>
<p>This example creates another integer pointer, in a different way. The <code>new()</code> built-in function creates a new integer and returns a pointer to it. This is semantically equivalent to declaring an integer variable and then taking its address. Neither guarantees how the underlying storage will be allocated. You can pass any type to <code>new()</code>, but it is not the standard way of allocating everything.</p>
<p>Go includes three special types, which we&#8217;ll look at in a lot more detail later in this book: <em>slices</em>, <em>maps</em>, and <em>channels</em>. These are <em>reference types</em>, meaning that you always access them via a reference. If you assign one map-typed variable <a id="page_29"/>to another, then you will have two variables referring to the same map. In contrast, if you assign one integer-typed variable to another, then you will have two variables with the same value, but modifying one will not affect the other.</p>
<p>Instances of reference types in Go are created with the <code>make()</code> built-in function. This is similar to <code>new()</code>, but also performs initialization of the built-in types. Values returned by <code>new()</code> are simply zeroed. They are not guaranteed to be immediately useful, although good style suggests that they should be.</p>
<h3 id="ch02lev1sec3">Declaring Functions</h3>
<p class="pre">&#160;4&#160;&#160;<span class="EmpStrong">func</span> printf(str string, args ...<span class="EmpStrong">interface</span>{}) (int<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;, error) {<br/>&#160;5&#160;&#160;&#160;&#160;_, err := fmt.Printf(str, args...)<br/>&#160;6&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> len(args), err<br/>&#160;7&#160;&#160;}<br/>&#160;8<br/>&#160;9&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>10&#160;&#160;&#160;&#160;count := 1<br/>11&#160;&#160;&#160;&#160;closure := <span class="EmpStrong">func</span>(msg string) {<br/>12&#160;&#160;&#160;&#160;&#160;&#160;printf("%d %s\n", count, msg)<br/>13&#160;&#160;&#160;&#160;&#160;&#160;count++<br/>14&#160;&#160;&#160;&#160;}<br/>15&#160;&#160;&#160;&#160;closure("A Message")<br/>16&#160;&#160;&#160;&#160;closure("Another Message")<br/>17&#160;&#160;}</p>
<p class="example"><a id="ch02ex04"/>From: functions.go</p>
<p><a id="page_30"/>Functions in Go are declared using the <span class="EmpStrong">func</span> keyword. As with variable declarations, the return type goes at the end. This can be a single value, or a list of values. The <code>printf()</code> function in the example shows several important features of Go. This is a <em>variadic function</em>, which returns multiple values: an integer and an error. The integer is the number of variadic arguments passed to it, and the error code is one of the values returned from the <code>Printf()</code> function from the <em>fmt package</em>.</p>
<p>Note the syntax for calling functions that return multiple values. The return values must either all be ignored, or all assigned to variables. The <em>blank identifier</em>, <code>_</code>, can be used for values that you wish to discard.</p>
<p>Variadic functions in Go are particularly interesting. In C, a variadic function call just pushes extra parameters onto the stack, and the callee has to know how to pop them off. In Go, all variadic parameters are delivered as a <em>slice</em> (see <a href="ch05.html#ch05">Chapter 5</a>, <em><a href="ch05.html#ch05">Arrays and Slices</a></em>; for now you can think of a slice as being like an array). The variadic parameters must all be of the same type, although you can use the <em>empty interface type</em> (<span class="EmpStrong">interface</span><code>{}</code>) to allow variables of any type and then use type introspection to find out what they really are.</p>
<p>The <code>main()</code> function in the example is the program entry point. Unlike many other languages, this takes no arguments. Command-line <a id="page_31"/>arguments and environment variables are stored globally in Go, making it easy to access them from any function, not just one near the program entry point.</p>
<p>Inside this function, you&#8217;ll see a closure defined. Closures in Go are declared as anonymous functions, inside other functions. The closure can refer to any variables in the scope where it is declared. In this example, it refers to the <code>count</code> variable from the outer function&#8217;s scope. It would continue to do so even after the outer function returned. In Go, there is no distinction between heap and stack allocated variables, except at the implementation level. If a local variable is referenced after the function that contains it, then it is not freed when the function returns. If <code>closure</code> were stored in a global variable, for example, then <code>count</code> would not be deallocated, even after the function returned.</p>
<h3 id="ch02lev1sec4"><a id="page_32"/>Looping in Go</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;3<br/>&#160;4&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;5&#160;&#160;&#160;&#160;loops := 1<br/>&#160;6&#160;&#160;&#160;&#160;// while loop:<br/>&#160;7&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> loops &gt; 0 {<br/>&#160;8&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("\nNumber of loops?\n")<br/>&#160;9&#160;&#160;&#160;&#160;&#160;&#160;fmt.Scanf("%d", &#38;loops)<br/>10&#160;&#160;&#160;&#160;&#160;&#160;// <span class="EmpStrong">for</span> loop<br/>11&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i := 0 ; i &lt; loops ; i++ {<br/>12&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%d ", i)<br/>13&#160;&#160;&#160;&#160;&#160;&#160;}<br/>14&#160;&#160;&#160;&#160;}<br/>15&#160;&#160;&#160;&#160;// Infinite loop<br/>16&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> {<br/>17&#160;&#160;&#160;&#160;&#160;&#160;// Explicitly terminated<br/>18&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">break</span><br/>19&#160;&#160;&#160;&#160;}<br/>20&#160;&#160;}</p>
<p class="example"><a id="ch02ex05"/>From: loop.go</p>
<p>In C, you have three kinds of loops, all with different syntax and overlapping semantics. Go manages to have more expressive loop semantics, but simple and uniform syntax.</p>
<p>Every loop in Go is a <span class="EmpStrong">for</span> statement. We&#8217;ll only look at the forms that mirror C loop constructs here. The form that iterates over a collection is explained in <a href="ch05.html#ch05">Chapter 5</a>, <em><a href="ch05.html#ch05">Arrays and Slices</a></em>.</p>
<p>The <span class="romanAlt">loop.go</span> example shows the three types of general <span class="EmpStrong">for</span> loops in Go. The last one is the simplest. This is an infinite loop, with an <a id="page_33"/>explicit <span class="EmpStrong">break</span> statement to terminate it. You&#8217;d most commonly use this form for an event loop that would not terminate in normal use. Like C, Go also has a <span class="EmpStrong">continue</span> statement that immediately jumps to the start of the next loop iteration, or exits the loop if the loop condition no longer holds.</p>
<p>Both the <span class="EmpStrong">break</span> and <span class="EmpStrong">continue</span> statements support an optional label for jumping out of nested loops. Note that the label is not a jump target; it is just used to identify the loop.</p>
<p class="pre-1">&#160;5&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i := 0 ; i&lt;10 ; i++ {<br/>&#160;6&#160;&#160;L:<br/>&#160;7&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> {<br/>&#160;8&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> {<br/>&#160;9&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">break</span> L<br/>10&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>11&#160;&#160;&#160;&#160;&#160;&#160;}<br/>12&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%d\n", i)<br/>13&#160;&#160;&#160;&#160;}</p>
<p class="example"><a id="ch02ex06"/>From: break.go</p>
<p>You can see this in the <span class="romanAlt">break.go</span> example. The <span class="EmpStrong">break</span> statement jumps out of the two inner loops, but does not prevent the <code>Printf</code> call from running. It jumps to the end of the loop immediately after <code>L:</code>, not to the start.</p>
<p>Most of the time, you won&#8217;t use infinite loops and explicit escapes. The other two types of <span class="EmpStrong">for</span> loops in Go are analogous to <code>while</code> and <span class="EmpStrong">for</span> loops in C and the older form of <span class="EmpStrong">for</span> loops in Java. <a id="page_34"/>The outer loop in the example at the start of this section will test its condition and loop as long as it is true. The inner loop first performs the initialization (<code>i := 0</code>) then tests the loop condition (<code>i &lt; loops</code>), and runs the loop clause as long as it&#8217;s true. Between each loop iteration, it runs the increment clause (<code>i++</code>). If you&#8217;ve used any vaguely C-like language, then this will be very familiar to you. The only difference between a Go <span class="EmpStrong">for</span> loop and a C <span class="EmpStrong">for</span> loop is that the Go version does not require brackets.</p>
<p>There are a couple of interesting things in this loop. The first is the creation of the loop variable (<code>i</code>) at the loop scope. This is similar to C99 or C++. The variable that is declared in the loop initialization clause is only in scope for the duration of the loop.</p>
<p>The second is the <em>increment statement</em>. Note that I did not call it a <em>postincrement expression</em>. The designers of Go decided to eliminate the confusion between preincrement and postincrement expressions in C. In Go, the increment statement is not an expression, and only the suffix syntax is allowed. This line increments the variable, but it does not evaluate to anything. Writing something like <code>a := b++</code> is not valid Go. Writing <code>++b</code> is invalid in all contexts in Go: there is no prefix form of the operator.</p>
<h3 id="ch02lev1sec5"><a id="page_35"/>Creating Enumerations</h3>
<p class="pre">4&#160;&#160;<span class="EmpStrong">const</span> (<br/>5&#160;&#160;&#160;&#160;Red&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;= (1&lt;&lt;iota)<br/>6&#160;&#160;&#160;&#160;Green&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;= (1&lt;&lt;iota)<br/>7&#160;&#160;&#160;&#160;Blue, ColorMask&#160;&#160;= (1&lt;&lt;iota), (1&lt;&lt;(iota+1))-1<br/>8&#160;&#160;)</p>
<p class="example"><a id="ch02ex07"/>From: enum.go</p>
<p>There are several places in Go where it is obvious that someone has spent a lot of thought designing exactly the right syntax for most common uses of a language feature. Enumeration constants are the most obvious example of this attention to detail.</p>
<p>There is no divide between constants and enumerations in Go. This mirrors their implementation in C, where enumerated types can be used interchangeably with integers. Groups of constants within the same declaration in Go are used for enumerations.</p>
<p>There are two common uses for enumerated types. The first is defining a set of mutually-exclusive options. The second is defining a set of overlapping flags. Typically, you&#8217;ll use a sequence of numbers for the first and a sequence of powers of 2 for the second. You can then create a bitfield by bitwise-oring a combination of enumeration values together.</p>
<p>In C, and most other languages with enumerated types, you need to explicitly provide the <a id="page_36"/>numerical values for the second type of enumeration. The first will be automatically numbered by the compiler.</p>
<p>Go provides a much more flexible mechanism for defining enumerations. The <code>iota</code> predeclared identifier is similar to the GNU C <code>__COUNTER__</code> preprocessor macro, but it&#8217;s more powerful. It is an integer constant expression. In a normal program scope, it evaluates to zero, but in the scope of a constant declaration it is initially zero but then incremented on each line where it is used.</p>
<p>Unlike <code>__COUNTER__</code>, <code>iota</code> is scoped. It is zero on the first line of the group in this example, and will always be zero in the first line of this group, irrespective of how it is used elsewhere. If you have multiple <span class="EmpStrong">const</span> groups in a single source file, then <code>iota</code> will be zero at the start of each of them.</p>
<p>The example at the start of this section shows how to declare a group of constants for use as an enumerated type. This simple example shows the low 3 bits of a bitfield being used to store three flags indicating the presence of three color values. The <code>ColorMask</code> constant is defined to provide the value that must be bitwise-and&#8217;d with an integer to give the three color flags.</p>
<p>It&#8217;s possible to reference constants from other constant declarations, so you can combine this kind of declaration easily. For example, you could provide another constant declaration <a id="page_37"/>describing another group of flags within a set, and then extend this declaration to use them in the next few bits of the bitfield.</p>
<p>Similarly, you can extend existing constant declarations by inserting another <code>iota</code> expression earlier. This will then renumber all subsequent values, so it&#8217;s important to be careful when the constants are part of a binary interface.</p>
<p>Constants&#8212;and therefore enumerations&#8212;in Go are not limited to integers. Other types can be specified in the same way. The <span class="romanAlt">enum.go</span> example also shows the declaration of the complex constant <code>i</code>, with the same definition as in mathematics.</p>
<p class="pre-1">10&#160;&#160;<span class="EmpStrong">const</span> (<br/>11&#160;&#160;&#160;&#160;i complex128 = complex(0, 1)<br/>12&#160;&#160;)</p>
<p class="example"><a id="ch02ex08"/>From: enum.go</p>
<h3 id="ch02lev1sec6">Declaring Structures</h3>
<p class="pre">4&#160;&#160;<span class="EmpStrong">type</span> Example <span class="EmpStrong">struct</span> {<br/>5&#160;&#160;&#160;&#160;Val string<br/>6&#160;&#160;&#160;&#160;count int<br/>7&#160;&#160;}</p>
<p class="example"><a id="ch02ex09"/>From: struct.go</p>
<p>Structures in Go are somewhat richer than <a id="page_38"/>C structures. One of the most important differences is that Go structures automatically support <em>data hiding</em>.</p>
<p>Any top-level type, method, or variable name that starts with a capital letter is visible outside of the package in which it is declared. This extends to structure fields. In C, if you only put some fields from a structure in a header, then you will encounter problems when someone tries to allocate an instance of it on the stack: his compiler won&#8217;t allocate enough space for it. Go packages export the offsets of the public fields. This allows them to be created and their public fields accessed from other compilation units.</p>
<p>The example at the start of this section defines a structure with two fields. The first, a string, is public and can be accessed from anywhere. The second, an integer, is private and is only visible to code in the same package as this definition. A structure doesn&#8217;t have to declare any public fields. You can create <em>opaque types</em> by defining a structure where all of the fields are private.</p>
<p>If you&#8217;re coming from a class-based language like C++ or Java, then you may be wondering why there are public and private fields, but not protected ones. The answer is quite simple: there is no inheritance in Go, so protected would have no meaning. Public and private also have slightly different meanings in Go and a language like Java. A private field in a Go structure can be accessed by any code in the same package, <a id="page_39"/>not just by methods of that structure. If you come from Objective-C, then you can think of private fields in Go structures like <code>@package</code> instance variables in Objective-C. If you come from C++, then think of all Go functions in a package as implicitly being friends of all structures declared in the same package.</p>
<h3 id="ch02lev1sec7">Defining Methods</h3>
<p class="pre">&#160;9&#160;&#160;<span class="EmpStrong">type</span> integer int<br/>10&#160;&#160;<span class="EmpStrong">func</span> (i integer) log() {<br/>11&#160;&#160;&#160;&#160;fmt.Printf("%d\n", i);<br/>12&#160;&#160;}<br/>13&#160;&#160;<span class="EmpStrong">func</span> (e *Example) Log() {<br/>14&#160;&#160;&#160;&#160;e.count++<br/>15&#160;&#160;&#160;&#160;fmt.Printf("%d %s\n", e.count, e.Val)<br/>16&#160;&#160;}</p>
<p class="example"><a id="ch02ex10"/>From: methods.go</p>
<p>If you&#8217;ve used a class-based language, then you are probably wondering why the last example didn&#8217;t define any methods defined on the structure. In Go, you may define methods on any concrete type that you define, not just on structures. The example at the start of this section defines two <code>Log()</code> methods&#8212;recall that the uppercase start letter makes them public&#8212;one on the structure defined in the last section and one on a named integer type.</p>
<p>The Go type system lets you assign any <code>int</code> to this named type without an explicit cast, but not <a id="page_40"/>vice versa. It also prevents you from assigning between two named types. This can be very useful for variables representing quantities. You could, for example, define kilometer and mile types and have the compiler reject any code where you attempted to assign one to the other.</p>
<p>You cannot add methods to existing types&#8212;Go does not have an equivalent of Objective-C categories&#8212;but you can define new named types and add methods to them.</p>
<p>Methods are declared just like functions, except that there is one extra parameter&#8212;the <em>receiver</em>&#8212;declared before the function name. One of the interesting syntactic quirks of Go is that there is no <code>this</code> or <code>self</code> keyword. You can give the receiver any name that you want, and this name does not have to be consistent between methods. This idea comes from Oberon-2 and should be popular with people who like the &#8220;no magic&#8221; philosophy of languages like Objective-C: the receiver is not an implicit hidden parameter that the compiler inserts; it is an explicit parameter just like any other.</p>
<p>The method on the structure in the example at the start of this section takes a pointer as the receiver. This means that it can modify fields of the receiver and these changes will be shared. Methods do not have to take pointers: the other method in the example takes a value. If a method takes a value type, then it can still be called with either a value or a pointer, but it <a id="page_41"/>will receive a copy of the structure, so changes that it makes will not be visible from the caller.</p>
<p>When talking about expressions with an explicit type, methods are just functions. You call a method on a structure by using the dot notation, and you declare the parameter that declares how the structure is passed to the method in a special way, but this is just some syntactic sugar. Methods called in this way are semantically equivalent to functions that just take the receiver as an argument: they are statically resolved and are just function calls.</p>
<p>That&#8217;s not the real power of methods, though. When you call a method via an interface (described in the next section), you get late-bound dynamic lookup. This dual nature of Go methods means that you have a single abstraction that can be used in the same way as either C types or Smalltalk objects. If you require performance, then you can use statically typed definitions and avoid the dynamic lookup. If you require flexibility, then you can use the late binding mechanism of interfaces.</p>
<h3 id="ch02lev1sec8"><a id="page_42"/>Implementing Interfaces</h3>
<p class="pre">&#160;5&#160;&#160;<span class="EmpStrong">type</span> cartesianPoint <span class="EmpStrong">struct</span>&#160;&#160;{<br/>&#160;6&#160;&#160;&#160;&#160;x, y float64<br/>&#160;7&#160;&#160;}<br/>&#160;8&#160;&#160;<span class="EmpStrong">type</span> polarPoint <span class="EmpStrong">struct</span> {<br/>&#160;9&#160;&#160;&#160;&#160;r, <span class="EmpItalic">&#952;</span> float64<br/>10&#160;&#160;}<br/>11<br/>12&#160;&#160;<span class="EmpStrong">func</span> (p cartesianPoint) X() float64 {<span class="EmpStrong">return</span> p.x }<br/>13&#160;&#160;<span class="EmpStrong">func</span> (p cartesianPoint) Y() float64 {<span class="EmpStrong">return</span> p.y }<br/>14&#160;&#160;<span class="EmpStrong">func</span> (p polarPoint) X() float64 {<br/>15&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> p.r*math.Cos(p.<span class="EmpItalic">&#952;</span>)<br/>16&#160;&#160;}<br/>17&#160;&#160;<span class="EmpStrong">func</span> (p polarPoint) Y() float64 {<br/>18&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> p.r*math.Sin(p.<span class="EmpItalic">&#952;</span>)<br/>19&#160;&#160;}<br/>20&#160;&#160;<span class="EmpStrong">func</span> (self cartesianPoint) Print() {<br/>21&#160;&#160;&#160;&#160;fmt.Printf("(%f, %f)\n", self.x, self.y)<br/>22&#160;&#160;}<br/>23&#160;&#160;<span class="EmpStrong">func</span> (self polarPoint) Print() {<br/>24&#160;&#160;&#160;&#160;fmt.Printf("(%f, %f&#176;)\n", self.r, self.<span class="EmpItalic">&#952;</span>)<br/>25&#160;&#160;}<br/>26&#160;&#160;<span class="EmpStrong">type</span> Point <span class="EmpStrong">interface</span>&#160;&#160;{<br/>27&#160;&#160;&#160;&#160;Printer<br/>28&#160;&#160;&#160;&#160;X() float64<br/>29&#160;&#160;&#160;&#160;Y() float64<br/>30&#160;&#160;}<br/>31&#160;&#160;<span class="EmpStrong">type</span> Printer <span class="EmpStrong">interface</span> {<br/>32&#160;&#160;&#160;&#160;Print()<br/>33&#160;&#160;}</p>
<p class="example"><a id="ch02ex11"/>From: interface.go</p>
<p>The dynamic dispatch mechanism in Go is reminiscent of StrongTalk, a strongly typed Smalltalk dialect. Interfaces describe a set of methods that a type understands. Unlike Java <a id="page_43"/>interfaces or Objective-C protocols, they do not need to be explicitly adopted.</p>
<p>Any type can be assigned to a variable with an interface type, as long as it implements all of the required methods. In some cases, this can be checked at compile time. For example, if one interface is a superset of another, then casting from the superset to the subset is always valid, as is casting from a structure type to an interface when the compiler sees that the structure implements the interface.</p>
<p>In other cases, it is not. These cases require a <em>type assertion</em>, detailed in the next section, which will generate a runtime panic if they fail. This means that any variable with an interface type is guaranteed to either be <code>nil</code>, or hold a valid value of a concrete type that implements the interface.</p>
<p>The example from the start of this section shows the creation of new structure types, and interfaces that they implement. Note that the structure can be defined before the interface. In fact, structures can be defined in entirely different packages to interfaces. This is especially useful if various third-party structures all implement the same method or group of methods: you can define a new interface that can be any one of them.</p>
<p>There are two interfaces declared in this example, both following Go naming conventions. The <code>Printer</code> interface defines a single method, so it follows the convention of appending the -er suffix to the method name to give the interface name.</p>
<div class="note"><hr/>
<p class="title"><a id="ch02note01"/><a id="page_44"/>Note</p>
<p class="notepara">If you&#8217;re coming from C++, then you should use interfaces in most of the places where you&#8217;d use templates in C++. Rather than defining template functions or classes (which Go doesn&#8217;t support), define an interface that specifies the set of methods that you need, and use it where you would use the template parameter in C++.</p>
<hr/></div>
<p>The other interface uses <em>interface composition</em> to extend the <code>Printer</code> interface. This one defines an abstract data type. It provides methods for accessing the horizontal and vertical coordinates of a two-dimensional point. Interface composition is effectively equivalent to interface inheritance in Java. You can use it in some places where you would consider using single or multiple inheritance in other languages.</p>
<p>This example provides two structures that implement this interface, one using Cartesian and the other using polar coordinates. This is a simple example of how an interface can be used to hide the implementation. The two structures both start with lowercase letters, so they will not be exported from this package, while the interfaces will. You could extend this example by providing functions to construct a <code>Point</code> from polar and Cartesian coordinates, each returning <a id="page_45"/>one of a different kind of structure.</p>
<p>When you are dealing with interfaces, the distinction between methods that take pointers and ones that take values becomes more important. If you tried to assign an instance of this example structure to an interface that required the <code>Log()</code> method, then the assignment would be rejected. Assigning a pointer to an instance of this structure would work.</p>
<p>This seems counterintuitive. If you have a value, then you can always take its address to get a pointer, so why are the two method sets distinct? The answer is very simple: it helps avoid bugs. When you pass a value, you create a copy of a structure. When you pass a pointer, you alias the structure. If you pass a value and then implicitly, via method invocation on an interface, pass a pointer, then any changes that the method made would be made to the temporary copy, not to the original structure. This is probably not what you want, and if it is then you can just pass the pointer originally, rather than the copy.</p>
<p>The Go FAQ gives an example of a case where this could be problematic:</p>
<p class="pre-n"><span class="EmpStrong">var</span> buf bytes.Buffer<br/>io.Copy(buf, os.Stdin)</p>
<p>The <code>io.Copy()</code> function copies data from something that implements the <code>io.Reader</code> interface to something that implements the <code>io.Writer</code> interface. When you call this <a id="page_46"/>function, it will pass a copy of <code>buf</code> as the first argument, because Go always passes by value, not by reference. It will then try to copy data from the standard input into the new copy of <code>buf</code>. When the function returns, the copy of <code>buf</code> will no longer be referenced, so the garbage collector will free it.</p>
<p>What the person writing this code probably wanted to do was copy data from the standard input into <code>buf</code>. The Go type system will reject this, because <code>buf</code> does not implement the <code>io.Writer</code> interface: the method for writing bytes to a buffer modifies the buffer and therefore requires a pointer receiver. By disallowing this, Go lets you get an error at compile time and trivially fix it by writing this instead:</p>
<p class="pre-n"><span class="EmpStrong">var</span> buf bytes.Buffer<br/>io.Copy(&#38;buf, os.Stdin)</p>
<p>If Go allowed values to use methods that are declared as requiring a pointer, then you would instead spend ages wondering why this line appeared to be reading the correct amount of data, but wasn&#8217;t storing any of it in the buffer that you declared. This is part of the Go philosophy of avoiding ambiguity. It just takes one extra character to make a pointer when you need one. That small amount of extra effort is a lot less than the time you&#8217;d spend debugging code where you meant one thing and Go assumed that you meant something else.</p>
<h3 id="ch02lev1sec9"><a id="page_47"/>Casting Types</h3>
<p class="pre">&#160;4&#160;&#160;<span class="EmpStrong">type</span> empty <span class="EmpStrong">interface</span> {}<br/>&#160;5&#160;&#160;<span class="EmpStrong">type</span> example <span class="EmpStrong">interface</span> {<br/>&#160;6&#160;&#160;&#160;&#160;notImplemented()<br/>&#160;7&#160;&#160;}<br/>&#160;8<br/>&#160;9&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>10&#160;&#160;&#160;&#160;one := 1<br/>11&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> i empty = one<br/>12&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> float float32<br/>13&#160;&#160;&#160;&#160;float = float32(one)<br/>14&#160;&#160;&#160;&#160;<span class="EmpStrong">switch</span> i.(<span class="EmpStrong">type</span>) {<br/>15&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">default:</span><br/>16&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Type error!\n")<br/>17&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> int:<br/>18&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%d\n", i)<br/>19&#160;&#160;&#160;&#160;}<br/>20&#160;&#160;&#160;&#160;fmt.Printf("%f\n", float)<br/>21&#160;&#160;&#160;&#160;// This will panic&#160;&#160;at run time<br/>22&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> e example = i.(example)<br/>23&#160;&#160;&#160;&#160;fmt.Printf("%d\n",&#160;e.(empty).(int))<br/>24&#160;&#160;}</p>
<p class="example"><a id="ch02ex12"/>From: cast.go</p>
<p>Unlike C, Go does not allow implicit casting. This is not laziness on the part of the implementors: implicit casting makes it easy for very subtle bugs to slip into code. I recently had to find a bug in some code that had gone undetected for several years, where an implicit cast meant that a value was incorrectly initialized. The code looked correct, until you checked the type declarations of everything involved, which were spread over multiple files.</p>
<p><a id="page_48"/>This is another example of the Go philosophy. You should never need to state the obvious to the compiler, but you should always have to explicitly specify things that are otherwise ambiguous.</p>
<p>The example at the start of this section shows several casts. The concept of casting in other languages is embodied by two concepts in Go. The first is <em>type conversion</em>; the second is <em>type assertion</em>.</p>
<p>A type conversion is similar to a cast in C. It reinterprets the value as a new type. The conversion from <code>int</code> to <code>float32</code> is an example of this. The resulting value is a new floating-point value with the same value as the integer. In some cases, the conversion is only approximate. For example, a conversion in the other direction will result in truncation. A type conversion from an integer to a string type will return a single-character string interpreting the integer as a unicode value.</p>
<p>Type assertions are more interesting. They do not convert between types; they simply state to the compiler that the underlying value has the specified type. This assertion is checked at run time. If you try running this example, you will see that it aborts with a runtime panic.</p>
<p>This is because of the type assertion telling the compiler that the type of <code>i</code> is something that implements the <code>example</code> interface. In fact, the underlying type is <code>int</code>, which does not implement the <code>notImplemented()</code> method that this interface specifies. The type check fails on the type assertion. If you come from C++, you can think of type assertions as roughly equivalent to a <code>dynamic_cast</code> that throws an exception<sup><a id="ch02fn02" href="footnotes.html#ch02fn02a">2</a></sup> on failure.</p>
<p class="pre-1">&#160;1&#160;&#160;1<br/>&#160;2&#160;&#160;1.000000<br/>&#160;3&#160;&#160;panic: interface conversion: int is not main.<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;example: missing method notImplemented<br/>&#160;4<br/>&#160;5&#160;&#160;goroutine 1 [running]:<br/>&#160;6&#160;&#160;main.main()<br/>&#160;7&#160;&#160;&#160;&#160;/Users/theraven/Documents/Books/GoPhrasebook/<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;startsnippets/cast.go:22 +0x20d<br/>&#160;8<br/>&#160;9&#160;&#160;&#160;goroutine 2 [syscall]:<br/>10&#160;&#160;&#160;created by runtime.main<br/>11&#160;&#160;&#160;&#160;&#160;/Users/theraven/go/src/pkg/runtime/proc.c:219<br/>12&#160;&#160;&#160;<span class="EmpStrong">exit</span> status 2</p>
<p class="example"><a id="page_49"/><a id="ch02ex13"/>Output from: cast.go</p>
<p>The final cast-like construct in Go is the <em>type switch statement</em>. This is written like a normal <span class="EmpStrong">switch</span> statement, but the switch expression is a type assertion to <span class="EmpStrong">type</span> and the cases have type names, rather than values.</p>
<p>The type switch in the example is used as a simple type check, like a C++ <code>dynamic_cast</code>.</p>
<p><a id="page_50"/>It is more common to use type switches when defining generic data structures (see <a href="ch04.html#ch04">Chapter 4</a>, <em><a href="ch04.html#ch04">Common Go Patterns</a></em>) to allow special cases for various types.</p>
</body>
</html>