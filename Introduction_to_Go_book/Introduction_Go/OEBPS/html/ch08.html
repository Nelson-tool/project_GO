<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>8. Handling Errors</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch08"><a id="page_117"/>8. Handling Errors</h2>
<p>Most code contains bugs. Good code is aware of this and will handle them gracefully. Really good code uses formal methods to prove that there are no bugs, but most people can&#8217;t afford really good code.</p>
<p>Most of the sample code in this book pretends that errors never happen. This book has quite small pages, and proper error-handling code for any of the examples would fill them up very quickly with things that are largely irrelevant to the point of the example.</p>
<p>Most errors that can be detected at run time come from one function or method calling another with invalid inputs. The best way of handling this depends a lot on the language. For example, Erlang discourages defensive programming at the module level; if your module is in an undefined state, you should kill it and create a new version. In C, you are encouraged to validate every input and check every return <a id="page_118"/>value. In Java, you can defer error handling by using exceptions. Lisp and Smalltalk let you inspect the stack when an error occurs and dynamically fix the code that gave you the wrong input.</p>
<p>Go doesn&#8217;t have a one-size-fits-all solution for errors. There are two common patterns for errors, depending on their severity, and some others that can be used for specific situations.</p>
<h3 id="ch08lev1sec1">Deferring Cleanup</h3>
<p class="pre">4&#160;&#160;<span class="EmpStrong">func</span> callLocked(lock *sync.Mutex, f <span class="EmpStrong">func</span>()) {<br/>5&#160;&#160;&#160;&#160;lock.Lock()<br/>6&#160;&#160;&#160;&#160;<span class="EmpStrong">defer</span> lock.Unlock()<br/>7&#160;&#160;&#160;&#160;f()<br/>8&#160;&#160;}</p>
<p class="example"><a id="ch08ex01"/>From: defer.go</p>
<p>Quite often there&#8217;s a lot of code between the place that caused an error and the place that can handle it. Quite often, it is important for code to be safe in both the presence and absence of errors. If your function is somewhere between a panic and a recover,<sup><a id="ch08fn01" href="footnotes.html#ch08fn01a">1</a></sup> it should not break.</p>
<p>One obvious example of this is releasing a mutex. We&#8217;ll look at mutexes in more detail in <a href="ch09.html#ch09">Chapter 9</a>, <em><a href="ch09.html#ch09">Goroutines</a></em>. If you&#8217;ve not come across them before in another language, you can think of them as simple locks. Once a mutex is locked, <a id="page_119"/>any other goroutine attempting to lock it will block until the mutex is unlocked. This means that forgetting to unlock a mutex that you&#8217;ve locked can cause your program to deadlock.</p>
<p>If you acquire a mutex, then you should make sure that you release it no matter how your function exits, whether via an explicit return, implicitly reaching the end of the function, or a panic causing the stack to unwind.</p>
<p>The <span class="EmpStrong">defer</span> statement lets you do exactly this. You can think of this as being analogous to GCC&#8217;s <code>__attribute__((cleanup))</code>, C++ local destructors, or <code>finally</code> and <code>@finally</code> in Java and Objective-C, respectively. The function call in the <span class="EmpStrong">defer</span> statement happens when the function exits.</p>
<p>The example at the start of this section shows a function that takes a mutex and a function as arguments, and calls the function with the mutex lock. The complete example calls this with a nil function, which causes a runtime panic. No matter what happens when the function is called, this function will then unlock the mutex. Of course, the program may then still abort, but the cleanup code should still run correctly. If the goroutine where this function was called terminates for any reason, it will not accidentally leave the mutex locked.</p>
<p>You can use this same mechanism for releasing operating system resources, for example closing a file that you have been using. This ensures <a id="page_120"/>that your code does not leak file descriptors. The garbage collection in Go means that you do not have to use this mechanism to free memory.</p>
<h3 id="ch08lev1sec2"><a id="page_121"/>Panicking and Recovering</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;3<br/>&#160;4&#160;&#160;<span class="EmpStrong">func</span> badFunction() {<br/>&#160;5&#160;&#160;&#160;&#160;fmt.Printf("Select Panic <span class="EmpStrong">type</span> (0=no panic, 1=<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int, 2=runtime panic)\n")<br/>&#160;6&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> choice int<br/>&#160;7&#160;&#160;&#160;&#160;fmt.Scanf("%d", &#38;choice)<br/>&#160;8&#160;&#160;&#160;&#160;<span class="EmpStrong">switch</span> choice {<br/>&#160;9&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> 1:<br/>10&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic(0)<br/>11&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> 2:<br/>12&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> invalid <span class="EmpStrong">func</span>()<br/>13&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;invalid()<br/>14&#160;&#160;&#160;&#160;}<br/>15&#160;&#160;}<br/>16<br/>17&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>18&#160;&#160;&#160;&#160;<span class="EmpStrong">defer func</span>() {<br/>19&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> x := recover(); x != nil {<br/>20&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">switch</span> x.(<span class="EmpStrong">type</span>) {<br/>21&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">default</span>: panic(x)<br/>22&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">case</span> int:<br/>23&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Function panicked with a<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;very unhelpful error: %d\n", x)<br/>24&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}<br/>25&#160;&#160;&#160;&#160;&#160;&#160;}<br/>26&#160;&#160;&#160;&#160;}()<br/>27&#160;&#160;&#160;&#160;badFunction()<br/>28&#160;&#160;&#160;&#160;fmt.Printf("Program exited normally\n")<br/>29&#160;&#160;}</p>
<p class="example"><a id="ch08ex02"/>From: panic.go</p>
<p>You may have heard that Go does not have exceptions. This is somewhat misleading. Go&#8217;s <code>panic</code> mechanism is semantically equivalent to <a id="page_122"/>an exception in other languages. What Go lacks is a culture of using exceptions for flow control.</p>
<p>Exceptions are so named because they are intended to be used for exceptional conditions. A lot of programmers seem to interpret this to mean that they don&#8217;t happen on quite every call. Go uses the stronger term, panic, to indicate that this mechanism should only be used when there is no obvious recovery mechanism.</p>
<p>The most common response to a panic is for the program to exit. In some cases, it may be possible to recover. In a multiuser program, such as a web app, the correct response to a panic might be to delete the session that caused the panic but not touch any other users&#8217; data.</p>
<p>In general, it&#8217;s much easier to decide when to panic than when to recover. You should panic when you can&#8217;t think of a good way of continuing. For example, Go will panic if you try to dereference a nil pointer. This implies that something has gone wrong somewhere, and continuing would probably be dangerous.</p>
<p>Deciding when to recover is harder. A panic is usually caused by some very unexpected behavior, so the program may be in an undefined state. Attempting to resume is often a bad idea. Even attempting to clean up can be dangerous: there was a vulnerability in OpenSSH not so long ago that was caused by a bug in cleanup code that ran as the result of abnormal termination.</p>
<p><a id="page_123"/>This mechanism is controlled by the <code>panic()</code> and <code>recover()</code> built-in functions. The <code>panic()</code> function takes an empty interface argument (i.e. a value of any type) and begins unwinding the stack, executing any of the code in any <span class="EmpStrong">defer</span> statements as it goes.</p>
<p>If a <span class="EmpStrong">defer</span> statement contains a call to <code>recover()</code>, the argument to <code>panic()</code> is returned. This will be <code>nil</code> if the <span class="EmpStrong">defer</span> clause is being called as a result of a normal function exit, not as part of a panic.</p>
<p>The example at the start of this section shows two ways of panicking: one with an explicit call to <code>panic()</code> and one by calling an invalid function, which causes the runtime to generate a panic.</p>
<p>The <span class="EmpStrong">defer</span> statement uses <code>recover()</code> to check for the panic. It then uses a <em>type switch statement</em> to determine the type of the panic. If it&#8217;s an <code>int</code>, then we know that it&#8217;s the example panic and so just discard it. Otherwise, we pass it back to <code>panic()</code>. Note the output for the runtime panic shows that it was recovered, before the program exited.</p>
<p>This example has largely used the panic and recover mechanism to implement a try-catch-finally mechanism. The point of this is to show you that the panicking is as expressive as these mechanisms, not to show you good practice. In general, you should avoid calling <code>recover()</code> unless you are absolutely certain that it is safe to recover.</p>
<p class="pre-1">&#160;1&#160;&#160;$ ./6.out<br/>&#160;2&#160;&#160;Select Panic type (0=no panic, 1=int, 2=runtime<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic)<br/>&#160;3&#160;&#160;0<br/>&#160;4&#160;&#160;Program exited normally<br/>&#160;5&#160;&#160;$ ./6.out<br/>&#160;6&#160;&#160;Select Panic type (0=no panic, 1=int, 2=runtime<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic)<br/>&#160;7&#160;&#160;2<br/>&#160;8&#160;&#160;panic: runtime error: invalid memory address or<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nil pointer dereference [recovered]<br/>&#160;9&#160;&#160;&#160;&#160;panic: runtime error: invalid memory address or<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nil pointer dereference<br/>10<br/>11&#160;&#160;&#160;&#160;[signal 0xb code=0x1 addr=0x0 pc=0x0]<br/>12<br/>13&#160;&#160;&#160;&#160;runtime.panic+0xac /Users/theraven/go/src/pkg/<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;runtime/proc.c:1060<br/>14&#160;&#160;&#160;&#160;&#160;&#160;runtime.panic(0x5e008, 0xf8400013d0)<br/>15<br/>16&#160;&#160;$ ./6.out<br/>17&#160;&#160;Select Panic type (0=no panic, 1=int, 2=runtime<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;panic)<br/>18&#160;&#160;1<br/>19&#160;&#160;Function panicked with a very unhelpful error: 0</p>
<p class="example"><a id="page_124"/><a id="ch08ex03"/>Output from: panic.go</p>
<p>If you are recovering from expected panics, as happens in this example, then it&#8217;s a good sign that your code is wrong. Panics should never be expected in good code, because it means that you&#8217;ve missed some error handling. The call to <code>invalid</code> in <code>badFunction()</code> should be bracketed with a check that it is not a nil function.</p>
<h3 id="ch08lev1sec3"><a id="page_125"/>Returning Error Values</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "errors"<br/>&#160;3&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;4&#160;&#160;<span class="EmpStrong">import</span> "math"<br/>&#160;5<br/>&#160;6&#160;&#160;<span class="EmpStrong">func</span> sqrt(i int) (result float64, error error) {<br/>&#160;7&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> i &lt; 0 {<br/>&#160;8&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> 0, errors.New("Invalid argument")<br/>&#160;9&#160;&#160;&#160;&#160;}<br/>10&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> math.Sqrt(float64(i)), nil<br/>11&#160;&#160;}<br/>12<br/>13&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>14&#160;&#160;&#160;&#160;// Ignoring error value, because 2 is a valid<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;input<br/>15&#160;&#160;&#160;&#160;r, _ := sqrt(2)<br/>16&#160;&#160;&#160;&#160;fmt.Printf("sqrt(2) = %f\nEnter another number\<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;n", r)<br/>17&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> i int<br/>18&#160;&#160;&#160;&#160;fmt.Scanf("%d", &#38;i)<br/>19&#160;&#160;&#160;&#160;root, err := sqrt(i)<br/>20&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> err == nil {<br/>21&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("sqrt(%d) = %f\n", i, root)<br/>22&#160;&#160;&#160;&#160;} <span class="EmpStrong">else</span> {<br/>23&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Error: %s\n", err.Error())<br/>24&#160;&#160;&#160;&#160;}<br/>25&#160;&#160;}</p>
<p class="example"><a id="ch08ex04"/>From: error.go</p>
<p>The common way of returning errors in C is to return a known-invalid value, like <code>-1</code> or <code>NULL</code>, and then use a side channel for passing back the error value. There are two major problems with this approach. It is not easy to spot code that is missing error checks and it requires overloading <a id="page_126"/>values, which makes the code hard to read.</p>
<p>In Go, the most common idiom for reporting errors is to use the <em>multiple return values</em> capability to return the normal result and an error. It is obvious when code is missing error checking because it is ignoring the error return value.</p>
<p>The example at the start of this section defines a simple <code>sqrt()</code> function that returns an error if you pass it a negative input, which would give a complex number as a result and could therefore not be returned as a <code>float64</code>.</p>
<p>The first call to this function ignores the error value. Without the comment, someone reading the code would be suspicious of this cavalier disregard for the error code. With the comment, they&#8217;d still not regard it as good code, but would understand why it was omitted.</p>
<p>When passing user-provided input to the function, checking the error is important, so in the second call the error is checked and we give up if there is any error.</p>
<p>This function shows the <code>error</code> built-in type. This is an interface that just defines one method, for generating a string value describing the error. The simplest way of constructing these is to use the <code>New()</code> function, which is currently the only function defined in the <em>errors package</em>. This returns a new <code>error</code> wrapping a string.</p>
<p>For more complex error reporting, you may want to provide your own structure implementing <a id="page_127"/>this interface and providing some extra fields or methods that users can examine for better error handling.</p>
<p>Lots of low-level code uses the <code>Errno</code> type, which wraps a UNIX-style error number. Unlike the UNIX or C version, this is returned using the same mechanism that we&#8217;ve just seen, not some side-channel involving macros and thread-local storage.</p>
<h3 id="ch08lev1sec4">Error Delegates</h3>
<p class="pre">&#160;5&#160;&#160;<span class="EmpStrong">type</span> sqrtError <span class="EmpStrong">interface</span> {<br/>&#160;6&#160;&#160;&#160;&#160;invalidArgument(int) (int, error)<br/>&#160;7&#160;&#160;}<br/>&#160;8&#160;&#160;<span class="EmpStrong">func</span> sqrt(i int, e sqrtError) (result float64,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;err error) {<br/>&#160;9&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i &lt; 0 {<br/>10&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> err error<br/>11&#160;&#160;&#160;&#160;&#160;&#160;i, err = e.invalidArgument(i)<br/>12&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> err != nil {<br/>13&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> 0, err<br/>14&#160;&#160;&#160;&#160;&#160;&#160;}<br/>15&#160;&#160;&#160;&#160;}<br/>16&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> math.Sqrt(float64(i)), nil<br/>17&#160;&#160;}</p>
<p class="example"><a id="ch08ex05"/>From: errorDelegate.go</p>
<p>One powerful error handling pattern that is not yet common in Go is the <em>error delegate pattern</em>. This pattern is well suited to Go&#8217;s interface typing, which makes it very easy to create simple objects.</p>
<p><a id="page_128"/>Error delegates in Go are interfaces with one method per type of error, implementing a recovery behavior. The example at the start of this section shows the last example, extended to take an error delegate as an argument.</p>
<p>This is a slightly oversimplified example, which contains an obvious bug&#8212;it doesn&#8217;t check that the error delegate is not <code>nil</code> before calling <code>invalidArgument()</code> on it, so it will crash if you pass <code>nil</code> as the error delegate&#8212;but it should serve to illustrate the general pattern.</p>
<p>When the error is encountered, rather than aborting, the code now gives the error delegate a chance to fix it&#8212;in this case, by providing a replacement for the invalid argument. The exact mechanism by which this replacement is provided is up to the caller.</p>
<p>The <span class="romanAlt">errorDelegate.go</span> example includes a simple example delegate that just asks the user for another version. Alternatively, one might just return an absolute value. In extreme cases, it might panic.</p>
<p>This pattern takes a little bit more effort to use than the simple error-value return and so is best used for errors in complex functions. In this example, it is massive overkill, because it&#8217;s faster and as powerful to simply retry the <code>sqrt()</code> call with different arguments if an error is encountered. If a function performs a lot of complex steps and might fail at any point in the middle, then it&#8217;s better to use something like this.</p>
<p class="pre-1">19&#160;&#160;<span class="EmpStrong">type</span> sqrtHandler <span class="EmpStrong">struct</span> {}<br/>20&#160;&#160;<span class="EmpStrong">func</span> (_ sqrtHandler) invalidArgument(i int) (int,<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;error) {<br/>21&#160;&#160;&#160;&#160;fmt.Printf("%d is not valid, please enter<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;another value\n", i)<br/>22&#160;&#160;&#160;&#160;fmt.Scanf("%d", &#38;i)<br/>23&#160;&#160;&#160;&#160;<span class="EmpStrong">return</span> i, nil<br/>24&#160;&#160;}<br/>25<br/>26&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>27&#160;&#160;&#160;&#160;fmt.Printf("Enter a number\n")<br/>28&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> i int<br/>29&#160;&#160;&#160;&#160;fmt.Scanf("%d", &#38;i)<br/>30&#160;&#160;&#160;&#160;root, err := sqrt(i, sqrtHandler{})<br/>31&#160;&#160;&#160;&#160;<span class="EmpStrong">if</span> err == nil {<br/>32&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("sqrt(%d) = %f\n", i, root)<br/>33&#160;&#160;&#160;&#160;} <span class="EmpStrong">else</span> {<br/>34&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("Error: %s\n", err.Error())<br/>35&#160;&#160;&#160;&#160;}<br/>36&#160;&#160;}</p>
<p class="example"><a id="page_129"/><a id="ch08ex06"/>From: errorDelegate.go</p>
<p>For example, if you had a function that copied a lot of files, then an error delegate would be a good way of handling problems. You may want to continue if one file copy fails, or you may wish to abort, or possibly modify the file permissions (or allow the user to do so) and continue.</p>
</body>
</html>