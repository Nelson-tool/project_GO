<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>3. Numbers</title>
<link rel="stylesheet" type="text/css" href="9780132919005.css"/>
<link rel="stylesheet" type="application/vnd.adobe-page-template+xml" href="page-template.xpgt"/>
</head>
<body>
<h2 id="ch03"><a id="page_51"/>3. Numbers</h2>
<p>When I first learned C, the compiler supported 16-bit <code>int</code>s and 32-bit <code>long</code>s. A few years later, it became more common for <code>int</code> to be 32 bits. A lot of code was written with assumptions about the sizes of C types, and this caused people a lot of problems when 64-bit systems became common.</p>
<p>The C99 standard introduced the <span class="romanAlt">stdint.h</span> header, which defined types like <code>uint32_t</code>, an unsigned integer that was 32 bits on any platform. This helped a bit, but on some platforms a cast between a <code>uint32_t</code> and an <code>unsigned int</code> was safe and wouldn&#8217;t generate a warning, since they were the same underlying type, while on others it was not.</p>
<p>Go learned from this mess and provides explicitly sized integer and floating-point types from the start. A <code>uint64</code> is always a 64-bit unsigned integer. An <code>int16</code> is always a 16-bit signed integer.</p>
<p><a id="page_52"/>Sometimes, you don&#8217;t want to specify the exact size of a type. Go also provides <code>int</code> and <code>uint</code> types, which have more or less the same definition as in C. They are a natural size for the machine, but always at least 32 bits.<sup><a id="ch03fn01" href="footnotes.html#ch03fn01a">1</a></sup> Unlike the C equivalent, you cannot implicitly cast between <code>int</code> and any explicitly sized type. This avoids the case where code is performing a safe conversion on one platform but not on another.</p>
<h3 id="ch03lev1sec1">Converting Between Strings and Numbers</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;3&#160;&#160;<span class="EmpStrong">import</span> "strconv"<br/>&#160;4<br/>&#160;5&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;6&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> i int<br/>&#160;7&#160;&#160;&#160;&#160;fmt.Scanf("%d", &#38;i)<br/>&#160;8&#160;&#160;&#160;&#160;str := strconv.FormatInt(int64(i), 10)<br/>&#160;9&#160;&#160;&#160;&#160;hex, _ := strconv.ParseInt(str, 16, 64)<br/>10&#160;&#160;&#160;&#160;fmt.Printf("%d\n", hex)<br/>11&#160;&#160;}</p>
<p class="example"><a id="ch03ex01"/>From: str2num.go</p>
<p>We&#8217;ve already seen some examples of converting between numbers and strings using the <em>fmt package</em>. You can use numerical format specifiers with functions like <code>Printf()</code> and <code>Scanf()</code> to <a id="page_53"/>read and write numbers, but that&#8217;s often overkill for a simple conversion.</p>
<p>The <em>strconv package</em> contains various functions to just perform the conversions. These allow conversion between numerical types and strings, in both directions, optionally with a specified number base.</p>
<p>The example at the start of this section shows a rather convoluted sequence of conversions. This first reads some characters from the standard input, which it interprets as a decimal integer. It then constructs a string from this, and then parses the string as a base-16 integer. Finally, it outputs the value as a base-10 integer again.</p>
<p>Prior to Go 1.0, the functions in this package had quite confusing names for various number bases. Now the large range of functions has been replaced by a simpler set of more generic ones. The example uses <code>FormatInt()</code> to create a string from the integer and <code>ParseInt()</code> to perform the inverse conversion.</p>
<p>We&#8217;re ignoring the second value returned from <code>strconv.ParseInt()</code>. This is an error value, and we assume that the input is always valid. If you are getting the string from user input then you should probably check the error value.</p>
<h3 id="ch03lev1sec2"><a id="page_54"/>Using Large Integers</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "math/big"<br/>&#160;3&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;4<br/>&#160;5&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;6&#160;&#160;&#160;&#160;<span class="EmpStrong">var</span> n int<br/>&#160;7&#160;&#160;&#160;&#160;fmt.Printf("Compute how many Fibonacci numbers?<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;")<br/>&#160;8&#160;&#160;&#160;&#160;fmt.Scanf("%d", &#38;n)<br/>&#160;9&#160;&#160;&#160;&#160;last := big.NewInt(1)<br/>10&#160;&#160;&#160;&#160;current := big.NewInt(1)<br/>11&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i := 0 ; (i &lt; n) &#38;&#38; (i &lt; 2) ; i++ {<br/>12&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("1\n")<br/>13&#160;&#160;&#160;&#160;}<br/>14&#160;&#160;&#160;&#160;<span class="EmpStrong">for</span> i := 2 ; i &lt; n ; i++ {<br/>15&#160;&#160;&#160;&#160;&#160;&#160;last.Add(last, current)<br/>16&#160;&#160;&#160;&#160;&#160;&#160;tmp := last<br/>17&#160;&#160;&#160;&#160;&#160;&#160;last = current<br/>18&#160;&#160;&#160;&#160;&#160;&#160;current = tmp<br/>19&#160;&#160;&#160;&#160;&#160;&#160;fmt.Printf("%s\n", current.String())<br/>20&#160;&#160;&#160;&#160;}<br/>21&#160;&#160;}</p>
<p class="example"><a id="ch03ex02"/>From: fib.go</p>
<p>The <em>math/big package</em> defines two types: one for arbitrary-length integers and one for arbitrary-size rational numbers, represented as fractions. These each define a set of operations, all following the same general, slightly unintuitive, form.</p>
<p>Operations such as <code>Add</code> are methods on these types. The receiver is set to the result of performing the operation on the two operands and returned. This means that <code>a.Add(b,c)</code> on <a id="page_55"/>a type from the big package is equivalent to <code>a = b + c</code> on built-in numeric types.</p>
<p>The example at the start of this section shows how to use big integers to compute the Fibonacci sequence. This program creates two big integers, one for each of the last two values in the sequence.</p>
<p>There is no explicit typing in this program (except for the small integer used for the loop). This is one of the nice things about Go: you rarely have to worry about types; you can rely on type inference everywhere. The three big integers are all pointers to big int structures. One of the advantages of garbage collection is that you don&#8217;t have to care about this. Variables will automatically be cleaned up whether they are pointer or structure types.</p>
<p>A big integer implementation of any kind will need to store an arbitrary amount of data, so it&#8217;s more efficient if we reuse them. To compute the sequence, we just add the last two values together and then loop, discarding the old last value implicitly in the addition and then swapping them.</p>
<p>The swap operation is very cheap, because they are pointer types: we are just changing how we refer to the two objects, not copying them.</p>
<h3 id="ch03lev1sec3"><a id="page_56"/>Converting Between Numbers and Pointers</h3>
<p class="pre">&#160;1&#160;&#160;<span class="EmpStrong">package</span> main<br/>&#160;2&#160;&#160;<span class="EmpStrong">import</span> "fmt"<br/>&#160;3&#160;&#160;<span class="EmpStrong">import</span> "unsafe"<br/>&#160;4<br/>&#160;5&#160;&#160;<span class="EmpStrong">func</span> main() {<br/>&#160;6&#160;&#160;&#160;&#160;str := "A Go variable"<br/>&#160;7&#160;&#160;&#160;&#160;addr := unsafe.Pointer(&#38;str)<br/>&#160;8&#160;&#160;&#160;&#160;fmt.Printf("The address of str is %d\n", addr)<br/>&#160;9&#160;&#160;&#160;&#160;str2 := (*string)(addr)<br/>10&#160;&#160;&#160;&#160;fmt.Printf("String constructed from pointer: %s<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;\n", *str2)<br/>11&#160;&#160;&#160;&#160;address := uintptr(addr)<br/>12&#160;&#160;&#160;&#160;address += 4<br/>13&#160;&#160;&#160;&#160;// This has undefined behavior!<br/>14&#160;&#160;&#160;&#160;str3 := (*string)(unsafe.Pointer(address))<br/>15&#160;&#160;&#160;&#160;fmt.Printf("String constructed from pointer: %s<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;\n", *str3)<br/>16&#160;&#160;}</p>
<p class="example"><a id="ch03ex03"/>From: ptr2int.go</p>
<p>In BCPL, there was no distinction between integer and pointer types; there was just a single word type, which stored a value that could fit in a register. If you did some arithmetic on such a value, it was treated as an integer; if you dereferenced it then it was treated as a pointer.</p>
<p>C added some explicit typing, so integers and pointers were treated as distinct types, but still allowed implicit conversions between pointers and pointer-sized integers. It also allowed various forms of arithmetic on pointers. In C, a pointer <a id="page_57"/>is just a number representing an address in memory, with a small amount of type checking to prevent you from doing some of the more obviously stupid things that it&#8217;s possible to do with pointers.</p>
<p>In Go, pointers and integers are completely distinct types. Converting between them is supported via the <em>unsafe package</em>, as shown in the example at the start of this section.</p>
<div class="note"><hr/>
<p class="title"><a id="ch03note01"/>Note</p>
<p class="notepara">Unsafe operations are not always supported. Passing the -u flag to the Go compiler disables it. This is commonly used in hosted Go environments, including the Google App Engine.</p>
<hr/></div>
<p>The first thing that you should notice about this example is that it is convoluted and verbose. This is intentional: doing low-level things with pointers is very rarely the correct thing to do, and Go doesn&#8217;t want to encourage this kind of behavior. In C, you often have to do pointer arithmetic because the language doesn&#8217;t provide a sensible way of doing what you want. In Go, you commonly only need to access pointers as integers for interfacing with other languages, or for some very low-level tasks. Abstractions like slices avoid the need in common cases.</p>
<p>The unsafe package provides a <code>Pointer</code> type, which represents an arbitrary pointer. This has some special properties. It can be cast to and from a <code>uintptr</code>, giving a numerical <a id="page_58"/>value representing the address. It can also be cast to and from any other Go pointer type. This completely bypasses the type checking mechanisms in Go, and so there is no guarantee that the resulting pointer is valid.</p>
<p>The example first converts the pointer back to its original type. It then does some invalid pointer arithmetic and tries to convert the result to a string pointer, which it then dereferences.</p>
<p>If you try running this example, then it may exit normally after showing some random value for the last two statements, but it is more likely to abort with a runtime panic delivered as a result of receiving a segmentation fault signal.</p>
<p>Don&#8217;t let the panic mislead you into thinking that Go will always catch this error. Sometimes this will appear to work correctly but give you bizarre results. The unsafe package is correctly named: It allows you to do unsafe things. Unlike C, Go makes it explicit when you are doing potentially unsafe things with pointers.</p>
<p class="pre-1">&#160;1&#160;&#160;The address of str is 0x421310a0<br/>&#160;2&#160;&#160;String constructed from pointer: A Go variable<br/>&#160;3&#160;&#160;unexpected fault address 0xd00000000<br/>&#160;4&#160;&#160;throw: fault<br/>&#160;5&#160;&#160;[signal 0xb code=0x1 addr=0xd00000000 pc=0x17053]<br/>&#160;6<br/>&#160;7&#160;&#160;goroutine 1 [running]:<br/>&#160;8&#160;&#160;bytes.(*Buffer).WriteString(0x4214e008, 0<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;xd00000000, 0x6f472041, 0xd, 0x0, ...)<br/>&#160;9&#160;&#160;&#160;&#160;go/src/pkg/bytes/buffer.go:119 +0x9d<br/>10&#160;&#160;fmt.(*fmt).padString(0x4214e098, 0xd00000000, 0<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x6f472041, 0xd00000000)<br/>11&#160;&#160;&#160;&#160;go/src/pkg/fmt/format.go:140 +0xe8<br/>12&#160;&#160;fmt.(*fmt).fmt_s(0x4214e098, 0xd00000000, 0<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x6f472041, 0x57770)<br/>13&#160;&#160;&#160;&#160;go/src/pkg/fmt/format.go:287 +0x60<br/>14&#160;&#160;fmt.(*pp).fmtString(0x4214e000, 0xd00000000, 0<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x6f472041, 0x73, 0x6f472041, ...)<br/>15&#160;&#160;&#160;&#160;go/src/pkg/fmt/print.go:504 +0xb8<br/>16&#160;&#160;fmt.(*pp).printField(0x4214e000, 0x57770, 0<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x42131080, 0x73, 0x0, ...)<br/>17&#160;&#160;&#160;&#160;go/src/pkg/fmt/print.go:744 +0xa47<br/>18&#160;&#160;fmt.(*pp).doPrintf(0x4214e000, 0x9ebf4, 0<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x400000024, 0x442148f70, 0x100000001, ...)<br/>19&#160;&#160;&#160;&#160;go/src/pkg/fmt/print.go:1046 +0x7b0<br/>20&#160;&#160;fmt.Fprintf(0x4212ea50, 0x42148008, 0x9ebf4, 0x24<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;, 0x442148f70, ...)<br/>21&#160;&#160;&#160;&#160;go/src/pkg/fmt/print.go:181 +0x7c<br/>22&#160;&#160;fmt.Printf(0x9ebf4, 0x6972745300000024, 0<br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x442148f70, 0x100000001, 0x42131080, ...)<br/>23&#160;&#160;&#160;&#160;go/src/pkg/fmt/print.go:190 +0x97<br/>24&#160;&#160;main.main()<br/>25&#160;&#160;&#160;&#160;ptr2int.go:15 +0x1ea<br/>26<br/>27&#160;&#160;goroutine 2 [syscall]:<br/>28&#160;&#160;created by runtime.main<br/>29&#160;&#160;&#160;&#160;go/src/pkg/runtime/proc.c:219<br/>30&#160;&#160;<span class="EmpStrong">exit</span> status 2</p>
<p class="example"><a id="page_59"/><a id="ch03ex04"/>Output from: ptr2int.go</p>
</body>
</html>